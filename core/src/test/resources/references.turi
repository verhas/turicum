// snippet json1
mut project = {
      name : "turicum-parent",
      packaging : "pom",
      groupId : "ch.turic",
      artifactId : "turicum-parent",
      version : "1.0.0-SNAPSHOT",
      description : "Turicum programming language",
      modules : [ "core", "maven", "cli" ]
      }
println project.name
println project.packaging
// end snippet

// snippet lazy_json1
fn get_name(){
    println "Getting name";
    "turicum-parent"
}
mut project = &{
      name : get_name(),
      packaging : "pom",
      groupId : "ch.turic",
      artifactId : "turicum-parent",
      version : "1.0.0-SNAPSHOT",
      description : "Turicum programming language",
      modules : [ "core", "maven", "cli" ]
      }
println project.name
println project.packaging
println project.name
// end snippet




// snippet blabla
println("blala")
// end snippet

// snippet first_sample
print "Hello,";
println " World"
for i=1 ; i < 3 ; i = i+1 : println(i)
// end snippet

// snippet if_value
mut z : num = {if 232 % 2 == 0 : 1 else: 2 }
println(z)
// end snippet

// snippet block_value
mut z = {
    mut k = "Hi";
    k + "cory"
    }
println(z)
// end snippet

// snippet scope1
mut z = "cory"
z = { // z is global
    println "just a print"
    mut k = "Hi" // k is local
         + z // z is accessible
    // the value of the block is the last command executed
    // 'mut' assignments result the value assigned
    }
println(z)
try:
    println(k)
catch err: println err
// end snippet

// snippet local_redefined_error
mut z = 5
try{
    z = {
        println(z);
        mut z = 3
        }
}catch ex {
    println(ex)
}
// end snippet

// snippet function_scope
mut glb = "global variable";
class A {
  fn z(){
    println("You can read glb, which is a " + glb)
    try{
       // you cannot change it without declaring that it is global
       glb = 5;
    }catch(e1){
        println("exception 1:",e1)
    }
    try{
       // you touched it as global, you cannot declare it as local anymore
       mut glb = 5;
    }catch(e2){
        println("exception 2:",e2)
    }
    global glb;
    glb = "modified"
    return "You can access glb here it is " + glb ;
  }
}
mut obj = A()
println(obj.z())
// end snippet

// snippet class_definition
class X {
  mut s = "hu"
}
println("class var ", X.s)
mut x = X();
println("object var ", x.s)
// end snippet

// snippet object_scope
class X {
  mut s = "class field"
  cls.h = "another class field"
  fn constructor {
    mut g = "object field"
  }
  fn t(){
    // access object field explicitly through 'this'
    println("this.g=",this.g)
    // the object wraps the class scope and not the other way around
    // there is no 'g' defined in the class
    try: println("cls.g=",cls.g) catch err1: println err1
    // 'g' is in the wrapped scope of the object scope
    // this is same as 'this.g'
    try: println("g=",g) catch err2: println err2
    // 'this.h' is the same as 'cls.h' because of wrapping
    println("this.h=",this.h)
    println("cls.h=",cls.h)
    println("h=",h)
    // the same is true for the other field
    // does not matter how it was defined
    println("this.s=",this.s)
    println("cls.s=",cls.s)
    println("s=",s)
  }
}
mut x = X();
x.t()
// end snippet

// snippet closure_example
mut c = {
    mut whom = "World!";
    {|greeting|
        println(greeting,whom);
        whom = "Universe!"
    }
}
c("Hello, ")
c("Hi, ")
// end snippet

// snippet macro_example
mut c = macro(
    {|condition,then,`else`|
        if evaluate(condition) : evaluate(then) else: evaluate(`else`)
    })

print(

    c(true,"yes, it is true",{ println("this will never be printed") })

    );
// end snippet

// snippet let_with_types_example
mut c : str |num = 3;
c = "" + c + " == " + c
println(c)
// end snippet

// snippet pinning
mut turicum = 13
mut `list` = [1,2,3]
mut object = { x:1, y:2};
pin turicum, [`list`], {object}

try {
  turicum = 14;
}catch e1: println("could not change the variable")

try {
  `list`[1] = 0;
}catch e2: println("could not change the `list`")
`list` = [ 0, ..`list`, 4]
println("variable 'list' still can be changed: ", `list`)

try {
  object.x = 3;
}catch e3: println("could not change the object")
object = { x:1, y:3 }
println("variable 'object' still can be changed: ", object)

// end snippet

// snippet ifCommand
mut a= 13
if a%2 == 0: println("even") else: println("odd")
a = {if a%2 == 0: "even" else: "odd"}
print("again ",a)
// end snippet

// snippet whileLoop
mut i = 1;
while i < 5 {
  print(i," ");
  i = i + 1;
}until i % 3 == 0;
// end snippet

// snippet whileLoop2
 mut i = 1;
while i < 5 :
  i = i + 1;
until i % 3 == 0;
println(i)
// end snippet

// snippet for1
for i = 1 ; i < 5 ; i=i+1 {
  print(i," ")
}until i%3 == 0 ;
// end snippet
// snippet for2
for( i = 1 ; i < 5 ; i=i+1 ){
  print(i," ")
}
// end snippet
// snippet for3
// same as 'for( mut i = 1 ;' ...
for( i = 1 ; i < 5 ; i=i+1 ){
  print(i," ")
}until i%3 == 0 ;
try:
    println("i at end=",i);
catch err { println(); println err ; }
// end snippet
// snippet for4
mut i;
for {i = 1} ; i < 5 ; i=i+1 :  print(i," "); until i%3 == 0;
println("i at end=",i);
// end snippet
// snippet foreach1
for each i in [1,2,3,4]: print(i," ");
// end snippet

// snippet foreach2
for each i ∈ [1,2,3,4]: print(i," "); until i%3 == 0
// end snippet

// snippet foreach3
for each z with i in ["apple", "banana", "orange", "peach"] {
    println "%s. %s" % [i,z]
}
// end snippet

// snippet yield1
fn gen_1_to_10 {
    for i=1 ; i <= 10 ; i = i + 1:
        yield i;
}

println([ .. (async gen_1_to_10()) ])
// end snippet

// snippet yield2
fn gen_1_to_10 {
    for i=1 ; i <= 10 ; i = i + 1:
        yield i;
}

mut st = async gen_1_to_10();
while st.has_next() :
    println(st.next());
// end snippet

// snippet fun1
fn inc(x) {
  x+1
}
println(inc)
println(inc(1))
// end snippet

// snippet fun3
fn inc x {
  x+1
}
println(inc)
println(inc(1))
// end snippet

// snippet fun2
mut inc = fn (x) {
  x+1
}
println(inc)
println(inc(1))
// end snippet

// snippet fun4
fn inc !x, @how_much {
  x+how_much
}
println(inc)
println(inc(1,how_much=5))
// end snippet

// snippet fun5
fn inc !x, @how_much=1 {
  x+how_much
}
println(inc(1,how_much=5))
println(inc(1))
// end snippet

// snippet fun6
fn wrong !x, h, !k {
  // just don't do
}
try: wrong(1,3, h= 2)
catch e: println("There is an error",e)
// end snippet

// snippet restParameters
mut f = fn (a,b,[rest]) {
  println("a=",a)
  println("b=",b)
  for each r in rest: print("%s " % r)
}

f(1,2,3,4,5,6)
// end snippet

// snippet metaParameters
mut f = fn (a,b,{meta}) {
  println("a=",a)
  println("b=",b)
  for each r in keys(meta): print("%s=%s\n" % [r , meta[r]])
}

f(1,b=2,k=3,x=4,juice=5,six=6)
// end snippet

// snippet metaRestParameters
mut f = fn (a,b,[rest],{meta}) {
  println("a=",a);
  println("b=",b);
  for each r in keys(meta): print("%s=%s\n" % [r , meta[r]]);
  println("rest:");
  for each r in rest: print("%s " % r);
}

f(1,b=2,k=3,x=4,juice=5,7,six=6);
// end snippet

// snippet closureArgument
mut f = fn (a,b,^closure) {
  println("a=",a);
  println("b=",b);
  println(closure(a,b))
}

f(2,3){|x,y| x+y}
f(2,3){|x,y| x*y}
// end snippet
// snippet spread
fn a(@a,@b,@c,@d){
    println("%s %s %s %s " % [a,b,c,d])
}
fn b(!a,!b,!c,!d){
    println("%s %s %s %s " % [a,b,c,d])
}
fn c(a,b,c,d){
    println("%s %s %s %s " % [a,b,c,d])
}

a(..{a:1,b:2,c:3,d:4});
b(..[1,2,3,4]);
c(..[1,2],..{d:4},3);
// end snippet

// snippet spreadStream
fn c(a,b,c,d){
    println("%s %s %s %s " % [a,b,c,d])
}
fn numbers {
  for i = 1 ; i <= 4 ; i = i + 1 : yield i
}

c(..(async numbers()))
// end snippet

// snippet closureDecorator1
  fn closure_decorator(^closure){
    {|| println("We start"); closure(); println("We finish")}
  }

  mut z = closure_decorator(){|| println("We are closure") }

  z()
// end snippet

// snippet closureDecorator2
  fn closure_decorator(^closure){
    {|| println("We start@"); closure(); println("We finish@")}
  }

  mut z = @closure_decorator(){|| println("We are closure") }

  z()
// end snippet

// snippet fnDecorator1
  fn fun_decorator(^closure){
    {|| println("We start the fun"); closure(); println("The fun is over")}
  }

mut z =
@fun_decorator()
fn q(){
  println("We function");
}
  z()
// end snippet

// snippet fnDecorator2
  fn fun_decorator(^closure){
    {|| println("We start the fun"); closure(); println("The fun is over")}
  }

mut z =
fun_decorator(
fn q(){
  println("We function");
})
  z()
// end snippet

// snippet fnDecorator3
mut fun_decorator={|^closure|
        set(closure.name,
            {|| println("We start the fun"); closure(); println("The fun is over")}
           )
    }

@fun_decorator()
fn q(){
  println("We function");
}

q()
// end snippet

// snippet fnDecorator4
{
    fn globalize(^closure){
            set_global(closure.name,closure)
        }

    @globalize()
    fn q(){
      println("We function");
    }
}
q()
// end snippet

// snippet that
class OuterClass {
    mut name = "outer class";
    fn init(){
      mut name = "outer object"
    }
    class InnerClass {
        mut name = "inner class";
        fn init() {
            mut name = "inner object"
            println("this name %s " % this.name)
            println("this name %s " % cls.name)
            println("this name %s " % that.name)
            println("this name %s " % that.cls.name)
            }
        }
    }
mut outer = OuterClass()
mut inner = outer.InnerClass()
// end snippet

// snippet fibonacci1
fn fib(x) {
    if x == 1 || x == 0 : 1
    else: fib(x - 1) + fib(x - 2)
}
println(fib(10))
// end snippet

// snippet fibonacci2
class FibCalculator {
    mut cache = [];
    fn fib(x) {
        if x == 1 || x == 0 : 1
        else{
            return cache[x] when cache[x] != none;
            cache[x] = fib(x - 1) + fib(x - 2);
        }
    }
}
println(FibCalculator.fib(10))
// end snippet

// snippet fibonacci3
try
{
    fn fib(x) {
        if x == 1 || x == 0 : 1
        else: fib(x - 1) + fib(x - 2)
    }
    println(fib(10))
}catch ex : println(ex)
// end snippet

// snippet fibonacci4
{
    mut fib={|x|
        if x == 1 || x == 0 : 1
        else: fib(x - 1) + fib(x - 2)
    }
    println(fib(10))
}
// end snippet

// snippet fibonacci5
{
    fn fib(x,fib=fib) {
        if x == 1 || x == 0 : 1
        else: fib(x - 1) + fib(x - 2)
    }
    println(fib(10))
}
// end snippet

// snippet fibonacci6
{
    fn fib(x) {
        if x == 1 || x == 0 : 1
        else: me(x - 1) + me(x - 2)
    }
    println(fib(10))
}
// end snippet

// snippet fibonacci7
mut fib = {
    mut cache = [];
    {|x|
        if x == 1 || x == 0 : 1
        else{
            return cache[x] if cache[x] != none;
            cache[x] = me(x - 1) + me(x - 2);
        }
    }
}
println(fib(10))
// end snippet

// snippet fibonacci8
class FibCalculator {
    fn init(start=1) {
        mut cache = [];
    }
    fn fib(x) {
        if x == 1 || x == 0 : start
        else{
            return cache[x] if cache[x] != none;
            cache[x] = fib(x - 1) + fib(x - 2);
        }
    }
}
println(FibCalculator().fib(10))
println(FibCalculator(2).fib(10))
// end snippet

// snippet evaluate1
mut twice = macro(fn (arg){ evaluate(arg); evaluate(arg);});
twice( {println("Hello")} )
// end snippet

// snippet evaluate2
macro(fn (!arg,[rest],{meta},^closure)
            { evaluate(arg)(..rest,..meta,..closure)}
     )(fn () {println("Hello")})
// end snippet

// snippet evaluate3
(fn (!arg,[rest],{meta},^closure)
            { arg(..rest,..meta,..closure)})
     (fn () {println("Hello")})
// end snippet

// snippet import
try{
mut MyImport = import("mod.ul.name.file")
mut my_function = MyImport.imported_function;
my_function("hello")
}catch e{}
// end snippet

// snippet class1
class A {
    fn init {
        mut a = "a";
    }
    mut c = "c"
}
mut a1 = A()
mut a2 = A()
a1.a = "1"
a2.a = "2"
A.c = "d"
println a1.a, a2.a, a1.c, a2.c

// end snippet

// snippet class2
class A {
    fn init {
        this.a = "a";
    }
    cls.c = "c"
}
mut a1 = A()
mut a2 = A()
a1.a = "1"
a2.a = "2"
A.c = "d"
println a1.a, a2.a, a1.c, a2.c

// end snippet

// snippet class3
class A {
    fn init {
        this.a = "a";
    }
    fn p {
        println "I am class level"
    }
}
mut a1 = A()
a1.p()
a1.p = fn (){
  println "I am a1"
}
mut a2 = A()
a2.p = fn (){
  println "I am a2"
}

a1.p()
a2.p()

// end snippet

// snippet class4
class A {
    fn p {
        this = none
    }
}
try :
    A().p()
catch ex :
    println ex
// end snippet

// snippet class5
class A {
    fn p {
        cls = none
    }
}
try :
    A().p()
catch ex :
    println ex
// end snippet

// snippet class6
class A {
    fn init {
      this = B()
    }
}

class B {

}

println A().cls

// end snippet

// snippet class7
class A {
    fn init {
      cls = B
    }
}

class B {

}
try:
    A()
catch ex:
    println ex

// end snippet

// snippet class8
class A {
    class B {
        fn init {
            println "this ", this
            println "cls ", cls
            println "that ", that
        }
    }
}

mut a = A()
mut b = a.B()
// end snippet

// snippet try1
mut z = {
    try {
        z = 55 // undefined variable
    }catch e {
      66
    } finally {
      println "this will always run"
    }
}
println "z is now 66, is it ? ",z
// end snippet

// snippet try2
try{
    try {
        z = 55 // undefined variable
    }
}catch e: println e
// end snippet

// snippet try3
try{
        z = 55 // undefined variable
}catch x : mut error:err = x

println error

// end snippet

// snippet try4
try{
        z = 55 // undefined variable
}catch error: ;

println """message "%s" """ % [error.message]
println """cause "%s" """ % [error.cause]
println """suppressed %s" """ % [error.suppressed]
for each st in error.stack_trace {
    println("%s:%s:%s" % [st.file, st.line, st.column])
    println "source: ", st.source
    }


// end snippet

// snippet try5
mut error:err|none
try{
        z = 55 // undefined variable
}catch err: error = err

println """message "%s" """ % [error.message]
println """cause "%s" """ % [error.cause]
println """suppressed %s" """ % [error.suppressed]
for each st in error.stack_trace {
    println("%s:%s:%s" % [st.file, st.line, st.column])
    println "source: ", st.source
    }


// end snippet

// snippet try6
try : (mut a = 1;
       mut b = 2;
       mut c = 1 / 0;
      )
catch e : println e;

println "Do we have a? ", is_defined(a)
println "Do we have b? ", is_defined(b)
println "Do we have c? ", is_defined(c)
// end snippet

// snippet try7
mut a = 3;
try : (mut a = 1;
       println "we redefined 'a'"
       mut b = 2;
       println "we defined 'b'"
      )
catch e : println e;

println "Do we have a? ", is_defined(a)
println "Was it changed or still 3? It is ",a
println "Do we have b? ", is_defined(b)
// end snippet

// snippet pscope

println "2*3=",2*(mut s=3)
println "s is defined and it is ",s
println "2*3=",2*{mut k=3}
try : mut h = 2*k
catch e : println e;
// end snippet

// snippet type1

mut s = "13"; mut i = 13; mut d = 3.14;

mut err
try: z = 6.55
catch ex: err=ex
class A {}

println "\"13\" ", type("13")
println "13 ", type(13)
println "3.14 ", type(3.14)
println "err ",type(err)
println "A() ",type(A())
println "[1,2,3] ",type([1,2,3])
println "A ",type(A)
println "fn()=3 ",type(fn()=3)
println "{|| 3} ",type({|| 3})
println "que(1) ",type(que(1))
println "async ",type(async 1)
println "macro ",type(macro(fn()=3))
println "none ",type(none)
println "java object ", type(java_object("java.lang.Object"))

// end snippet

// snippet sleep

sleep(0.001) // sleep one mili

// end snippet

// snippet reclose
fn my_fun(@close_it) {
  mut s: str = "in function";
  return reclose(close_it)
}

mut s:str ="outer";
mut closure = {|x| println s; s = x};
mut reclosure = my_fun(close_it=closure);

closure("closure 1")
reclosure("reclosure 1")
println "s = %s" % s

closure("closure 2")
reclosure("reclosure 2")
println "s = %s" % s
// end snippet

// snippet die

sys_import "turi.throw"

try:
    throw "wuff"
catch ex:
    print "don't die"
// end snippet

// snippet que
/**
 * A printing function that will print the objects received through the que `q` till it gets closed.
 */
fn printer(q,@name){
    mut n = 0 // counts the number of not ready que attempts
    while {
        mut s = q.try_receive(); // try to receive one or get none if there is nothing in the queue
        return { println "%s is done" % name } if q.is_closed(); // return when the que is closed
        if s == none {
            println "%s is not ready %s" % [name,n]
            n = n + 1 // count the attempts
            sleep 0.003 // sleep 3 mili
        } else {
            n = 0 // reset the attempts, we go an object to print
            println "%s is ready %s" % [name,s];
        }
    }
}

// create ONE queue that will be consumed by two
mut q : que = que(3)
// create two asynchronous task. they start immediately
mut task1 : task = async printer(q,name="task1")
mut task2 : task = async printer(q,name="task2")
// send the numbers 1 to 10 to the queue, whoever is lucky can get it
for i=1 ; i < 10 ; i = i +1 {
    q.send(i);
    sleep 0.01
    }
println "closing the channel"
q.close();
println "channel is closed"
println "1 is done %s" % task1.is_done()
println "2 is done %s" % task2.is_done()

// get only the tasks into the list which are not done yet
mut task_list = [ task1, task2 ? !it.is_done() ]

println "we start to wait the first time"
await task_list

println "task1 done %s" % task1.is_done()
println "task2 done %s" % task2.is_done()
println "We start to wait the second time"
// have to use [] empty options, no timeout because a list literal stands after it
await[] [ task1, task2 ? !it.is_done() ]

println "task1 done %s" % task1.is_done()
println "task2 done %s" % task2.is_done()

none
// end snippet

// snippet async_list

mut z = async[] [ 1, 2,  3, 4];
mut k = await z
print k

// end snippet
// snippet try_yield
fn printer(){
    mut n = 0
    while {
        mut s = try_yield();
        return { println "we are done" } if yield_is_closed();
        if s == none {
            println "not ready %s" % n
            n = n + 1
            sleep 0.003
        } else {
            n = 0
            println "received %s" % s;
        }
    }
}

mut task : task = async printer()
for i=1 ; i < 4 ; i = i +1 {
 println "sending ",i
 task.send(i);
 sleep 0.009
 }
println "closing the channel"
task.close();
println "channel is closed"
println "is done %s" % task.is_done()
await task
println "is done %s" % task.is_done()

none
// end snippet

// snippet async
mut t:task = async {
    for i=0 ; i < 10 ; i = i + 1 {
        yield i
    }
    55
}

while t.has_next():
    print t.next(), " "
println()
println(await t)

// end snippet

// snippet channel_limit

/**
  * a very simple prime number filter
  */
fn is_prime(x:num):bool {
    return true if x == 2;
    return false if x % 2 == 0;
    for n = 3 ; n*n <= x ; n = n + 2 :
        return false if x % n == 0
    true
}
/**
  * Create a generator with limited que size.
  * Then read from it and print.
  */
fn execute(name:str, que_length:num){
    mut prime = async[in=que_length] {
        yield 2;
        mut i = 3;
        while {
            if is_prime(i) {
                yield i
                println name, " generated ", i
            }
            i = i + 2; // only the odd numbers
        }
    }

    mut count = 0
    while prime.has_next(){
        println " prime read ",prime.next()
        count = count + 1
        }until count > 3 // limit the printout to the first three primes
    sleep 1 // will give time for the generator to run ahead uselessly
    println "stopping"
    prime.stop()
    // the error is cancellation, since we stopped the task
    try: await prime catch e : println "exception ", e
}
// only 5 for demonstration, in real life it can be millions eating memory
// five now stands for "unlimited size"
execute("Thread 1",5)
// limited channel size will stop the running ahead
execute("Thread 2",2)
// end snippet


// snippet flat_let_object1

mut z = { a: "apple", b:"bier", c : "count" }
mut {a, b, c} = z
println a
println b
println c
// end snippet

// snippet flat_let_object2

mut z = { a: "apple", b:"bier", c : "count" , d: "not used" }
mut {a, b, c, f} = z
println a
println b
println c
println f
// end snippet

// snippet flat_let_list1
mut [a, b, c] = [1,2,3]
println a
println b
println c
// end snippet

// snippet flat_let_list2
try:
    mut [a, b, c, f] = [1,2,3]
catch err: println err
// end snippet

// snippet flat_let_list3
try:
    mut [a, b] = [1,2,3]
catch err: println err
// end snippet

// snippet flat_let_list4
mut [a, b] = [1,2,3,4,5,6,7,8][0..2]
println a
println b
// end snippet

// snippet flat_let_list5
fn adjust(_x, @to){
    mut x = _x
    if len(x) < to :
        while len(x) < to :
            x = [..x, none]
    else :
        x = x[0..len(x)]
    x
}
mut [a, b, c, d] = adjust(to=4,[1,2])
println a
println b
println c
println d
// end snippet

// snippet flat_let_list6
fn adjust(@to,[_x]){
    mut x = _x
    if len(x) < to :
        while len(x) < to :
            x = [..x, none]
    else :
        x = x[0..len(x)]
    x
}
mut [a, b, c, d] = adjust(to=4, 1,2)
println a
println b
println c
println d
// end snippet

// snippet re
sys_import "turi.re"

fn print_match(m){
    for i=0 ; i < len(m.group) ; i = i + 1 {
        mut {index, start, end } = m.group[i];
        println "%s. '%s'.substring(%s,%s)='%s'" % [index,s,start, end,s[start..end]];
    }
}

mut s = "abrakadabra";
mut rx =Re("a(b)ra(ka)(dabra)")
mut m = rx.match(s);
println m
print_match(m);

s = "xxx"+s+"yyy";
m = rx.match(s);
if m.group == none :
    println "does not match because of xxx and yyy"
println m, " is an empty object"
m = rx.find(s)
if m.group != none :
    println "matches because we find and not match"
print_match(m);
// end snippet


// snippet re2
sys_import "turi.re"

mut m = Re("a(?<firstb>b)ra(?<twoletter>ka)(dabra)").match("abrakadabra");
println "the ks is '%s'" % [m.name.twoletter]
// end snippet

// snippet preprocessorSample
fn hi(){ // this will be deleted, it only exists in the preprocessor context
  "hello "
}
// the next line starts the preprocessor
# {|lexes|
["""
    // this is a string that will lead the new lexical token list
    mut M:str = ""
    fn helvetic_hi(){
      "Gruetzi "
    }
    M = M + "hello ";
    M = M + (hi() or "none ");
""",
// and just mut's have the rest of the tokens
..lexes]
} // end of the preprocessor command

// this is preprocessed
M = M + helvetic_hi() + "ant hunter"
print M
// end snippet

// snippet inherit1
class P {
    fn a()=1
    mut v = 2
}
class C : P {
    fn b()=3
    mut z = 4
}
mut o = C();
println o.a(),o.v,o.b(),o.z;
// end snippet

// snippet inherit2
class P1 {
    fn a()=1
    mut v = 2
}
class P2 {
    fn aa()=3
    mut vv = 4
}
class C : P1,P2 {
    fn b()=5
    mut z = 6
}
mut o = C();
println o.a(), o.v, o.aa(), o.vv, o.b(), o.z;
// end snippet

// snippet inherit3
class P1 {
    fn a()=1
    mut v = 2
}
class P2 {
    fn a()=3
    mut v = 4
}
class C : P1,P2 {
    fn b()=5
    mut z = 6
}
mut o = C();
println o.a(), o.v, o.b(), o.z;
// end snippet

// snippet inherit4
class P1 {
    fn init {
        println "init in P1, cls='%s' this='%s'" % [cls, this]
    }
}
class P2 {
    fn init {
        println "init in P2, cls='%s' this='%s'" % [cls, this]
    }
}
class C : P1,P2 {
    fn init {
        println "init in C, cls='%s' this='%s'" % [cls, this]
    }
}
mut o = C();
// end snippet

// snippet inherit5
class P1 {
    fn init {
        println "init in P1, cls='%s' this='%s'" % [cls, this]
    }
}
class P2 {
    fn init {
        println "init in P2, cls='%s' this='%s'" % [cls, this]
    }
}
class C : P1,P2 {
    fn init {
        println "init in C, cls='%s' this='%s'" % [cls, this]
        P1.init()
        P2.init()
    }
}
mut o = C();
// end snippet

// snippet inherit6
class P {
    fn init {
        println "init in P, cls='%s' this='%s'" % [cls, this]
    }
}
class C : P {
}
mut o = C();
// end snippet

// snippet fun7
fn concat(a:str, b:str):str = a + b
println concat("ab","ba")
// end snippet

// snippet fun8
fn concat(a:str, b:str):str = 13
try:
    println concat("ab","ba")
catch err: println err
// end snippet

// snippet fun9
mut myString="num"
fn concat(a:str, b:str):(myString) = 13
myString = "str"
try:
    println concat("ab","ba")
catch err: println err
// end snippet

// snippet fun10
class K {   fn p()=(println "original K") }
fn h():K = K()
h().p()
// end snippet

// snippet fun11
class K {   fn p()=(println("original K")) }
fn h():K = K()
h().p()
// end snippet

// snippet is_defined
if is_defined(z) : println "defined" else: println "not defined";
mut z = 1
if is_defined(z) : println "defined" else: println "not defined";
try:
    println {if is_defined(z+2) : "defined" else: "not defined"}
catch: println "no way"
// end snippet


// snippet objectAddition1
class LN {
    fn init( a ){

    }
    fn `+` ( other ){
            LN( this.a * other.a )
    }
}
println( (LN(2) + LN(4)).a )
// end snippet

// snippet objectAddition2
class LN {
    fn init( a ){

    }
    fn `+` ( other ){
            LN( this.a * other.a )
    }
}
println {LN(2) + LN(4)}.a
// end snippet

// snippet myEqual
class A {
  fn `==`(other) : bool {
    this.a == other.a
  }
}

mut x = A()
mut y = A()
mut z = { a: 1, b: "x" }

x.a = 1
x.b = "x"

y.a = 1
y.b = "y"

println "x == y is %s" % (x == y)
println "y == z is %s" % (y == z)
// end snippet

// snippet myEqual2
class A {
  fn `==`(other) : bool {
    return false if cls != other.cls
    a == other.a
  }
}

mut y = A()
mut z = { a: 1, b: "x" }

y.a = 1
y.b = "y"

println "y == z is %s" % (y == z)
// end snippet

// snippet unlet
class Z {
    fn init(obj){
        for each t in keys(obj){
            this[t] = obj[t]
        }
        unlet obj;
    }
}
mut z = Z({
    a: {
        B : "abraka"
        },
    c : ""
    });
println z
// end snippet

// snippet ListLiteral1
mut computed = {fn(a,b) = a + b}(1,2);
println [1, 2, 3, 4]
println ["apple", "banana", "cherry"]
println [1 + 2, computed]
// end snippet

// snippet ListLiteral2
mut a = [1, 2, 3, 4]
mut b = ["apple", ..a, "banana", "cherry"]
println b
// end snippet

// snippet ListLiteral3
mut a = [1, 2, 3, 4]
mut b = [5, 6, 7]
println([..a, ..b])
// end snippet

// snippet ListLiteral4
mut a = [1, 2, 3, 4]
mut b = [1, 3]
println a,"+",b,"=", a+b
println a,"-",b,"=", a-b
println a,"*", b,"=", a*b
println a,"+\"sixteen\"=", a+"sixteen"
println a,"-",2,"=", a-2
// end snippet

// snippet ListLiteral5
mut a = [1, 2, 3, 4]
mut b = [1, 3]
println a+[b]
// end snippet

// snippet ListLiteral6
mut a = [1, 2, 3, 4]
println [a[0],..a[2..inf]]
// end snippet

// snippet ListLiteral7
mut a = [1, 2, 3, 4 ? {|x| x % 2 == 0 } ]
println a
// end snippet

// snippet ListLiteral8
mut a = [1, 2, 3, 4 ? {|x| x % 2 == 0 } -> {|z| return z/2 }]
println a
// end snippet

// snippet ListLiteral9
mut a = [1, 2, 3, 4 ? {|| it % 2 == 0 } -> {|| return it/2 }]
println a
// end snippet

// snippet ListLiteral10
mut a = [1, 2, 3, 4 ? it % 2 == 0  -> it/2 ]
println a
// end snippet

// snippet xor1
println 12 ^ 2
println 12.0 ^ 2
println( [1,2,3] ^ [3,4,5] )
// end snippet

// snippet mod1
println "2*3=%s" % [2*3]
println "2/3=%s" % [2/3]
println "2%%3=%s" % [2%3]
println "aa " * 6
println( [1,2] * [6])
println( [1,2,3] % [3,4,5] )
println( [1,2,3 ? it in [3,4,5]] )
// end snippet

// snippet shr1
println 8>>2
println "artany" >> "...... ..."
println([1,2,3] >> [-1,-2,-3])
// end snippet

// snippet equal1
mut k = { a:1 , b:2 }
mut q = { a:1 , b:2 }
mut w = "ohmy"
println 1 == 1, " one is one"
println 1 == 2, " one is not two"
println 1 === 1, "one is the same as one"
println 1 === 2, "one is not the same as two"
println k == q, "k equals q, but"
println k === q, "k is not the same as q"
println w == "ohmy", " w is 'ohmy'"
println w === "ohmy", " w is not that 'ohmy'"
// end snippet

// snippet inop
println "raka" in "avraka dabra", " there is 'raka' in 'avraka dabra'"
println "raka" in "evreke debre", " there is no raka in 'evreke debre'"
println 3 in [1,2,3], " 3 is in [1,2,3]"
println 3 in [1,2,4], " 3 is not in [1,2,4]"
// end snippet

// snippet bor1
println 1 | 2
println( [1,1,2,3,3,2,1] | [])
try:
    3.0 | 3.14
catch e: println e
// end snippet

// snippet band1
println 7 &  2
println( [1,1,2,3,3,2,1] & [2, 3, 7])
try:
    3.0 & 3.14
catch e: println e
// end snippet

// snippet compare
println 1 < 2
println 3 <= 3
println 4 > 3
println 4 >= 4
// end snippet

// snippet and
if (7&2) == 3 && 5/0 == inf {
    println "something is wrong"
}else{
    println "dandy"
}
// end snippet

// snippet logical_or
if (7&2) == 2 || 5/0 == inf {
    println "dandy"
}else{
    println "something is wrong"
}
// end snippet

// snippet oror
println none or 3
// end snippet

// snippet string_functions
println " 1. ","alma kadarka".after("ka")
println " 2. ","alma kadarka".before("ka")
println " 3. ","alma kadarka".between("ma","da")
println " 4. ","aa ".times(6)
println " 5. "," aa ".trim()
println " 6. ","aa ".starts_with("a")
println " 7. ","aa".ends_with("a")
println " 8. ","AA".lower_case()
println " 9. ","aa".upper_case()
println "10. ","a,b,c,d".split(",")
println "11. ","abcd".bytes()
println "12. ","abc".char_at(2), " is c"
println "13. ","alma kadarka".index_of("ka")
println "14. ","alma kadarka".last_index_of("ka")
println "15. ","alma kadarka".replace_all("a|d","e")
println "16. ","\n\t\r".quote()
println "17. ","alma kadarka".reverse()
println "18. ","alma kadarka".chop().chop()
println "19. ","alma kadarka\n".chomp()
println "20. ","alma kadarka".chomp()
println "21. ","alma kadarka".contains("ma ka")
println "22. ","alma kadarka".left(4)
println "23. ","alma kadarka".right(4)
println "24. ","alma kadarka".count_substring("a")
println "25. ","kadarka".pad_left(12)
println "26. ","kadarka".pad_left(".",12)
println "27. ","kadarka".pad_right(12) + "<"
println "28. ","kadarka".pad_right(".",12)
println "29. ","   ".is_blank()
println "30. ","   ".is_empty()
println "31. ","+6.2E23".is_numeric()
println "32. ","+6.2E23".is_digit()
println "33. ","6223".is_digit()
println "34. ","Euler Number".is_numeric()
println "35. ","EulerNumber".is_alpha()
println "36. ","EulerNumberisnot314".is_alphanumeric()
println "37. ","2AF".is_hex()
println "38. ","0x2AF".is_hex()
println "39. ","2AF".hex()
println "40. ","0x2AF".hex()
println "41. ","0x2AF".base64()
println "42. ","MHgyQUY=".from_base64()
println "43. ","MHgyQUY=".from_base64_str()
println "44. ","alma van a fa = alarr://".url_encode()
println "45. ","alma+van+a+fa+%3D+alarr%3A%2F%2F".url_decode()
println "46. ","line 1\nline2\n\nline4".lines()
println "47. ","What do you read, my lord? Words, words, words.".words()
println "48. ","alma kadarka".remove_prefix("alma")
println "49. ","alma kadarka".remove_postfix("kadarka")
println "50. ","alma kadarka".remove_prefix("apple")
println "51. ","alma kadarka".remove_postfix("kik")
println "52. ",">" + ("alma".safe_char_at(666)) + "<"
println "53. ",",".join(["abrak","a","dabra","lonak","zabla"])
println "54. ","aaa".md5()
println "55. ","aaa".sha_1()
println "56. ","aaa".sha_256()
println "57. ","aaa".sha_512()
println "60. ","aaa".digest("MD5")
println "61. ",61.hex()
println "62. ","mut z = if a == 3 :  3 else: 5;".turi_lex()
println "63. ","mut M= \"\"; for i=0 ; i < 8 ; i = i +1 : M = M + i; M".execute()
println "64. ",M
// end snippet

// snippet hexNumber
mut z = 0xFfE3;
println z
// end snippet

// snippet string
print "this is a simple string"
// end snippet

// snippet mlstring
println """
Hello,
  This is a multiline string.
Goodbye.
"""
// end snippet

// snippet simpleWith
mut x = {a:1,b:2};
mut y = {a:4,c:5};
with x,y {
    println a
    println b
    println c
}
// end snippet

// snippet modifyWith
mut x = {a:1,b:2};
mut y = {a:4,c:5};
with x,y {
    a = 0
    b = 0
    c = 0
    mut k = 55;
}
println x
println y
// end snippet

// snippet valueWith
mut x = {a:1,b:2};
mut y = {a:4,c:5};
println {with x,y : a * b + c}
// end snippet

// snippet entryAndExitWith
class A {
    fn init(a=1,b=2);
    fn entry {
        println "entry to A"
    }
    fn exit {
        println "exit fom A"
    }
}
class B {
    fn init(a=4,c=5);
    fn entry {
        println "entry to B"
    }
    fn exit {
        println "exit fom B"
    }
}
mut x = A();
mut y = B();
with x,y {
  println "executing with A and B"
}
// end snippet

// snippet entryAndExitWith2
class A {
    fn init(a=1,b=2);
    fn entry {
        println "entry to A"
        { a: 7, b:8 }
    }
    fn exit e:err|none {
        println "exit fom A"
    }
}
class B {
    fn init(a=4,c=5);
    fn entry {
        println "entry to B"
    }
    fn exit (e){
        println "exit fom B"
    }
}
with A() as x, B() as y {
  println x.a,x.b,y.c
}
// end snippet
// snippet withAs
class Resource {
    fn init(a=1,b=2);
    fn entry {
        println "entry to A"
        // the value is not instance of A
        { a: 7, b:8 }
    }
    fn exit(e){
        println "exit fom A"
        return none // if there is an error, mut it go
    }
}
with Resource() as a {
    println type(a)
    println a.a
    println a.b
}
// end snippet


// snippet withAsExceptionHandled
class Resource {
    fn init(a=1,b=2);
    fn entry {
        println "entry to A"
        // the value is not instance of A
        { a: 7, b:8 }
    }
    fn exit(exception) {
        println "exit fom A"
        if exception != none:
            println "There was an exception '%s'" % [exception.message]
        return true // we handled the exception, no more
    }
}
with Resource() as a {
    die "Raise an exception"
}
println "Exception was eliminated"
// end snippet

// snippet is_type
class A {}
class B : A {}
mut K = class : B {}
mut z = K()
println is_type(z,"A")," yes"
println is_type(z,"H")," no"
println is_type(z,"K")," no" // it is a no named class
println is_type(z,K)," yes"
println is_type(z,A)," yes"
println is_type(z,"#undefined")," yes" // bit strange, but actually
// end snippet

// snippet parents
class A {}
class B : A {}
mut K = class : B {}
println([ ..parents(K) -> type(it()) ])
// end snippet

// snippet all_parents
class A {}
class B : A {}
mut K = class : B {}
println all_parents(K)
println([ ..all_parents(K) -> type(it()) ])
// end snippet

// snippet rng
mut z = rng(0,9223372036854775807)
mut i = 0
for each k in z {
  println k
  i = i + 1
}until i > 5
// end snippet

// snippet rngThousand
mut z = rng(0,1000)
mut array = [ ..z ]
print( [..array[0 .. 5], ..array[-5 .. array.length]])
// end snippet

// snippet rangeThousand
sys_import "turi.range"
mut z = range(start=0,end=1000,closend=true)
mut array = [ ..z ]
print( array[0 .. 5] + array[-5 .. array.length])
// end snippet

// snippet rngRange
mut z = rng(100,9223372036854775807,100)
mut range = z[20..2000000]
print( [..range[0 .. 5], ..range[-5 .. range.length]])
// end snippet

// snippet rngErrs
try:
    rng(1,10,-1)
catch e1:
    println e1.message
try:
    rng(10,1,+1)
catch e2:
    println e2.message
try:
    rng(10,11,0)
catch e3:
    println e3.message

println "Special zero element range can have zero as step %s" % [rng(10,10,0)]
println "but it is just the same as %s" % [rng(10,10)]

// end snippet

// snippet asyn_list
fn sleeper(x) {
    sleep 0.1
    x
    }
{
mut start = nano_time()
mut serial = [sleeper(1), sleeper(2), sleeper(3)]
mut end = nano_time()
println serial
println( (end-start)/1000000, "ms")
}
{
mut start = nano_time()
mut serial = [ ..async([sleeper(1), sleeper(2), sleeper(3)]) -> it.get() ]
mut end = nano_time()
println serial
println( (end-start)/1000000, "ms")
}
// end snippet

// snippet example_flow_squareroot
mut sqrt = {
    flow until epsilon < 0.0001 {
        a <- 13;
        a <- {
            mut newA = (a + 13 / a) / 2;
            println("a =", newA);
            newA;
        }
        epsilon <- abs(a - (a + 13 / a) / 2);
        yield a
    }
}

println("sqrt(13) ≈ ", sqrt);
println("square ≈ ", sqrt * sqrt);
// end snippet

// snippet example_flow_timeout
mut result = {try {
    flow timeout 0.01 {  // 10 milliseconds
        counter <- 0;
        counter <- {
            mut n = counter + 1;
            println("counter =", n);
            sleep(0.005);  // 5 milliseconds per step
            n;
        }
        yield counter
    }
}catch e: println e}

println("Final counter = ", result);
// end snippet

// snippet example_flow_limit

mut result = {try {
               flow limit 5 {
                   x <- 1;
                   x <- {
                       mut newX = x + 1;
                       println("x =", newX);
                       newX;
                   }
                   yield x
               }
           } catch e: println e.message}

           println("Final x = ", result);
// end snippet

//  flow_mermaid_output
mut norm = command({flow test {
        a <- 3;
        b <- 4;
        a <- {
            println "update a: a=%s b=%s" % [a,b]
            if a > 10 { println("a fini"); fini } else{ a + 1 };
            }
        b <- {
            println "update b: a=%s b=%s" % [a,b]
            if b > 1 { println("b fini"); non_mutat } else{ b + 2 };
            }
        yield [a,b]
    }
})

println("graph TD;")
mut d_cells = norm.commands[0].dependentCells
for each k in keys(d_cells) {
    for each dep in d_cells[k] {
        println("    %s-->%s" % [k, dep.id])
    }
}
//

// snippet thunk_unthunk
mut z = thunk({mut x = 3; println "hello"})
println "before eval"
unthunk(z)
println "after eval"
println is_defined(x) // will print false
unthunk(unwrap(z))
println is_defined(x) // will print true and
println x             // then the value
// end snippet

// snippet block_list
mut commands = block_list(thunk({k = 13; suss = "huss"; mut x = 3; println "hello"}))
println "before execution"
mut i = 1;
for each command in commands {
    mut suss;
    println "%s. before is_defined(x) = %s" % [i,is_defined(x)]
    if i == 1 {
        try: unthunk(command) catch e: println "ERROR: %s" % [e];
    } else {
        unthunk(command)
        println "%s. after is_defined(x) = %s" % [i,is_defined(x)]
    }
    i = i + 1
}
// end snippet

// snippet while_result
println {
    mut k = 0
    while k < 10 : k = k + 1
}
// end snippet
// snippet for_result
println {
    mut k = 0
    for ; k < 10 ; : k = k + 1
}
// end snippet

// snippet for_each_result
println {
    for each t with i in [1,2,3] : t + 10*i
}
// end snippet

// snippet for_list
println {for i=0; i < 10 ; i = i + 1 list: i}
// end snippet

// snippet for_each_list
println {
    for each z with i in [1,2,3] list { 10*i + z }
    }
// end snippet

// snippet while_list
mut k = 0;
println{ while k < 5 list{
            mut h = k;
            k = k + 1;
            h
         }
}
// end snippet


// snippet break1
println {
    for i=0 ; i < 10 ; i = i + 1 {
      println ".. ",i;
      break if i == 2
    }
}
// end snippet

// snippet break2
println {
    for i=0 ; i < 10 ; i = i +1 {
      println ".. ",i;
      break -2 if i == 2
    }
}
// end snippet

// snippet break3
println {
    for i=0 ; i < 10 ; i = i + 1 list{
      break if i == 2
      i;
    }
}
// end snippet

// snippet break4
println {
    for i=0 ; i < 10 ; i = i +1 list{
      break -2 if i == 2
      i;
    }
}
// end snippet

// snippet break5
println {
    for i=0 ; i < 10 ; i = i +1 list{
      break none if i == 2
      i;
    }
}
// end snippet

// snippet break6
println {
    for i=0 ; i < 4 ; i = i +1 {
      if i == 2 : break;
      println i;
    }
}
println "however"
println {
    for i=0 ; i < 4 ; i = i +1 {
      if i == 2 { break };
      println i;
    }
}
// end snippet

// snippet break7
println {
    for i=0 ; i < 4 ; i = i +1 {
      break (if i == 2 : 3 else : 4) if i == 2;
      println i;
    }
}
// end snippet

// snippet return1
fn a(x) {
    if x == 2 {
        return 2
    }
    return
}
println a(1)
println a(2)
println a(3)
// end snippet


// snippet continue1
sys_import "turi.range"

for each i in range(start=0, end=5) list{
    println i
}
// end snippet


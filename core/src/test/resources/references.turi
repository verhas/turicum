// snippet blabla
println("blala")
// end snippet

// snippet first_sample
print "Hello,";
println " World"
for i=1 ; i < 3 ; i = i+1 : println(i)
// end snippet

// snippet if_value
let z : num = {if 232 % 2 == 0 : 1 else: 2 }
println(z)
// end snippet

// snippet block_value
let z = {
    let k = "Hi";
    k + "cory"
    }
println(z)
// end snippet

// snippet scope1
let z = "cory"
z = { // z is global
    println "just a print"
    let k = "Hi" // k is local
         + z // z is accessible
    // the value of the block is the last command executed
    // 'let' assignments result the value assigned
    }
println(z)
try:
    println(k)
catch err: println err
// end snippet

// snippet local_redefined_error
let z = 5
try{
    z = {
        println(z);
        let z = 3
        }
}catch e {
    println(e)
}
// end snippet

// snippet function_scope
let glb = "global variable";
class A {
  fn z(){
    println("You can read glb, which is a " + glb)
    try{
       // you cannot change it without declaring that it is global
       glb = 5;
    }catch(e){
        println("exception 1:",e)
    }
    try{
       // you touched it as global, you cannot declare it as local anymore
       let glb = 5;
    }catch(e){
        println("exception 2:",e)
    }
    global glb;
    glb = "modified"
    return "You can access glb here it is " + glb ;
  }
}
let obj = A()
println(obj.z())
// end snippet

// snippet class_definition
class X {
  let s = "hu"
}
println("class var ", X.s)
let x = X();
println("object var ", x.s)
// end snippet

// snippet object_scope
class X {
  let s = "class field"
  cls.h = "another class field"
  fn constructor {
    let g = "object field"
  }
  fn t(){
    // access object field explicitly through 'this'
    println("this.g=",this.g)
    // the object wraps the class scope and not the other way around
    // there is no 'g' defined in the class
    try: println("cls.g=",cls.g) catch err: println err
    // 'g' is in the wrapped scope of the object scope
    // this is same as 'this.g'
    try: println("g=",g) catch err: println err
    // 'this.h' is the same as 'cls.h' because of wrapping
    println("this.h=",this.h)
    println("cls.h=",cls.h)
    println("h=",h)
    // the same is true for the other field
    // does not matter how it was defined
    println("this.s=",this.s)
    println("cls.s=",cls.s)
    println("s=",s)
  }
}
let x = X();
x.t()
// end snippet

// snippet closure_example
let c = {
    let whom = "World!";
    {|greeting|
        println(greeting,whom);
        whom = "Universe!"
    }
}
c("Hello, ")
c("Hi, ")
// end snippet

// snippet macro_example
let c = macro(
    {|condition,then,`else`|
        if evaluate(condition) : evaluate(then) else: evaluate(`else`)
    })

print(

    c(true,"yes, it is true",{ println("this will never be printed") })

    );
// end snippet

// snippet let_with_types_example
let c : str |num = 3;
c = "" + c + " == " + c
println(c)
// end snippet

// snippet pinning
let turicum = 13
let list = [1,2,3]
let object = { x:1, y:2};
pin turicum, [list], {object}

try {
  turicum = 14;
}catch e: println("could not change the variable")

try {
  list[1] = 0;
}catch e: println("could not change the list")
list = [ 0, ..list, 4]
println("variable 'list' still can be changed: ", list)

try {
  object.x = 3;
}catch e: println("could not change the object")
object = { x:1, y:3 }
println("variable 'object' still can be changed: ", object)

// end snippet

// snippet ifCommand
let a= 13
if a%2 == 0: println("even") else: println("odd")
a = {if a%2 == 0: "even" else: "odd"}
print("again ",a)
// end snippet

// snippet whileLoop
let i = 1;
while i < 5 {
  print(i," ");
  i = i + 1;
}until i % 3 == 0;
// end snippet

// snippet whileLoop2
let i = 1;
while i < 5 :
  i = i + 1;
until i % 3 == 0;
println(i)
// end snippet

// snippet for1
for i = 1 ; i < 5 ; i=i+1 {
  print(i," ")
}until i%3 == 0 ;
// end snippet
// snippet for2
for( i = 1 ; i < 5 ; i=i+1 ){
  print(i," ")
}
// end snippet
// snippet for3
// same as 'for( let i = 1 ;' ...
for( i = 1 ; i < 5 ; i=i+1 ){
  print(i," ")
}until i%3 == 0 ;
try:
    println("i at end=",i);
catch err { println(); println err ; }
// end snippet
// snippet for4
let i;
for {i = 1} ; i < 5 ; i=i+1 :  print(i," "); until i%3 == 0;
println("i at end=",i);
// end snippet
// snippet foreach1
for each i in [1,2,3,4]: print(i," ");
// end snippet
// snippet foreach2
for each i âˆˆ [1,2,3,4]: print(i," "); until i%3 == 0
// end snippet

// snippet yield1
fn gen_1_to_10 {
    for i=1 ; i <= 10 ; i = i + 1:
        yield i;
}

println([ .. (async gen_1_to_10()) ])
// end snippet

// snippet yield2
fn gen_1_to_10 {
    for i=1 ; i <= 10 ; i = i + 1:
        yield i;
}

let st = async gen_1_to_10();
while st.has_next() :
    println(st.next());
// end snippet

// snippet fun1
fn inc(x) {
  x+1
}
println(inc)
println(inc(1))
// end snippet

// snippet fun3
fn inc x {
  x+1
}
println(inc)
println(inc(1))
// end snippet

// snippet fun2
let inc = fn (x) {
  x+1
}
println(inc)
println(inc(1))
// end snippet

// snippet fun4
fn inc !x, @how_much {
  x+how_much
}
println(inc)
println(inc(1,how_much=5))
// end snippet

// snippet fun5
fn inc !x, @how_much=1 {
  x+how_much
}
println(inc(1,how_much=5))
println(inc(1))
// end snippet

// snippet fun6
fn wrong !x, h, !k {
  // just don't do
}
try: wrong(1,3, h= 2)
catch e: println("There is an error",e)
// end snippet

// snippet restParameters
let f = fn (a,b,[rest]) {
  println("a=",a)
  println("b=",b)
  for each r in rest: print("%s " % r)
}

f(1,2,3,4,5,6)
// end snippet

// snippet metaParameters
let f = fn (a,b,{meta}) {
  println("a=",a)
  println("b=",b)
  for each r in keys(meta): print("%s=%s\n" % [r , meta[r]])
}

f(1,b=2,k=3,x=4,juice=5,six=6)
// end snippet

// snippet metaRestParameters
let f = fn (a,b,[rest],{meta}) {
  println("a=",a);
  println("b=",b);
  for each r in keys(meta): print("%s=%s\n" % [r , meta[r]]);
  println("rest:");
  for each r in rest: print("%s " % r);
}

f(1,b=2,k=3,x=4,juice=5,7,six=6);
// end snippet

// snippet closureArgument
let f = fn (a,b,^closure) {
  println("a=",a);
  println("b=",b);
  println(closure(a,b))
}

f(2,3){|x,y| x+y}
f(2,3){|x,y| x*y}
// end snippet
// snippet spread
fn a(@a,@b,@c,@d){
    println("%s %s %s %s " % [a,b,c,d])
}
fn b(!a,!b,!c,!d){
    println("%s %s %s %s " % [a,b,c,d])
}
fn c(a,b,c,d){
    println("%s %s %s %s " % [a,b,c,d])
}

a(..{a:1,b:2,c:3,d:4});
b(..[1,2,3,4]);
c(..[1,2],..{d:4},3);
// end snippet

// snippet spreadStream
fn c(a,b,c,d){
    println("%s %s %s %s " % [a,b,c,d])
}
fn numbers {
  for i = 1 ; i <= 4 ; i = i + 1 : yield i
}

c(..(async numbers()))
// end snippet

// snippet closureDecorator1
  fn closure_decorator(^closure){
    {|| println("We start"); closure(); println("We finish")}
  }

  let z = closure_decorator(){|| println("We are closure") }

  z()
// end snippet

// snippet closureDecorator2
  fn closure_decorator(^closure){
    {|| println("We start@"); closure(); println("We finish@")}
  }

  let z = @closure_decorator(){|| println("We are closure") }

  z()
// end snippet

// snippet fnDecorator1
  fn fun_decorator(^closure){
    {|| println("We start the fun"); closure(); println("The fun is over")}
  }

let z =
@fun_decorator()
fn q(){
  println("We function");
}
  z()
// end snippet

// snippet fnDecorator2
  fn fun_decorator(^closure){
    {|| println("We start the fun"); closure(); println("The fun is over")}
  }

let z =
fun_decorator(
fn q(){
  println("We function");
})
  z()
// end snippet

// snippet fnDecorator3
let fun_decorator={|^closure|
        set(closure.name,
            {|| println("We start the fun"); closure(); println("The fun is over")}
           )
    }

@fun_decorator()
fn q(){
  println("We function");
}

q()
// end snippet

// snippet fnDecorator4
{
    fn globalize(^closure){
            set_global(closure.name,closure)
        }

    @globalize()
    fn q(){
      println("We function");
    }
}
q()
// end snippet

// snippet that
class OuterClass {
    let name = "outer class";
    fn init(){
      let name = "outer object"
    }
    class InnerClass {
        let name = "inner class";
        fn init() {
            let name = "inner object"
            println("this name %s " % this.name)
            println("this name %s " % cls.name)
            println("this name %s " % that.name)
            println("this name %s " % that.cls.name)
            }
        }
    }
let outer = OuterClass()
let inner = outer.InnerClass()
// end snippet

// snippet fibonacci1
fn fib(x) {
    if x == 1 || x == 0 : 1
    else: fib(x - 1) + fib(x - 2)
}
println(fib(10))
// end snippet

// snippet fibonacci2
class FibCalculator {
    let cache = [];
    fn fib(x) {
        if x == 1 || x == 0 : 1
        else{
            return cache[x] when cache[x] != none;
            cache[x] = fib(x - 1) + fib(x - 2);
        }
    }
}
println(FibCalculator.fib(10))
// end snippet

// snippet fibonacci3
try
{
    fn fib(x) {
        if x == 1 || x == 0 : 1
        else: fib(x - 1) + fib(x - 2)
    }
    println(fib(10))
}catch ex : println(ex)
// end snippet

// snippet fibonacci4
{
    let fib={|x|
        if x == 1 || x == 0 : 1
        else: fib(x - 1) + fib(x - 2)
    }
    println(fib(10))
}
// end snippet

// snippet fibonacci5
{
    fn fib(x,fib=fib) {
        if x == 1 || x == 0 : 1
        else: fib(x - 1) + fib(x - 2)
    }
    println(fib(10))
}
// end snippet

// snippet fibonacci6
{
    fn fib(x) {
        if x == 1 || x == 0 : 1
        else: me(x - 1) + me(x - 2)
    }
    println(fib(10))
}
// end snippet

// snippet fibonacci7
let fib = {
    let cache = [];
    {|x|
        if x == 1 || x == 0 : 1
        else{
            return cache[x] if cache[x] != none;
            cache[x] = me(x - 1) + me(x - 2);
        }
    }
}
println(fib(10))
// end snippet

// snippet fibonacci8
class FibCalculator {
    fn init(start=1) {
        let cache = [];
    }
    fn fib(x) {
        if x == 1 || x == 0 : start
        else{
            return cache[x] if cache[x] != none;
            cache[x] = fib(x - 1) + fib(x - 2);
        }
    }
}
println(FibCalculator().fib(10))
println(FibCalculator(2).fib(10))
// end snippet

// snippet evaluate1
let twice = macro(fn (arg){ evaluate(arg); evaluate(arg);});
twice( {println("Hello")} )
// end snippet

// snippet evaluate2
macro(fn (!arg,[rest],{meta},^closure)
            { evaluate(arg)(..rest,..meta,..closure)}
     )(fn () {println("Hello")})
// end snippet

// snippet evaluate3
(fn (!arg,[rest],{meta},^closure)
            { arg(..rest,..meta,..closure)})
     (fn () {println("Hello")})
// end snippet

// snippet import
try{
let MyImport = import("mod.ul.name.file")
let my_function = MyImport.imported_function;
my_function("hello")
}catch e{}
// end snippet

// snippet class1
class A {
    fn init {
        let a = "a";
    }
    let c = "c"
}
let a1 = A()
let a2 = A()
a1.a = "1"
a2.a = "2"
A.c = "d"
println a1.a, a2.a, a1.c, a2.c

// end snippet

// snippet class2
class A {
    fn init {
        this.a = "a";
    }
    cls.c = "c"
}
let a1 = A()
let a2 = A()
a1.a = "1"
a2.a = "2"
A.c = "d"
println a1.a, a2.a, a1.c, a2.c

// end snippet

// snippet class3
class A {
    fn init {
        this.a = "a";
    }
    fn p {
        println "I am class level"
    }
}
let a1 = A()
a1.p()
a1.p = fn (){
  println "I am a1"
}
let a2 = A()
a2.p = fn (){
  println "I am a2"
}

a1.p()
a2.p()

// end snippet

// snippet class4
class A {
    fn p {
        this = none
    }
}
try :
    A().p()
catch ex :
    println ex
// end snippet

// snippet class5
class A {
    fn p {
        cls = none
    }
}
try :
    A().p()
catch ex :
    println ex
// end snippet

// snippet class6
class A {
    fn init {
      this = B()
    }
}

class B {

}

println A().cls

// end snippet

// snippet class7
class A {
    fn init {
      cls = B
    }
}

class B {

}
try:
    A()
catch ex:
    println ex

// end snippet

// snippet class8
class A {
    class B {
        fn init {
            println "this ", this
            println "cls ", cls
            println "that ", that
        }
    }
}

let a = A()
let b = a.B()
// end snippet

// snippet try1

try {
    z = 55 // undefined variable
}catch err {
  println err
} finally {
  println "this will always run"
}

// end snippet

// snippet try2
try{
    try {
        z = 55 // undefined variable
    }
}catch(err): println err

// end snippet

// snippet try3
let error:err|none
try{
        z = 55 // undefined variable
}catch(err): error = err

println error

// end snippet

// snippet try4
let error:err|none
try{
        z = 55 // undefined variable
}catch(err): error = err

println """message "%s" """ % [error.message]
println """cause "%s" """ % [error.cause]
println """suppressed %s" """ % [error.suppressed]
for each st in error.stack_trace {
    println("%s:%s:%s" % [st.file, st.line, st.column])
    println "source: ", st.source
    }


// end snippet

// snippet type1

let s = "13"; let i = 13; let d = 3.14;

let err
try: z = 6.55
catch ex: err=ex
class A {}

println "\"13\" ", type("13")
println "13 ", type(13)
println "3.14 ", type(3.14)
println "err ",type(err)
println "A() ",type(A())
println "[1,2,3] ",type([1,2,3])
println "A ",type(A)
println "fn()=3 ",type(fn()=3)
println "{|| 3} ",type({|| 3})
println "que(1) ",type(que(1))
println "async ",type(async 1)
println "macro ",type(macro(fn()=3))
println "none ",type(none)
println "java object ", type(java_object("java.lang.Object"))

// end snippet

// snippet sleep

sleep(0.001) // sleep one mili

// end snippet

// snippet reclose
fn my_fun(@close_it) {
  let s: str = "in function";
  return reclose(close_it)
}

let s:str ="outer";
let closure = {|x| println s; s = x};
let reclosure = my_fun(close_it=closure);

closure("closure 1")
reclosure("reclosure 1")
println "s = %s" % s

closure("closure 2")
reclosure("reclosure 2")
println "s = %s" % s
// end snippet

// snippet die

sys_import "turi.throw"

try:
    throw "wuff"
catch ex:
    print "don't die"
// end snippet

// snippet que
/**
 * A printing function that will print the objects received through the que `q` till it gets closed.
 */
fn printer(q,@name){
    let n = 0 // counts the number of not ready que attempts
    while {
        let s = q.try_receive(); // try to receive one or get none if there is nothing in the queue
        return { println "%s is done" % name } if q.is_closed(); // return when the que is closed
        if s == none {
            println "%s is not ready %s" % [name,n]
            n = n + 1 // count the attempts
            sleep 0.003 // sleep 3 mili
        } else {
            n = 0 // reset the attempts, we go an object to print
            println "%s is ready %s" % [name,s];
        }
    }
}

// create ONE queue that will be consumed by two
let q : que = que(3)
// create two asynchronous task. they start immediately
let task1 : task = async printer(q,name="task1")
let task2 : task = async printer(q,name="task2")
// send the numbers 1 to 10 to the queue, whoever is lucky can get it
for i=1 ; i < 10 ; i = i +1 {
    q.send(i);
    sleep 0.01
    }
println "closing the channel"
q.close();
println "channel is closed"
println "1 is done %s" % task1.is_done()
println "2 is done %s" % task2.is_done()

// get only the tasks into the list which are not done yet
let task_list = [task1, task2 ? {|x| !x.is_done()} ]

println "we start to wait the first time"
await task_list

println "task1 done %s" % task1.is_done()
println "task2 done %s" % task2.is_done()
println "We start to wait the second time"
// have to use [] empty options, no timeout because a list literal stands after it
await[] [task1, task2 ? {|x| !x.is_done()} ]

println "task1 done %s" % task1.is_done()
println "task2 done %s" % task2.is_done()

none
// end snippet

// snippet try_yield
fn printer(){
    let n = 0
    while {
        let s = try_yield();
        return { println "we are done" } if yield_is_closed();
        if s == none {
            println "not ready %s" % n
            n = n + 1
            sleep 0.003
        } else {
            n = 0
            println "received %s" % s;
        }
    }
}

let task : task = async printer()
for i=1 ; i < 4 ; i = i +1 {
 println "sending ",i
 task.send(i);
 sleep 0.009
 }
println "closing the channel"
task.close();
println "channel is closed"
println "is done %s" % task.is_done()
await task
println "is done %s" % task.is_done()

none
// end snippet

// snippet flat_let_object1

let z = { a: "apple", b:"bier", c : "count" }
let {a, b, c} = z
println a
println b
println c
// end snippet

// snippet flat_let_object2

let z = { a: "apple", b:"bier", c : "count" , d: "not used" }
let {a, b, c, f} = z
println a
println b
println c
println f
// end snippet

// snippet flat_let_list1
let [a, b, c] = [1,2,3]
println a
println b
println c
// end snippet

// snippet flat_let_list2
try:
    let [a, b, c, f] = [1,2,3]
catch err: println err
// end snippet

// snippet flat_let_list3
try:
    let [a, b] = [1,2,3]
catch err: println err
// end snippet

// snippet flat_let_list4
let [a, b] = [1,2,3,4,5,6,7,8][0..2]
println a
println b
// end snippet

// snippet flat_let_list5
fn adjust(x, @to){
    if len(x) < to :
        while len(x) < to :
            x = [..x, none]
    else :
        x = x[0..len(x)]
    x
}
let [a, b, c, d] = adjust(to=4,[1,2])
println a
println b
println c
println d
// end snippet

// snippet flat_let_list6
fn adjust(@to,[x]){
    if len(x) < to :
        while len(x) < to :
            x = [..x, none]
    else :
        x = x[0..len(x)]
    x
}
let [a, b, c, d] = adjust(to=4, 1,2)
println a
println b
println c
println d
// end snippet

// snippet re
sys_import "turi.re"

fn print_match(m){
    for i=0 ; i < len(m.group) ; i = i + 1 {
        let {index, start, end } = m.group[i];
        println "%s. '%s'.substring(%s,%s)='%s'" % [index,s,start, end,s[start..end]];
    }
}

let s = "abrakadabra";
let rx =Re("a(b)ra(ka)(dabra)")
let m = rx.match(s);
println m
print_match(m);

s = "xxx"+s+"yyy";
m = rx.match(s);
if m.group == none :
    println "does not match because of xxx and yyy"
println m, " is an empty object"
m = rx.find(s)
if m.group != none :
    println "matches because we find and not match"
print_match(m);
// end snippet


// snippet re2
sys_import "turi.re"

let m = Re("a(?<firstb>b)ra(?<twoletter>ka)(dabra)").match("abrakadabra");
println "the ks is '%s'" % [m.name.twoletter]
// end snippet

// snippet preprocessorSample
fn hi(){ // this will be deleted, it only exists in the preprocessor context
  "hello "
}
// the next line starts the preprocessor
# {|lexes|
["""
    // this is a string that will lead the new lexical token list
    let M:str = ""
    fn helvetic_hi(){
      "Gruetzi "
    }
    M = M + "hello ";
    M = M + (hi() or "none ");
""",
// and just let's have the rest of the tokens
..lexes]
} // end of the preprocessor command

// this is preprocessed
M = M + helvetic_hi() + "ant hunter"
print M
// end snippet

// snippet inherit1
class P {
    fn a()=1
    let v = 2
}
class C : P {
    fn b()=3
    let z = 4
}
let o = C();
println o.a(),o.v,o.b(),o.z;
// end snippet

// snippet inherit2
class P1 {
    fn a()=1
    let v = 2
}
class P2 {
    fn aa()=3
    let vv = 4
}
class C : P1,P2 {
    fn b()=5
    let z = 6
}
let o = C();
println o.a(), o.v, o.aa(), o.vv, o.b(), o.z;
// end snippet

// snippet inherit3
class P1 {
    fn a()=1
    let v = 2
}
class P2 {
    fn a()=3
    let v = 4
}
class C : P1,P2 {
    fn b()=5
    let z = 6
}
let o = C();
println o.a(), o.v, o.b(), o.z;
// end snippet

// snippet inherit4
class P1 {
    fn init {
        println "init in P1, cls='%s' this='%s'" % [cls, this]
    }
}
class P2 {
    fn init {
        println "init in P2, cls='%s' this='%s'" % [cls, this]
    }
}
class C : P1,P2 {
    fn init {
        println "init in C, cls='%s' this='%s'" % [cls, this]
    }
}
let o = C();
// end snippet

// snippet inherit5
class P1 {
    fn init {
        println "init in P1, cls='%s' this='%s'" % [cls, this]
    }
}
class P2 {
    fn init {
        println "init in P2, cls='%s' this='%s'" % [cls, this]
    }
}
class C : P1,P2 {
    fn init {
        println "init in C, cls='%s' this='%s'" % [cls, this]
        P1.init()
        P2.init()
    }
}
let o = C();
// end snippet

// snippet inherit6
class P {
    fn init {
        println "init in P, cls='%s' this='%s'" % [cls, this]
    }
}
class C : P {
}
let o = C();
// end snippet

// snippet fun7
fn concat(a:str, b:str):str = a + b
println concat("ab","ba")
// end snippet

// snippet fun8
fn concat(a:str, b:str):str = 13
try:
    println concat("ab","ba")
catch err: println err
// end snippet

// snippet fun9
let myString="num"
fn concat(a:str, b:str):(myString) = 13
myString = "str"
try:
    println concat("ab","ba")
catch err: println err
// end snippet

// snippet fun10
class K {   fn p()=println "original K" }
fn h():K = K()
h().p()
// end snippet

// snippet fun11
class K {   fn p()=println("original K") }
fn h():K = K()
h().p()
// end snippet

// snippet is_defined
if is_defined(z) : println "defined" else: println "not defined";
let z = 1
if is_defined(z) : println "defined" else: println "not defined";
try:
    println {if is_defined(z+2) : "defined" else: "not defined"}
catch: println "no way"
// end snippet


// snippet objectAddition1
class LN {
    fn init( a ){

    }
    fn `+` ( other ){
            LN( this.a * other.a )
    }
}
println( (LN(2) + LN(4)).a )
// end snippet

// snippet objectAddition2
class LN {
    fn init( a ){

    }
    fn `+` ( other ){
            LN( this.a * other.a )
    }
}
println {LN(2) + LN(4)}.a
// end snippet

// snippet myEqual
class A {
  fn `==`(other) -> bool {
    this.a == other.a
  }
}

let x = A()
let y = A()
let z = { a: 1, b: "x" }

x.a = 1
x.b = "x"

y.a = 1
y.b = "y"

println "x == y is %s" % (x == y)
println "y == z is %s" % (y == z)
// end snippet

// snippet myEqual2
class A {
  fn `==`(other) -> bool {
    return false if cls != other.cls
    a == other.a
  }
}

let y = A()
let z = { a: 1, b: "x" }

y.a = 1
y.b = "y"

println "y == z is %s" % (y == z)
// end snippet

// snippet unlet
class Z {
    fn init(obj){
        for each t in keys(obj){
            this[t] = obj[t]
        }
        unlet obj;
    }
}
let z = Z({
    a: {
        B : "abraka"
        },
    c : ""
    });
println z
// end snippet

// snippet ListLiteral1
let computed = {fn(a,b) = a + b}(1,2);
println([1, 2, 3, 4])
println(["apple", "banana", "cherry"])
println([1 + 2, computed])
// end snippet

// snippet ListLiteral2
let a = [1, 2, 3, 4]
let b = ["apple", ..a, "banana", "cherry"]
println b
// end snippet

// snippet ListLiteral3
let a = [1, 2, 3, 4]
let b = [5, 6, 7]
println([..a, ..b])
// end snippet

// snippet ListLiteral4
let a = [1, 2, 3, 4]
let b = [1, 3]
println(a+b)
println(a-b)
println(a*b)
println(a+"sixteen")
println(a-2)
// end snippet

// snippet ListLiteral5
let a = [1, 2, 3, 4]
let b = [1, 3]
println(a+[b])
// end snippet

// snippet ListLiteral6
let a = [1, 2, 3, 4]
println([a[0],..a[2..inf]])
// end snippet

// snippet ListLiteral7
let a = [1, 2, 3, 4 ? {|x| x % 2 == 0 } ]
println a
// end snippet

// snippet ListLiteral8
let a = [1, 2, 3, 4 ? {|x| x % 2 == 0 } -> {|z| return z/2 }]
println a
// end snippet

// snippet ListLiteral9
let a = [1, 2, 3, 4 ? {|| it % 2 == 0 } -> {|| return it/2 }]
println a
// end snippet

// snippet ListLiteral10
let a = [1, 2, 3, 4 ? it % 2 == 0  -> it/2 ]
println a
// end snippet

// snippet xor1
println 12 ^ 2
println 12.0 ^ 2
println( [1,2,3] ^ [3,4,5] )
// end snippet

// snippet mod1
println "2*3=%s" % [2*3]
println "2/3=%s" % [2/3]
println "2%%3=%s" % [2%3]
println "aa " * 6
println( [1,2] * [6])
println( [1,2,3] % [3,4,5] )
println( [1,2,3 ? it in [3,4,5]] )
// end snippet

// snippet shr1
println 8>>2
println "artany" >> "...... ..."
println([1,2,3] >> [-1,-2,-3])
// end snippet

// snippet equal1
let k = { a:1 , b:2 }
let q = { a:1 , b:2 }
let w = "ohmy"
println 1 == 1, " one is one"
println 1 == 2, " one is not two"
println 1 === 1, "one is the same as one"
println 1 === 2, "one is not the same as two"
println k == q, "k equals q, but"
println k === q, "k is not the same as q"
println w == "ohmy", " w is 'ohmy'"
println w === "ohmy", " w is not that 'ohmy'"
// end snippet

// snippet inop
println "raka" in "avraka dabra", " there is 'raka' in 'avraka dabra'"
println "raka" in "evreke debre", " there is no raka in 'evreke debre'"
println 3 in [1,2,3], " 3 is in [1,2,3]"
println 3 in [1,2,4], " 3 is not in [1,2,4]"
// end snippet

// snippet bor1
println 1 | 2
println( [1,1,2,3,3,2,1] | [])
try:
    3.0 | 3.14
catch e: println e
// end snippet

// snippet band1
println 7 &  2
println( [1,1,2,3,3,2,1] & [2, 3, 7])
try:
    3.0 & 3.14
catch e: println e
// end snippet

// snippet compare
println 1 < 2
println 3 <= 3
println 4 > 3
println 4 >= 4
// end snippet

// snippet and
if (7&2) == 3 && 5/0 == inf {
    println "something is wrong"
}else{
    println "dandy"
}
// end snippet

// snippet logical_or
if (7&2) == 2 || 5/0 == inf {
    println "dandy"
}else{
    println "something is wrong"
}
// end snippet

// snippet oror
println none or 3
// end snippet

// snippet string_functions
println " 1. ","alma kadarka".after("ka")
println " 2. ","alma kadarka".before("ka")
println " 3. ","alma kadarka".between("ma","da")
println " 4. ","aa ".times(6)
println " 5. "," aa ".trim()
println " 6. ","aa ".starts_with("a")
println " 7. ","aa".ends_with("a")
println " 8. ","AA".lower_case()
println " 9. ","aa".upper_case()
println "10. ","a,b,c,d".split(",")
println "11. ","abcd".bytes()
println "12. ","abc".char_at(2), " is c"
println "13. ","alma kadarka".index_of("ka")
println "14. ","alma kadarka".last_index_of("ka")
println "15. ","alma kadarka".replace_all("a|d","e")
println "16. ","\n\t\r".quote()
println "17. ","alma kadarka".reverse()
println "18. ","alma kadarka".chop().chop()
println "19. ","alma kadarka\n".chomp()
println "20. ","alma kadarka".chomp()
println "21. ","alma kadarka".contains("ma ka")
println "22. ","alma kadarka".left(4)
println "23. ","alma kadarka".right(4)
println "24. ","alma kadarka".count_substring("a")
println "25. ","kadarka".pad_left(12)
println "26. ","kadarka".pad_left(".",12)
println "27. ","kadarka".pad_right(12) + "<"
println "28. ","kadarka".pad_right(".",12)
println "29. ","   ".is_blank()
println "30. ","   ".is_empty()
println "31. ","+6.2E23".is_numeric()
println "32. ","+6.2E23".is_digit()
println "33. ","6223".is_digit()
println "34. ","Euler Number".is_numeric()
println "35. ","EulerNumber".is_alpha()
println "36. ","EulerNumberisnot314".is_alphanumeric()
println "37. ","2AF".is_hex()
println "38. ","0x2AF".is_hex()
println "39. ","2AF".hex()
println "40. ","0x2AF".hex()
println "41. ","0x2AF".base64()
println "42. ","MHgyQUY=".from_base64()
println "43. ","MHgyQUY=".from_base64_str()
println "44. ","alma van a fa = alarr://".url_encode()
println "45. ","alma+van+a+fa+%3D+alarr%3A%2F%2F".url_decode()
println "46. ","line 1\nline2\n\nline4".lines()
println "47. ","What do you read, my lord? Words, words, words.".words()
println "48. ","alma kadarka".remove_prefix("alma")
println "49. ","alma kadarka".remove_postfix("kadarka")
println "50. ","alma kadarka".remove_prefix("apple")
println "51. ","alma kadarka".remove_postfix("kik")
println "52. ",">" + ("alma".safe_char_at(666)) + "<"
println "53. ",",".join(["abrak","a","dabra","lonak","zabla"])
println "54. ","aaa".md5()
println "55. ","aaa".sha_1()
println "56. ","aaa".sha_256()
println "57. ","aaa".sha_512()
println "60. ","aaa".digest("MD5")
println "61. ",61.hex()
println "62. ","let z = if a == 3 :  3 else: 5;".turi_lex()
println "63. ","let M= \"\"; for i=0 ; i < 8 ; i = i +1 : M = M + i; M".execute()
println "64. ",M
// end snippet
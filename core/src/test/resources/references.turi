

// snippet uncurry1
fn add(a,b)=a + b
let add5 = add.(5)
println add5(5)
println is_curried(add)
println is_curried(add5)
let unc = uncurry(add5)
println unc(6,6)
// end snippet

// snippet uncurry2
fn add(a,b)=a + b
let be10 = add.(5).(5)
println be10()
let unc = uncurry(be10)
println unc(6,6)
// end snippet

// snippet uncurry3
fn add(a,b)=a + b
let be10 = add.(5).(5)
println "be10() ", be10()
println "uncurry(be10)(6,7) ", uncurry(be10)(6,7)
println "uncurry(be10,0)() ", uncurry(be10,0)()
println "uncurry(be10,1)(6) ", uncurry(be10,1)(6)
println "uncurry(be10,2)(6,6) ", uncurry(be10,2)(6,6)
println "uncurry(be10,curried_arity(be10))(6,6) ", uncurry(be10,curried_arity(be10))(6,6)
// end snippet

// snippet uncurry4
class CurriedAway {
    fn init(spice);
    fn a(x,y) = x + y + spice
}

let z = CurriedAway(1)
let fun = z.a.(1,1)
println fun()
println uncurry(fun,2)(2,1)
try: uncurry(fun)(1,3) catch err: println err
// end snippet

// snippet uncurry5
fn a(x,y){}
println is_curried(uncurry(a.(1,2)))
println is_curried(uncurry(a.(1,2),2))
// end snippet

// snippet uncurry6
class CurriedAway {
    fn init(spice);
    fn a(x,y) = x + y + spice
}

let z = CurriedAway(1)
let fun = z.a.(1,1)
println fun()
println uncurry(fun,2)(2,1)
{
let spice = 3;
println reclose(uncurry(fun))(3,1);
}
// end snippet


// snippet curry1
let add = fn(x, y) { x + y }
let add5 = add.(5)
print(add5(3))
// end snippet

// snippet curry2
class AddAndOffset {
    fn init(offset=0);
    fn add(a:num,b:num) = a + b + offset
}

let offset5 = AddAndOffset(5)
let add8 = offset5.add.(3)
println add8(2)
// end snippet

// snippet curry_named
fn add(a:num,@b:num) = a + 2 * b

 let add6 = add.(b=3)
 let times2_add3 = add.(3)
 println add6(2)
 println times2_add3(b=1)
 // end snippet

// snippet curry_rest
fn echo(a,!b,@c,[rest],{meta}){
    println $"a=${a}"
    println $"b=${b}"
    println $"c=${c}"
    println $"rest=${rest}"
    println $"meta=${meta}"
    "who am I kidding?"
}
let ho = echo.(c="cica","alamaba","bourbenk","rist",rust="the best programming language ever", joke=true)
println ho("yayy")
// end snippet

// snippet curry_closure
let echo= {|a,!b,@c,[rest],{meta}|
    println $"a=${a}"
    println $"b=${b}"
    println $"c=${c}"
    println $"rest=${rest}"
    println $"meta=${meta}"
    "who am I kidding?"
}
let ho = echo.(c="cica","alamaba","bourbenk","rist",rust="the best programming language ever", joke=true)
println ho("yayy")
 // end snippet

// snippet curry_macro
fn add(a,b) = evaluate(a) + evaluate(b)
let addM = macro(add)
println addM.(3)(4)
// end snippet

// snippet curry_macro_mix
fn add(a,b,c) = a + evaluate(b) + evaluate(c)
println macro(add.(1)).(2)(3)
 // end snippet

// snippet signatura1
fn f (a:num=53,[reliquum],{nominati},^clausura):any {
    return a + b + c
}

println jsonify_beauty(signature(f))
// end snippet

// snippet func_concat1
fn f (a,b,c) {
    return a + b + c
}
fn g(x):num{
    return x+1
}
let z =  (f ## g)(1,1,1)
println z
// end snippet

// snippet update_forbiden
mut z = 13
try {
    z = {z = 12; 14}
}catch e : println e
print z," not changed"
// end snippet

// snippet update_forbiden2
mut z = [13]
try {
    z[0] = {z[0] = 12; 14}
}catch e : println e
print z[0], " already changed"
// end snippet

// snippet update_forbiden3
mut z = { z: 13 };
try {
    z.z = {z.z = 12; 14}
}catch e : println e
print z.z, " not changed"
// end snippet

// snippet update_forbiden4
mut z = { z: 13 };
try {
    z["z"] = {z.z = 12; 14}
}catch e : println e
print z.z, " already changed"
// end snippet

// snippet update_forbiden5
mut z = "apple juice";
try: z[1..5] = {z = "worm"; "lma"}
catch e: println e
print z
// end snippet

// snippet update_forbiden6
mut z = "apple juice";
try:
    z = z[0..1] + {z = "worm"; "lma"} + z [5..inf];
catch e: println e
print z
// end snippet

// snippet update_forbiden7
mut z = []
z[1] = []
z[1][3] = { z[1] = [];  "K"}
println z
// end snippet

// snippet update_forbiden8
mut z = []
try: z[3] = { z = [];  "K"}
catch e: println e
println z
// end snippet

// snippet string_after
println "alma ata".after("ma ")
// end snippet

// snippet string_before
println "alma ata".before(" ata")
// end snippet

// snippet string_between
println "alma ata".between("al","ta")
// end snippet

// snippet string_lines
println jsonify("alma\na\nta".lines())
// end snippet

// snippet string_words
println jsonify("alma ata".words())
// end snippet

// snippet string_turi_lex
println "for each i in range(1,55) : println i".turi_lex()
// end snippet

// snippet string_execute
sys_import turi.range;

mut j = 3;
println "for each i in range(1,3) { println i+j; j ++ }".execute()
println j;
// end snippet

// snippet string_url_encode
println "63/2%3 =55".url_encode()
// end snippet

// snippet string_url_decode
println "63%2F2%253+%3D55".url_decode()
// end snippet

// snippet string_md5
println "borra sor meggyotor".md5()
// end snippet

// snippet string_sha_1
println "borra sor meggyotor".sha_1()
// end snippet

// snippet string_sha_256
println "borra sor meggyotor".sha_256()
// end snippet

// snippet string_sha_512
println "borra sor meggyotor".sha_512()
// end snippet

// snippet string_digest
println "borra sor meggyotor".digest("sha-512")
// end snippet

// snippet string_base64
println "borra sor meggyotor".base64()
// end snippet

// snippet string_from_base64
println "Ym9ycmEgc29yIG1lZ2d5b3Rvcg==".from_base64()
// end snippet

// snippet string_from_base64_str
println "Ym9ycmEgc29yIG1lZ2d5b3Rvcg==".from_base64_str()
// end snippet

// snippet string_contains
println "Ym9ymcAgc29yIG1lZ2d5b3Rvcg==".contains("ymcA")
println "Ym9ymcAgc29yIG1lZ2d5b3Rvcg==".contains("bora nora")
// end snippet

// snippet string_contains_regex
println "Ym9ymcAgc29yIG1lZ2d5b3Rvcg==".contains_regex("IG.*cg")
println "Ym9ymcAgc29yIG1lZ2d5b3Rvcg==".contains_regex("YmZ.*?nora")
// end snippet

// snippet string_matches
println "Ym9ymcAgc29yIG1lZ2d5b3Rvcg==".matches("Ym.*cg..")
println "Ym9ymcAgc29yIG1lZ2d5b3Rvcg==".matches("ym.*cA")
// end snippet

// snippet string_matches_glob
println "my_precious_text_file.txt".matches_glob("*.txt")
println "my_precious_text_file.txt".matches_glob("*.turx")
// end snippet

// snippet string_is_blank
println "\n\t  ".is_blank()
println "\n\t  wupps".is_blank()
// end snippet

// snippet string_is_not_blank
println "\n\t  ".is_not_blank()
println "\n\t  wupps".is_not_blank()
// end snippet

// snippet string_is_empty
println "".is_empty()
println "\n\t  ".is_empty()
// end snippet

// snippet string_is_not_empty
println "".is_not_empty()
println "\n\t  ".is_not_empty()
// end snippet

// snippet string_is_numeric
println "653".is_numeric()
println "6E23".is_numeric()
println "3.1425923".is_numeric()
println "10.13.55.2".is_numeric()
// end snippet

// snippet string_is_not_numeric
println "653".is_not_numeric()
println "6E23".is_not_numeric()
println "3.1425923".is_not_numeric()
println "10.13.55.2".is_not_numeric()
// end snippet

// snippet string_is_digit
println "653".is_digit()
println "6E23".is_digit()
println "3.1425923".is_digit()
println "10.13.55.2".is_digit()
// end snippet

// snippet string_is_not_digit
println "653".is_not_digit()
println "6E23".is_not_digit()
println "3.1425923".is_not_digit()
println "10.13.55.2".is_not_digit()
// end snippet

// snippet string_is_alpha
println "ABC".is_alpha()
println "ABC DEF".is_alpha()
println "ABCDEF13".is_alpha()
// end snippet

// snippet string_is_not_alpha
println "ABC".is_not_alpha()
println "ABC DEF".is_not_alpha()
println "ABCDEF13".is_not_alpha()
// end snippet

// snippet string_is_alphanumeric
println "ABC".is_alphanumeric()
println "ABC DEF".is_alphanumeric()
println "ABCDEF13".is_alphanumeric()
// end snippet

// snippet string_is_not_alphanumeric
println "ABC".is_not_alphanumeric()
println "ABC DEF".is_not_alphanumeric()
println "ABCDEF13".is_not_alphanumeric()
// end snippet

// snippet string_is_hex
println "ABC".is_hex()
println "ABC DEF".is_hex()
println "ABCDEF13".is_hex()
// end snippet

// snippet string_is_not_hex
println "ABC".is_not_hex()
println "ABC DEF".is_not_hex()
println "ABCDEF13".is_not_hex()
// end snippet

// snippet string_int
println "632".int()
// end snippet

// snippet string_float
println "3.1415929".float()
// end snippet

// snippet string_number
println "61".number(7)
// end snippet

// snippet string_hex
println "2F".hex()
println "0x2F".hex()
// end snippet

// snippet string_substring
println "alma ata".substring(5)
println "alma ata".substring(5,53)
println "alma ata".substring(5,7)
println "alma ata".substring(-3,7)
// end snippet

// snippet string_remove_prefix
println "alma ata".remove_prefix("alma")
println "alma ata".remove_prefix("apple")
// end snippet

// snippet string_remove_postfix
println "alma ata".remove_postfix("ata")
println "alma ata".remove_postfix("alma")
// end snippet

// snippet string_count_substring
println "almal atal".count_substring("al")
println ("a"*6).count_substring("aa")
// end snippet

// snippet string_count_substring_overlap
println "almal atal".count_substring_overlap("al")
println ("a"*6).count_substring_overlap("aa")
// end snippet

// snippet string_left
println "alma ata".left(4)
// end snippet

// snippet string_right
println "alma ata".right(3)
// end snippet


// snippet string_replace_all
println "alma ata".replace_all("a(.*?)a","b$1b")
// end snippet

// snippet string_quote
let s= """z\t \\ a\n"a"""
let q = s.quote()
println $"${q} len q=${len(q)} len s=${len(s)}"
// end snippet

// snippet string_reverse
println "alma ata".reverse()
// end snippet

// snippet string_times
println "alma ".times(5)
// end snippet

// snippet string_lower_case
println "aLMa aTTa".lower_case()
// end snippet

// snippet string_upper_case
println "aLMa aTTa".upper_case()
// end snippet

// snippet string_swap_case
println "aLMa aTTa".swap_case()
// end snippet

// snippet string_capitalize
println "aLMa aTTa".capitalize()
// end snippet

// snippet string_title
println "aLMa aTTa".title()
// end snippet

// snippet string_casefold
println "Straße".casefold()
// end snippet

// snippet string_trim
let s=" \u202Fspace elol hatul "
println s
println s.trim()
// end snippet

// snippet string_strip
let s="\u202F space elol hatul "
println s
println s.strip()
// end snippet

// snippet string_strip_leading
let s="\u202F space elol hatul "
println s
println s.strip_leading()
// end snippet

// snippet string_strip_trailing
let s="\u202F space elol hatul "
println s
println s.strip_trailing()
// end snippet

// snippet string_strip_indent
let s="""
    bruhaha
      marha
  korte
  valaka mortunaktraburnaki                  """
println s.strip_indent()
// end snippet

// snippet string_starts_with
println "alma ata".starts_with("alma")
println "alma ata".starts_with("ata")
// end snippet

// snippet string_ends_with
println "alma ata".ends_with("alma")
println "alma ata".ends_with("ata")
// end snippet

// snippet string_partition
mut s:str = "abraka; muhaha dabra; mutabor; kalifa";
while s.is_not_empty() {
  mut [start:str, sep:str, s ] = s.partition("; ");
  println start
}
// end snippet

// snippet string_partition_alt
mut s:str = "abraka; muhaha dabra; mutabor; kalifa";
while s.is_not_empty() {
  mut [start:str, sep:str, s_new ] = s.partition("; ");
  s = s_new;
  println start;
}
// end snippet

// snippet string_partition_regex
mut s = "abraka, muhaha dabra, mutabor; kalifa";
while s.is_not_empty() {
  mut [start, sep, s ] = s.partition_regex("[ ,;]+")
  println start
}
// end snippet

// snippet string_split
println jsonify("abraka, muhaha dabra, mutabor; kalifa".split("[ ,;]+",3));
// end snippet

// snippet string_msplit
println jsonify("gropeId:artichokId:varsio,mersio,mubakka|abraka:debarbara,mucika::hoppana|mutabor.kalofa:nohabor,kalifa:abrbor,kalifa".msplit("|:,"));
// end snippet

// snippet string_bytes
println "alma ata".bytes()
// end snippet

// snippet string_join
println ":".join([".","/usr/bin","usr/local/bin"])
// end snippet

// snippet string_char_at
for i=0 ; i < 8 ; i++ :
    print "alma ata".char_at(i)
// end snippet

// snippet string_safe_char_at
for i=-3 ; i < 18 ; i++ :
    print "alma ata".safe_char_at(i);
// end snippet

// snippet string_ord
println "a".ord()
// end snippet

// snippet delete
let a = { a: 1 , b: 2, c: ["kedavra"], d:"avraka"}
a.a = none // this does not delete the field
println jsonify(a)
delete a, a // delete the field a
println jsonify(a)
delete {13; 55; a }, b // the object is calculated
delete a, "c" // string name for the field
println jsonify(a)
delete a, chr("c".ord()+1) // string calculated name
println a
try delete a, d catch e1 println e1  // was already deleted
a.c = []
try delete a.c, h catch e2 println e2
// end snippet



// snippet string_index_of
println "alma ata".index_of("lma")
println "alma ata".index_of("amla")
// end snippet

// snippet string_last_index_of
println "alma ata".last_index_of("a")
println "alma ata".last_index_of("amla")
// end snippet



// snippet string_chop
mut s = "alma ata\n";
println s;
s = s.chop()
println s;
s = s.chop()
println s;
s = s.chop()
println s;
// end snippet

// snippet string_chomp
mut s = "alma ata\n";
println s;
s = s.chomp()
println s;
s = s.chomp()
println s;
s = s.chomp()
println s;
// end snippet




// snippet string_pad_left
println "avalanche".pad_left(15)
println "avalanche".pad_left(15,".")
// end snippet

// snippet string_pad_right
println "avalanche".pad_right(15),"<<"
println "avalanche".pad_right(15,"."),"<<"
// end snippet

// snippet to_xml
sys_import "turi.xml";

let h = {
    name : "Pinco Palino",
    age : 32,
    sex : "sometimes"
}

h.`@cahe` = true;

println xml_format(to_xml(h, top="h"))

// end snippet

// snippet plural1
sys_import "turi.xml";

let project = {
    dependencies : [
    { groupId : "ch.turic", artifactId: "habakuk", version: "1.0.7" },
    { groupId : "ch.turic", artifactId: "habakak", version: "1.0.8" },
    { groupId : "ch.turic", artifactId: "hababab", version: "1.0.5" },
    { groupId : "ch.turic", artifactId: "haraluk", version: "1.4.7" }
] };

println xml_format(to_xml(project, top="project"))

// end snippet

// snippet plural2
sys_import "turi.xml";

let project = {
    dependencies : [
    { "!": "dependentia", groupId : "ch.turic", artifactId: "habakuk", version: "1.0.7" },
    { groupId : "ch.turic", artifactId: "habakak", version: "1.0.8" },
    { groupId : "ch.turic", artifactId: "hababab", version: "1.0.5" },
    { groupId : "ch.turic", artifactId: "haraluk", version: "1.4.7" }
] };

println xml_format(to_xml(project, top="project"))

// end snippet

// snippet keys1
class A {
    mut z:num = 1
    let k:str = "two"
    fn zibabwa(a,b,@shia,[ta]){}
}
let k = A()
let uu = {|f,y,z| none}

println keys(A), " of A"
println keys(A.zibabwa), " of A.zibabwa"
println keys(k), " of k"
println keys(uu), " of uu"

let BigDecimal = java_class("java.math.BigDecimal")
println keys(BigDecimal)
println keys(BigDecimal("0"))
// end snippet

// snippet jsonify
let z = {
  a: 1, b:? [1,2,3]
  pi : 3.1415926,
  location : {
    latidude : 16.990635373109665,
    longidude: 17.935398980291257,
    altidude: [2000, 1000,  -3 , false, "karma" ]
    the_dude : "Peter Verhas",
  }
};

println $"object to_string=${z}";
println;
println $"object jsonify=${jsonify(z)}";
println;
println $"object beauty=${jsonify_beauty(z,2,60)}";

// end snippet


// snippet pin_object
let a = {a:1, b:2};
pin {a};

try: a.k = 13 catch e: println e

// end snippet

// snippet pin_list
let a = [1,2,3,4];
pin [a];

try: a[0] = 13 catch e: println e
// end snippet

// snippet pin_wrong
let a = [1,2,3,4];
try: pin {a}; catch e1: println e1
let b = {a:1, b:2, c:3}
try: pin [b]; catch e2: println e2
// end snippet

// snippet field_access
let a = {}
a.k = 55
a["z"] = a["k"]
die if a.z != 55
println "it is ok"
// end snippet

// snippet field_none_indexed_access
let a  = {}
let q = (a["b"] or {}) ["c"]
println $"q is ${q}"
// end snippet

// snippet field_none_access
let a  = {}
println $"is a.b defined? ${with a: is_defined(b)}"
try: let q = a.b.c
catch e: println e
// q is still undefined we can assign
let p = (a.b or {}).c
// the same, but shorter
let q = a.b?.c
println $"q is ${q}.. eventually, but at least exists..."
println $"a was not changed ${a}"
// end snippet

// snippet field_transitive_creation
let a = {}
a.b.c.d.e.f = 1
println a
// end snippet

// snippet pinned_field
class Car {
    fn init(power:num=125, color:str="red"){
        pin power
    }
    fn repaint(color:str){
        this.color = color
    }
}
let my_porsch = Car(power=467)
my_porsch.repaint("yellow")
try {
    with my_porsch {
        power = power + 100;
    }
}catch e : println "You cannot do home tuning on a porsch";
print $"The color of my porsch is ${my_porsch.color}"
// end snippet

// snippet pinned_field_with
let a = {}
a.b = 13
with a : pin b
try{ a.b = 14 } catch e: println e
println a.b
// end snippet

// snippet istring1
let a = 3;
println $"a is ${a}"
// end snippet

// snippet istring2
println $"define a, but local ${let a = 3}"
println $"define b, not local $(let b = 4)"
println "is a defined? ", if is_defined(a) : $"yes, it is ${a}" else: "no"
println "is b defined? ", if is_defined(b) : $"yes, it is ${b}" else: "no"
// end snippet

// snippet istring3
println $"${ $\"${6*6}\"}"
// end snippet

// snippet emptyLoopResult
println { for i=0 ; i < 0 ; i=i+1 : "anything, not executed, will print none" }
println { for i=0 ; i < 0 ; i=i+1 list: "anything, not executed, will print []" }
// end snippet

// snippet mixed_continue
println {for each z in [1, 2, 3, 4, 5, 10, 11, 12] list {
            if z % 5 == 0 : continue;
            if z % 3 == 0 : continue z + 0.1;
            z
          }
        }
// end snippet

// snippet bad_continue
try: let k = {for each z in [1,2,3] {
    continue z/2 if z % 2 == 0;
    continue z;
    }
}catch e: println e
// end snippet

// snippet bnot
println $"negating all bits in 3 ${~3}"
println $"!true is ${!true}"
println $"+13 is just ${+13}"
println $"-13 is just ${-(13)}"
// end snippet

// snippet json1
mut project = {
      name : "turicum-parent",
      packaging : "pom",
      groupId : "ch.turic",
      artifactId : "turicum-parent",
      version : "1.0.0-SNAPSHOT",
      description : "Turicum programming language",
      modules : [ "core", "maven", "cli" ]
      }
println project.name
println project.packaging
// end snippet

// snippet lazy_json1
fn get_name(){
    println "Getting name";
    "turicum-parent"
}
mut project = &{
      name : get_name(),
      packaging : "pom",
      groupId : "ch.turic",
      artifactId : "turicum-parent",
      version : "1.0.0-SNAPSHOT",
      description : "Turicum programming language",
      modules : [ "core", "maven", "cli" ]
      }
println project.name
println project.packaging
println project.name
// end snippet




// snippet blabla
println("blala")
// end snippet

// snippet first_sample
print "Hello,";
println " World"
for i=1 ; i < 3 ; i = i+1 : println(i)
// end snippet

// snippet if_value
mut z : num = {if 232 % 2 == 0 : 1 else: 2 }
println(z)
// end snippet

// snippet block_value
mut z = {
    mut k = "Hi";
    k + "cory"
    }
println(z)
// end snippet

// snippet scope1
mut z = "cory"
z = { // z is global
    println "just a print"
    mut k = "Hi" // k is local
         + z // z is accessible
    // the value of the block is the last command executed
    // 'mut' assignments result the value assigned
    }
println(z)
try:
    println(k)
catch err: println err
// end snippet

// snippet local_redefined_error
mut z = 5
try{
    z = {
        println(z);
        mut z = 3
        }
}catch ex {
    println(ex)
}
// end snippet

// snippet function_scope
mut glb = "global variable";
class A {
  fn z(){
    println("You can read glb, which is a " + glb)
    try{
       // you cannot change it without declaring that it is global
       glb = 5;
    }catch(e1){
        println("exception 1:",e1)
    }
    try{
       // you touched it as global, you cannot declare it as local anymore
       mut glb = 5;
    }catch(e2){
        println("exception 2:",e2)
    }
    global glb;
    glb = "modified"
    return "You can access glb here it is " + glb ;
  }
}
mut obj = A()
println(obj.z())
// end snippet

// snippet class_definition
class X {
  mut s = "hu"
}
println("class var ", X.s)
mut x = X();
println("object var ", x.s)
// end snippet

// snippet object_scope
class X {
  mut s = "class field"
  cls.h = "another class field"
  fn constructor {
    mut g = "object field"
  }
  fn t(){
    // access object field explicitly through 'this'
    println("this.g=",this.g)
    // the object wraps the class scope and not the other way around
    // there is no 'g' defined in the class
    try: println("cls.g=",cls.g) catch err1: println err1
    // 'g' is in the wrapped scope of the object scope
    // this is same as 'this.g'
    try: println("g=",g) catch err2: println err2
    // 'this.h' is the same as 'cls.h' because of wrapping
    println("this.h=",this.h)
    println("cls.h=",cls.h)
    println("h=",h)
    // the same is true for the other field
    // does not matter how it was defined
    println("this.s=",this.s)
    println("cls.s=",cls.s)
    println("s=",s)
  }
}
mut x = X();
x.t()
// end snippet

// snippet closure_example
mut c = {
    mut whom = "World!";
    {|greeting|
        println(greeting,whom);
        whom = "Universe!"
    }
}
c("Hello, ")
c("Hi, ")
// end snippet

// snippet macro_example
mut c = macro(
    {|condition,then,`else`|
        if evaluate(condition) : evaluate(then) else: evaluate(`else`)
    })

print(

    c(true,"yes, it is true",{ println("this will never be printed") })

    );
// end snippet

// snippet let_with_types_example
mut c : str |num = 3;
c = "" + c + " == " + c
println(c)
// end snippet

// snippet pinning
mut turicum = 13
mut `list` = [1,2,3]
mut object = { x:1, y:2};
pin turicum, [`list`], {object}

try {
  turicum = 14;
}catch e1: println("could not change the variable")

try {
  `list`[1] = 0;
}catch e2: println("could not change the `list`")
`list` = [ 0, ..`list`, 4]
println("variable 'list' still can be changed: ", `list`)

try {
  object.x = 3;
}catch e3: println("could not change the object")
object = { x:1, y:3 }
println("variable 'object' still can be changed: ", object)

// end snippet

// snippet ifCommand
mut a= 13
if a%2 == 0: println("even") else: println("odd")
a = {if a%2 == 0: "even" else: "odd"}
print("again ",a)
// end snippet

// snippet whileLoop
mut i = 1;
while i < 5 {
  print(i," ");
  i++;
}until i % 3 == 0;
// end snippet

// snippet whileLoop2
 mut i = 1;
while i < 5 :
  i++;
until i % 3 == 0;
println(i)
// end snippet

// snippet for1
for i = 1 ; i < 5 ; i=i+1 {
  print(i," ")
}until i%3 == 0 ;
// end snippet
// snippet for2
for( i = 1 ; i < 5 ; i=i+1 ){
  print(i," ")
}
// end snippet
// snippet for3
// same as 'for( mut i = 1 ;' ...
for( i = 1 ; i < 5 ; i=i+1 ){
  print(i," ")
}until i%3 == 0 ;
try:
    println("i at end=",i);
catch err { println(); println err ; }
// end snippet
// snippet for4
mut i;
for {i = 1} ; i < 5 ; i=i+1 :  print(i," "); until i%3 == 0;
println("i at end=",i);
// end snippet
// snippet for5
mut i;
for i = 1 ; i < 3 ; i=i+1 {
    try: i++
    catch e: println "not possible to change loop variable in the loop it remained ",i
}

// end snippet
// snippet foreach1
for each i in [1,2,3,4]: print(i," ");
// end snippet

// snippet foreach2
for each i ∈ [1,2,3,4]: print(i," "); until i%3 == 0
// end snippet

// snippet foreach3
for each z with i in ["apple", "banana", "orange", "peach"] {
    println "%s. %s" % [i,z]
}
// end snippet

// snippet foreach4
for each [fruit, origin ] in [ ["apple","Ukraine"], ["banana","Brasil"], ["orange","Spain"], ["peach","Hungary"]] {
println "Fruit %s comes from %s" % [fruit, origin]
}
// end snippet

// snippet foreach5
for each [ j, z ] with i in enumerate(["apple", "banana", "orange", "peach"]) {
println "%s.%s. %s" % [i, j, z]
}
// end snippet

// snippet yield1
fn gen_1_to_10 {
    for i=1 ; i <= 10 ; i++:
        yield i;
}

println([ .. (async gen_1_to_10()) ])
// end snippet

// snippet yield2
fn gen_1_to_10 {
    for i=1 ; i <= 10 ; i++:
        yield i;
}

mut st = async gen_1_to_10();
while st.has_next() :
    println(st.next());
// end snippet

// snippet string_length
print len("abraka dabra") == "abraka debra".length()
// end snippet

// snippet fun1
fn inc(x) {
  x+1
}
println str(inc).before("@")
println(inc(1))
// end snippet

// snippet fun3
fn inc x {
  x+1
}
println str(inc).before("@")
println(inc(1))
// end snippet

// snippet fun2
mut inc = fn (x) {
  x+1
}
println str(inc).before("@")
println(inc(1))
// end snippet

// snippet fun4
fn inc !x, @how_much {
  x+how_much
}
println str(inc).before("@")
println(inc(1,how_much=5))
// end snippet

// snippet fun5
fn inc !x, @how_much=1 {
  x+how_much
}
println(inc(1,how_much=5))
println(inc(1))
// end snippet

// snippet fun6
fn wrong !x, h, !k {
  // just don't do
}
try: wrong(1,3, h= 2)
catch e: println("There is an error",e)
// end snippet

// snippet restParameters
mut f = fn (a,b,[rest]) {
  println("a=",a)
  println("b=",b)
  for each r in rest: print("%s " % r)
}

f(1,2,3,4,5,6)
// end snippet

// snippet metaParameters
mut f = fn (a,b,{meta}) {
  println("a=",a)
  println("b=",b)
  for each r in keys(meta): print("%s=%s\n" % [r , meta[r]])
}

f(1,b=2,k=3,x=4,juice=5,six=6)
// end snippet

// snippet metaRestParameters
mut f = fn (a,b,[rest],{meta}) {
  println("a=",a);
  println("b=",b);
  for each r in keys(meta): print("%s=%s\n" % [r , meta[r]]);
  println("rest:");
  for each r in rest: print("%s " % r);
}

f(1,b=2,k=3,x=4,juice=5,7,six=6);
// end snippet

// snippet closureArgument
mut f = fn (a,b,^closure) {
  println("a=",a);
  println("b=",b);
  println(closure(a,b))
}

f(2,3){|x,y| x+y}
f(2,3){|x,y| x*y}
// end snippet
// snippet spread
fn a(@a,@b,@c,@d){
    println("%s %s %s %s " % [a,b,c,d])
}
fn b(!a,!b,!c,!d){
    println("%s %s %s %s " % [a,b,c,d])
}
fn c(a,b,c,d){
    println("%s %s %s %s " % [a,b,c,d])
}

a(..{a:1,b:2,c:3,d:4});
b(..[1,2,3,4]);
c(..[1,2],..{d:4},3);
// end snippet

// snippet spreadStream
fn c(a,b,c,d){
    println("%s %s %s %s " % [a,b,c,d])
}
fn numbers {
  for i = 1 ; i <= 4 ; i++ : yield i
}

c(..(async numbers()))
// end snippet

// snippet closureDecorator1
  fn closure_decorator(^closure){
    {|| println("We start"); closure(); println("We finish")}
  }

  mut z = closure_decorator(){|| println("We are closure") }

  z()
// end snippet

// snippet closureDecorator2
  fn closure_decorator(^closure){
    {|| println("We start@"); closure(); println("We finish@")}
  }

  mut z = @closure_decorator(){|| println("We are closure") }

  z()
// end snippet

// snippet fnDecorator1
  fn fun_decorator(^closure){
    {|| println("We start the fun"); closure(); println("The fun is over")}
  }

mut z =
@fun_decorator()
fn q(){
  println("We function");
}
  z()
// end snippet

// snippet fnDecorator2
  fn fun_decorator(^closure){
    {|| println("We start the fun"); closure(); println("The fun is over")}
  }

mut z =
fun_decorator(
fn q(){
  println("We function");
})
  z()
// end snippet

// snippet fnDecorator3
mut fun_decorator={|^closure|
        set(closure.name,
            {|| println("We start the fun"); closure(); println("The fun is over")}
           )
    }

@fun_decorator()
fn q(){
  println("We function");
}

q()
// end snippet

// snippet fnDecorator4
{
    fn globalize(^closure){
            set_global(closure.name,closure)
        }

    @globalize()
    fn q(){
      println("We function");
    }
}
q()
// end snippet

// snippet fnDecorator5
fn fun_decorator(^closure){
        set_caller(closure.name,
            {|| println("We start the fun"); closure(); println("The fun is over")}
           )
    }

{
    @fun_decorator()
    fn q(){
      println("We function");
    }

    q()
}
// end snippet

// snippet that
class OuterClass {
    mut name = "outer class";
    fn init(){
      mut name = "outer object"
    }
    class InnerClass {
        mut name = "inner class";
        fn init() {
            mut name = "inner object"
            println("this name %s " % this.name)
            println("this name %s " % cls.name)
            println("this name %s " % that.name)
            println("this name %s " % that.cls.name)
            }
        }
    }
mut outer = OuterClass()
mut inner = outer.InnerClass()
// end snippet

// snippet fibonacci1
fn fib(x) {
    if x == 1 || x == 0 : 1
    else: fib(x - 1) + fib(x - 2)
}
println(fib(10))
// end snippet

// snippet fibonacci2
class FibCalculator {
    mut cache = [];
    fn fib(x) {
        if x == 1 || x == 0 : 1
        else{
            return cache[x] when cache[x] != none;
            cache[x] = fib(x - 1) + fib(x - 2);
        }
    }
}
println(FibCalculator.fib(10))
// end snippet

// snippet fibonacci3
try
{
    fn fib(x) {
        if x == 1 || x == 0 : 1
        else: fib(x - 1) + fib(x - 2)
    }
    println(fib(10))
}catch ex : println(ex)
// end snippet

// snippet fibonacci4
{
    mut fib={|x|
        if x == 1 || x == 0 : 1
        else: fib(x - 1) + fib(x - 2)
    }
    println(fib(10))
}
// end snippet

// snippet fibonacci5
{
    fn fib(x,fib=fib) {
        if x == 1 || x == 0 : 1
        else: fib(x - 1) + fib(x - 2)
    }
    println(fib(10))
}
// end snippet

// snippet fibonacci6
{
    fn fib(x) {
        if x == 1 || x == 0 : 1
        else: me(x - 1) + me(x - 2)
    }
    println(fib(10))
}
// end snippet

// snippet fibonacci7
mut fib = {
    mut cache = [];
    {|x|
        if x == 1 || x == 0 : 1
        else{
            return cache[x] if cache[x] != none;
            cache[x] = me(x - 1) + me(x - 2);
        }
    }
}
println(fib(10))
// end snippet

// snippet fibonacci8
class FibCalculator {
    fn init(start=1) {
        mut cache = [];
    }
    fn fib(x) {
        if x == 1 || x == 0 : start
        else{
            return cache[x] if cache[x] != none;
            cache[x] = fib(x - 1) + fib(x - 2);
        }
    }
}
println(FibCalculator().fib(10))
println(FibCalculator(2).fib(10))
// end snippet

// snippet evaluate1
mut twice = macro(fn (arg){ evaluate(arg); evaluate(arg);});
twice( {println("Hello")} )
// end snippet

// snippet evaluate2
macro(fn (!arg,[rest],{meta},^closure)
            { evaluate(arg)(..rest,..meta,..closure)}
     )(fn () {println("Hello")})
// end snippet

// snippet evaluate3
(fn (!arg,[rest],{meta},^closure)
            { arg(..rest,..meta,..closure)})
     (fn () {println("Hello")})
// end snippet

// snippet limited_import
sys_import "turi.maven" , "lic*"

println license.apache2_0.name
println "The next printout is the error message, because github() is exported but we do not import it."
try : println github("verhas", "turicum"); catch e: println e
// end snippet

// snippet import
global APPIA = ["./src/test/resources/"];

let fun = import("import_this").imported_fun

print fun()

// end snippet

// snippet class1
class A {
    fn init {
        mut a = "a";
    }
    mut c = "c"
}
mut a1 = A()
mut a2 = A()
a1.a = "1"
a2.a = "2"
A.c = "d"
println a1.a, a2.a, a1.c, a2.c

// end snippet

// snippet class2
class A {
    fn init {
        this.a = "a";
    }
    cls.c = "c"
}
mut a1 = A()
mut a2 = A()
a1.a = "1"
a2.a = "2"
A.c = "d"
println a1.a, a2.a, a1.c, a2.c

// end snippet

// snippet class3
class A {
    fn init {
        this.a = "a";
    }
    fn p {
        println "I am class level"
    }
}
mut a1 = A()
a1.p()
a1.p = fn (){
  println "I am a1"
}
mut a2 = A()
a2.p = fn (){
  println "I am a2"
}

a1.p()
a2.p()

// end snippet

// snippet class4
class A {
    fn p {
        this = none
    }
}
try :
    A().p()
catch ex :
    println ex
// end snippet

// snippet class5
class A {
    fn p {
        cls = none
    }
}
try :
    A().p()
catch ex :
    println ex
// end snippet

// snippet class6
class A {
    fn init {
      this = B()
    }
}

class B {

}

println A().cls

// end snippet

// snippet class7
class A {
    fn init {
      cls = B
    }
}

class B {

}
try:
    A()
catch ex:
    println ex

// end snippet

// snippet class8
class A {
    class B {
        fn init {
            println "this ", this
            println "cls ", cls
            println "that ", that
        }
    }
}

mut a = A()
mut b = a.B()
// end snippet

// snippet try1
mut z = {
    try {
        z = 55 // undefined variable
    }catch e {
      66
    } finally {
      println "this will always run"
    }
}
println "z is now 66, is it ? ",z
// end snippet

// snippet try2
try{
    try {
        z = 55 // undefined variable
    }
}catch e: println e
// end snippet

// snippet try3
try{
        z = 55 // undefined variable
}catch x : mut error:err = x

println error

// end snippet

// snippet try4
try{
        z = 55 // undefined variable
}catch error: ;

println """message "%s" """ % [error.message]
println """cause "%s" """ % [error.cause]
println """suppressed %s" """ % [error.suppressed]
for each st in error.stack_trace {
    println("%s:%s:%s" % [st.file, st.line, st.column])
    println "source: ", st.source
    }


// end snippet

// snippet try5
mut error:err|none
try{
        z = 55 // undefined variable
}catch err: error = err

println """message "%s" """ % [error.message]
println """cause "%s" """ % [error.cause]
println """suppressed %s" """ % [error.suppressed]
for each st in error.stack_trace {
    println("%s:%s:%s" % [st.file, st.line, st.column])
    println "source: ", st.source
    }


// end snippet

// snippet try6
try (mut a = 1;
       mut b = 2;
       mut c = 1 / 0;
      )
catch e println e;

println "Do we have a? ", is_defined(a)
println "Do we have b? ", is_defined(b)
println "Do we have c? ", is_defined(c)
// end snippet

// snippet try7
mut a = 3;
try : (a = 1;
       println "we redefined 'a'"
       mut b = 2;
       println "we defined 'b'"
       1/0; // exception
      )
catch e : println e;

println "Do we have a? ", is_defined(a)
println "Was it changed or still 3? It is ",a
println "Do we have b? ", is_defined(b)
// end snippet

// snippet pscope

println "2*3=",2*(mut s=3)
println "s is defined and it is ",s
println "2*3=",2*{mut k=3}
try : mut h = 2*k
catch e : println e;
// end snippet

// snippet type1

mut s = "13"; mut i = 13; mut d = 3.14;

mut err
try: z = 6.55
catch ex: err=ex
class A {}

println "\"13\" ", type("13")
println "13 ", type(13)
println "3.14 ", type(3.14)
println "err ",type(err)
println "A() ",type(A())
println "[1,2,3] ",type([1,2,3])
println "A ",type(A)
println "fn()=3 ",type(fn()=3)
println "{|| 3} ",type({|| 3})
println "que(1) ",type(que(1))
println "async ",type(async 1)
println "macro ",type(macro(fn()=3))
println "none ",type(none)
println "java object ", type(java_object("java.lang.Object"))

// end snippet

// snippet java_object1
let bd1 = java_object("java.math.BigDecimal", "10.50");
let bd2 = java_object("java.math.BigDecimal", "3.25");
let result = bd1.add(bd2)
println result
// end snippet

// snippet java_object2
let sb = java_object("java.lang.StringBuilder", "xBruhahha");
try: sb.deleteCharAt(0) catch e: println e
sb.deleteCharAt(int(0))
println sb
// end snippet

// snippet java_call1
let sb = java_object("java.lang.StringBuilder", "xBruhahha");
java_call sb,"deleteCharAt",int(0)
println sb
// end snippet

// snippet java_class3
let Locale = java_class("java.util.Locale")
// Locale constructor is vararg
let l1 = Locale("en", "US");
let l2 = Locale("en", "US", "POSIX");
println "%s %s" % [l1, l2]
// end snippet

// snippet java_class2
let BigDecimal = java_class("java.math.BigDecimal")
let h = BigDecimal("10.50")
println $"h is ${h} of ${type(h)}"
// end snippet

// snippet java_class1
let m = java_class("java.lang.Math");
println m.abs(-5)
println m.absExact(int(-5))
// end snippet

// snippet sleep
println sleep(0.001) // sleep one milli
// end snippet

// snippet reclose
fn my_fun(@close_it) {
  mut s: str = "in function";
  return reclose(close_it)
}

mut s:str ="outer";
// this closure has a reference to 's' that contains "outer"
// it prints the value of the enclosed variable and then
// changes to a new value passed as argument
let closure = {|x| println s; s = x};
// after reclosing the new closure stored in 'reclosure' refers to the
//variable 's' in the 'my_fun' function
let reclosure = my_fun(close_it=closure);
// another reclosure will reference another 's'
// local variables are allocated dynamically
let rereclosure = my_fun(close_it=closure);

// prints the original "outer" and sets the variable to "closure 1"
closure("closure 1")
// prints "in function" and sets the 's' inside the function
reclosure("reclosure 1")
// prints "in function" and sets the 's' inside the second function
rereclosure("rereclosure 1")
println "s = %s" % s // prints "closure 1"

// we repeat the call sequence
closure("closure 2") // output is "closure 1"
reclosure("reclosure 2") // and "reclosure 1"
rereclosure("rereclosure 2") // and "rereclosure 1"
println "s = %s" % s // the new value is "closure 2"
// end snippet

// snippet die

sys_import "turi.throw"

try:
    throw "wuff"
catch ex:
    print "don't die"
// end snippet

// snippet que1
let q = que(3) // create a queue that can hold 3 messages
println q.send("apple"), " apple is sent" // return value true means the message was sent
println q.send("birne"), " birne ist geschickt"
println q.try_send("peach"), " means ok"

// q.send("queue is full") // this would wait infinitely
// or until some other thread reads something from the queue and there is space to send

println q.try_send("fail"), " means no" // false means sending failed, the queue is full

// just print out the fruits we read from the queue
println q.receive()
println q.receive()
println q.receive()

// println q.receive() // this would wait infinitely, there is nothing in the queue
// or until some other thread puts something into the queue

// try_receive() returns none if there is nothing in the queue
println q.try_receive()," return none, there is nothing in the queue"

// it also returns none if there is a none in the queue
q.send(none)
println q.receive(), " was received... how do we know?"
// we send again a none
q.send(none)
// check that there is something in the queue
if q.has_next() : print "has_next() is true: it has value and it is "
// we can be sure the 'none' was coming as a message from the queue
println q.try_receive()
// end snippet

// snippet que
/**
 * A printing function that will print the objects received through the que `q` till it gets closed.
 */
fn printer(q,@name){
    mut n = 0 // counts the number of not-ready que attempts
    while {
        mut s = q.try_receive(); // try to receive one or get none if there is nothing in the queue
        return { println "%s is done" % name } if q.is_closed(); // return when the que is closed
        if s == none {
            println "%s is not ready %s" % [name,n]
            n++ // count the attempts
            sleep 0.003 // sleep 3 mili
        } else {
            n = 0 // reset the attempts, we go an object to print
            println "%s is ready %s" % [name,s];
        }
    }
}

// create ONE queue that will be consumed by two
mut q : que = que(3)
// create two asynchronous task. they start immediately
mut task1 : task = async printer(q,name="task1")
mut task2 : task = async printer(q,name="task2")
// send the numbers 1 to 10 to the queue, whoever is lucky can get it
for i=1 ; i < 10 ; i++ {
    q.send(i);
    sleep 0.01
    }
println "closing the channel"
q.close();
println "channel is closed"
println "1 is done %s" % task1.is_done()
println "2 is done %s" % task2.is_done()

// get only the tasks into the list which are not done yet
mut task_list = [ task1, task2 ? !it.is_done() ]

println "we start to wait the first time"
await task_list

println "task1 done %s" % task1.is_done()
println "task2 done %s" % task2.is_done()
println "We start to wait the second time"
// have to use [] empty options, no timeout because a list literal stands after it
await[] [ task1, task2 ? !it.is_done() ]

println "task1 done %s" % task1.is_done()
println "task2 done %s" % task2.is_done()

none
// end snippet

// snippet async_list

mut z = async[] [ 1, 2,  3, 4];
mut k = await z
print str(k).left(len("ch.turic.memory.Channel$SimpleMessage@"))

// end snippet
// snippet try_yield
fn printer(){
    mut n = 0
    while {
        mut s = try_yield();
        return { println "we are done" } if yield_is_closed();
        if s == none {
            println "not ready %s" % n
            n++
            sleep 0.003
        } else {
            n = 0
            println "received %s" % s;
        }
    }
}

mut task : task = async printer()
for i=1 ; i < 4 ; i++ {
 println "sending ",i
 task.send(i);
 sleep 0.009
 }
println "closing the channel"
task.close();
println "channel is closed"
println "is done %s" % task.is_done()
await task
println "is done %s" % task.is_done()

none
// end snippet

// snippet async
mut t:task = async {
    for i=0 ; i < 10 ; i++ {
        yield i
    }
    55
}

while t.has_next():
    print t.next(), " "
println()
println(await t)

// end snippet

// snippet channel_limit

/**
  * a very simple prime number filter
  */
fn is_prime(x:num):bool {
    return true if x == 2;
    return false if x % 2 == 0;
    for n = 3 ; n*n <= x ; n = n + 2 :
        return false if x % n == 0
    true
}
/**
  * Create a generator with limited que size.
  * Then read from it and print.
  */
fn execute(name:str, que_length:num){
    mut prime = async[in=que_length] {
        yield 2;
        mut i = 3;
        while {
            if is_prime(i) {
                yield i
                println name, " generated ", i
            }
            i = i + 2; // only the odd numbers
        }
    }

    mut count = 0
    while prime.has_next(){
        println " prime read ",prime.next()
        count++
        }until count > 3 // limit the printout to the first three primes
    sleep 1 // will give time for the generator to run ahead uselessly
    println "stopping"
    prime.stop()
    // the error is cancellation, since we stopped the task
    try: await prime catch e : println "exception ", e
}
// only 5 for demonstration, in real life it can be millions eating memory
// five now stands for "unlimited size"
execute("Thread 1",5)
// limited channel size will stop the running ahead
execute("Thread 2",2)
// end snippet


// snippet flat_let_object1

let z = { a: "apple", b:"bier", c : "count" }
let {a, b, c} = z
println a
println b
println c
// end snippet

// snippet flat_let_object2

let z = { a: "apple", b:"bier", c : "count" , d: "not used" }
let {a, b, c, f} = z
println a
println b
println c
println f
// end snippet

// snippet flat_let_list1
mut [a, b, c] = [1,2,3]
println a
println b
println c
// end snippet

// snippet flat_let_list2
try:
    let [a, b, c, f] = [1,2,3]
catch err: println err
// end snippet

// snippet flat_let_list3
try:
    mut [a, b] = [1,2,3]
catch err: println err
// end snippet

// snippet flat_let_list4
mut [a, b] = [1,2,3,4,5,6,7,8][0..2]
println a
println b
// end snippet

// snippet flat_let_list5
fn adjust(_x, @to){
    mut x = _x
    if len(x) < to :
        while len(x) < to :
            x = [..x, none]
    else :
        x = x[0..len(x)]
    x
}
mut [a, b, c, d] = adjust(to=4,[1,2])
println a
println b
println c
println d
// end snippet

// snippet flat_let_list6
fn adjust(@to,[_x]){
    mut x = _x
    if len(x) < to :
        while len(x) < to :
            x = [..x, none]
    else :
        x = x[0..len(x)]
    x
}
mut [a, b, c, d] = adjust(to=4, 1,2)
println a
println b
println c
println d
// end snippet

// snippet let_map1
let { a , b , k -> [c,d,e , {f , k -> g }]} = {a:1,b:2, k: [3,4,5,{f:6, k: 7}]};
println a
println b
println c
println d
println e
println f
println g
// end snippet

// snippet let_map2
let b = []
mut { a:num , b -> b[0] } = {a:1,b:2};
println a
println b
// end snippet

// snippet let_map3
mut b = 5
try:
  let { a , b  } = {a:1,b:1};
catch e: println e
// end snippet

// snippet let_map4
let b = []
mut { a:num , let b -> [ x, y, z ] } = {a:1,b:[1,2,3]};
a = 5 // a is mutable
try: x = 77 catch e: none // x is immutable will not change
println a
println x
println y
println z
// end snippet

// snippet let_map5
mut { a:num , let b } = {a:1,b:1};
a = 5 // a is mutable
try: b = 5 catch e: none // b is immutable will not change
println a
println b
// end snippet

// snippet let_map6
mut a:num = 3
try:
  mut { a:num , let b } = {a:1,b:1};
catch e: println e
// end snippet


// snippet re
sys_import "turi.re"

fn print_match(m){
    for i=0 ; i < len(m.group) ; i++ {
        mut {index, start, end } = m.group[i];
        println "%s. '%s'.substring(%s,%s)='%s'" % [index,s,start, end,s[start..end]];
    }
}

mut s = "abrakadabra";
mut rx =Re("a(b)ra(ka)(dabra)")
mut m = rx.match(s);
println m
print_match(m);

s = "xxx"+s+"yyy";
m = rx.match(s);
if m.group == none :
    println "does not match because of xxx and yyy"
println m, " is an empty object"
m = rx.find(s)
if m.group != none :
    println "matches because we find and not match"
print_match(m);
// end snippet


// snippet re2
sys_import "turi.re"

mut m = Re("a(?<firstb>b)ra(?<twoletter>ka)(dabra)").match("abrakadabra");
println "the ks is '%s'" % [m.name.twoletter]
// end snippet

// snippet preprocessorSample
fn hi(){ // this will be deleted, it only exists in the preprocessor context
  "hello "
}
// the next line starts the preprocessor
# {|lexes|
["""
    // this is a string that will lead the new lexical token list
    mut M:str = ""
    fn helvetic_hi(){
      "Gruetzi "
    }
    fn hi() { "hullo" }
    M = M + "hello ";
    M = M + (hi() or "none ");
""",
// and just mut's have the rest of the tokens
..lexes]
} // end of the preprocessor command

// this is preprocessed
M = M + helvetic_hi() + "ant hunter"
print M
// end snippet

// snippet inherit1
class P {
    fn a()=1
    mut v = 2
}
class C : P {
    fn b()=3
    mut z = 4
}
mut o = C();
println o.a(),o.v,o.b(),o.z;
// end snippet

// snippet inherit2
class P1 {
    fn a()=1
    mut v = 2
}
class P2 {
    fn aa()=3
    mut vv = 4
}
class C : P1,P2 {
    fn b()=5
    mut z = 6
}
mut o = C();
println o.a(), o.v, o.aa(), o.vv, o.b(), o.z;
// end snippet

// snippet inherit3
class P1 {
    fn a()=1
    mut v = 2
}
class P2 {
    fn a()=3
    mut v = 4
}
class C : P1,P2 {
    fn b()=5
    mut z = 6
}
mut o = C();
println o.a(), o.v, o.b(), o.z;
// end snippet

// snippet inherit4
class P1 {
    fn init {
        println "init in P1, cls='%s' this='%s'" % [cls, this]
    }
}
class P2 {
    fn init {
        println "init in P2, cls='%s' this='%s'" % [cls, this]
    }
}
class C : P1,P2 {
    fn init {
        println "init in C, cls='%s' this='%s'" % [cls, this]
    }
}
mut o = C();
// end snippet

// snippet inherit5
class P1 {
    fn init {
        println "init in P1, cls='%s' this='%s'" % [cls, this]
    }
}
class P2 {
    fn init {
        println "init in P2, cls='%s' this='%s'" % [cls, this]
    }
}
class C : P1,P2 {
    fn init {
        println "init in C, cls='%s' this='%s'" % [cls, this]
        P1.init()
        P2.init()
    }
}
mut o = C();
// end snippet

// snippet inherit6
class P {
    fn init {
        println "init in P, cls='%s' this='%s'" % [cls, this]
    }
}
class C : P {
}
mut o = C();
// end snippet

// snippet inherit7
class P {
    fn init(a,b);
}
class C : P {
    fn init(b,c){
        P.init(3,4)
    }
}

let object = C(1,2);
print object
// end snippet

// snippet inherit8
class Parent {
    fn init(b:str){
        }
}
class Child : Parent {
    fn init(b:num){
        Parent.init("mutabor")
        this
    }
}

let k = Child(42);
try: k.b = none; // will fail as it is num and str, which
catch e: println e; // we should see in the error
// end snippet

// snippet fun7
fn concat(a:str, b:str):str = a + b
println concat("ab","ba")
// end snippet

// snippet fun8
fn concat(a:str, b:str):str = 13
try:
    println concat("ab","ba")
catch err: println err
// end snippet


// snippet fun9
mut myString="num"
fn concat(a:str, b:str):(myString) = 13
myString = "str"
try:
    println concat("ab","ba")
catch err: println err
// end snippet

// snippet fun10
fn p()=len "original K";
println str(p()).left("ch.turic.builtins.functions.Len".length())
// end snippet

// snippet fun11
fn p()=(len "original K");
println p()
// end snippet

// snippet fun12
fn p()=len("original K");
println p()
// end snippet

// snippet dot_method1
class B {
  fn init(a,b,c);

  fn `.` {
    println a,b,c
  }
}
B(1,2,3).`we can write here anything`()
// end snippet

// snippet dot_method2
class B {
  fn `.` {
    // print the name of the method, `.`
    // `.` is a local variable holding the name of the metod
    // this.`.` is still the method itself (not the name)
    println `.`
  }
}
B().`we can write here anything`()
// end snippet

// snippet dot_method3
class B {
  fn `.` {
    println str(this.`.`).before("@")
  }
}
B().`we can write here anything`()
// end snippet

// snippet is_defined
if is_defined(z) : println "defined" else: println "not defined";
mut z = 1
if is_defined(z) : println "defined" else: println "not defined";
try:
    println {if is_defined(z+2) : "defined" else: "not defined"}
catch: println "no way"
// end snippet


// snippet objectAddition1
class LN {
    fn init( a ){

    }
    fn `+` ( other ){
            LN( this.a * other.a )
    }
}
println (LN(2) + LN(4)).a
// end snippet

// snippet myEqual
class A {
  fn `==`(other) : bool {
    this.a == other.a
  }
}

mut x = A()
mut y = A()
mut z = { a: 1, b: "x" }

x.a = 1
x.b = "x"

y.a = 1
y.b = "y"

println "x == y is %s" % (x == y)
println "y == z is %s" % (y == z)
// end snippet

// snippet myEqual2
class A {
  fn `==`(other) : bool {
    return false if cls != other.cls
    a == other.a
  }
}

mut y = A()
mut z = { a: 1, b: "x" }

y.a = 1
y.b = "y"

println "y == z is %s" % (y == z)
// end snippet

// snippet unlet
class Z {
    fn init(obj){
        for each t in keys(obj){
            this[t] = obj[t]
        }
        // arguments to `init` are automatically fields
        // we do not need this extra field here
        unlet obj;
    }
}
mut z = Z({
    a: {
        B : "abraka"
        },
    c : ""
    });
println z
// end snippet

// snippet ListLiteral1
mut computed = {fn(a,b) = a + b}(1,2);
println [1, 2, 3, 4]
println ["apple", "banana", "cherry"]
println [1 + 2, computed]
// end snippet

// snippet ListLiteral2
mut a = [1, 2, 3, 4]
mut b = ["apple", ..a, "banana", "cherry"]
println b
// end snippet

// snippet ListLiteral3
mut a = [1, 2, 3, 4]
mut b = [5, 6, 7]
println([..a, ..b])
// end snippet

// snippet ListLiteral4
mut a = [1, 2, 3, 4]
mut b = [1, 3]
println a,"+",b,"=", a+b
println a,"-",b,"=", a-b
println a,"*", b,"=", a*b
println a,"+\"sixteen\"=", a+"sixteen"
println a,"-",2,"=", a-2
// end snippet

// snippet ListLiteral5
mut a = [1, 2, 3, 4]
mut b = [1, 3]
println a+[b]
// end snippet

// snippet ListLiteral6
mut a = [1, 2, 3, 4]
println [a[0],..a[2..inf]]
// end snippet

// snippet ListLiteral7
mut a = [1, 2, 3, 4 ? {|x| x % 2 == 0 } ]
println a
// end snippet

// snippet ListLiteral8
mut a = [1, 2, 3, 4 ? {|x| x % 2 == 0 } -> {|z| return z/2 }]
println a
// end snippet

// snippet ListLiteral9
mut a = [1, 2, 3, 4 ? {|| it % 2 == 0 } -> {|| return it/2 }]
println a
// end snippet

// snippet ListLiteral10
mut a = [1, 2, 3, 4 ? it % 2 == 0  -> it/2 ]
println a
// end snippet

// snippet xor1
println 12 ^ 2
println ?(12.0 ^ 2) or "does not work for floating points"
println( [1,2,3] ^ [3,4,5] )
// end snippet

// snippet mod1
println "2*3=%s" % [2*3]
println "2/3=%s" % [2/3]
println "2%%3=%s" % [2%3]
println "aa " * 6
println( [1,2] * [6])
println( [1,2,3] % [3,4,5] )
println( [1,2,3 ? it in [3,4,5]] )
// end snippet

// snippet shr1
println 8>>2
println "artany" >> "...... ..."
println([1,2,3] >> [-1,-2,-3])
// end snippet

// snippet power
die "** failed" if 2 * 3 ** 3 != 2* (3 ** 3)
// end snippet

// snippet equal1
mut k = { a:1 , b:2 }
mut q = { a:1 , b:2 }
mut w = "ohmy"
println 1 == 1, " one is one"
println 1 == 2, " one is not two"
println 1 === 1, " one is the same as one"
println 1 === 2, " one is not the same as two"
println k == q, " k equals q, but"
println k === q, " k is not the same as q"
println w == "ohmy", " w is 'ohmy'"
println w === "ohmy", " w is not that 'ohmy'"
// end snippet

// snippet inop
println "raka" in "avraka dabra", " there is 'raka' in 'avraka dabra'"
println "raka" in "evreke debre", " there is no raka in 'evreke debre'"
println 3 in [1,2,3], " 3 is in [1,2,3]"
println 3 in [1,2,4], " 3 is not in [1,2,4]"
// end snippet

// snippet bor1
println 1 | 2
println( [1,1,2,3,3,2,1] | [])
println ( { a:1, b: 2, c: { h: 1, z:2} w: ["k","h","dr."] }
            | { a:11, b: 22, c: { k:7} , w : [1,2,3]} )
try:
    3.0 | 3.14
catch e: println e
// end snippet

// snippet band1
println 7 &  2
println [1,1,2,3,3,2,1] & [2, 3, 7]
try:
    3.0 & 3.14
catch e: println e
// end snippet

// snippet compare
println 1 < 2
println 3 <= 3
println 4 > 3
println 4 >= 4
// end snippet

// snippet and
if (7&2) == 3 && 5/0 == inf {
    println "something is wrong"
}else{
    println "dandy"
}
// end snippet

// snippet logical_or
if (7&2) == 2 || 5/0 == inf {
    println "dandy"
}else{
    println "something is wrong"
}
// end snippet

// snippet oror
println none or 3
// end snippet

// snippet string_functions
println " 1. ","alma kadarka".after("ka")
println " 2. ","alma kadarka".before("ka")
println " 3. ","alma kadarka".between("ma","da")
println " 4. ","aa ".times(6)
println " 5. "," aa ".trim()
println " 6. ","aa ".starts_with("a")
println " 7. ","aa".ends_with("a")
println " 8. ","AA".lower_case()
println " 9. ","aa".upper_case()
println "10. ","a,b,c,d".split(",")
println "11. ","abcd".bytes()
println "12. ","abc".char_at(2), " is c"
println "13. ","alma kadarka".index_of("ka")
println "14. ","alma kadarka".last_index_of("ka")
println "15. ","alma kadarka".replace_all("a|d","e")
println "16. ","\n\t\r".quote()
println "17. ","alma kadarka".reverse()
println "18. ","alma kadarka".chop().chop()
println "19. ","alma kadarka\n".chomp()
println "20. ","alma kadarka".chomp()
println "21. ","alma kadarka".contains("ma ka")
println "22. ","alma kadarka".left(4)
println "23. ","alma kadarka".right(4)
println "24. ","alma kadarka".count_substring("a")
println "25. ","kadarka".pad_left(12)
println "26. ","kadarka".pad_left(12,".")
println "27. ","kadarka".pad_right(12) + "<"
println "28. ","kadarka".pad_right(12,".")
println "29. ","   ".is_blank()
println "30. ","   ".is_empty()
println "31. ","+6.2E23".is_numeric()
println "32. ","+6.2E23".is_digit()
println "33. ","6223".is_digit()
println "34. ","Euler Number".is_numeric()
println "35. ","EulerNumber".is_alpha()
println "36. ","EulerNumberisnot314".is_alphanumeric()
println "37. ","2AF".is_hex()
println "38. ","0x2AF".is_hex()
println "39. ","2AF".hex()
println "40. ","0x2AF".hex()
println "41. ","0x2AF".base64()
println "42. ","MHgyQUY=".from_base64()
println "43. ","MHgyQUY=".from_base64_str()
println "44. ","alma van a fa = alarr://".url_encode()
println "45. ","alma+van+a+fa+%3D+alarr%3A%2F%2F".url_decode()
println "46. ","line 1\nline2\n\nline4".lines()
println "47. ","What do you read, my lord? Words, words, words.".words()
println "48. ","alma kadarka".remove_prefix("alma")
println "49. ","alma kadarka".remove_postfix("kadarka")
println "50. ","alma kadarka".remove_prefix("apple")
println "51. ","alma kadarka".remove_postfix("kik")
println "52. ",">" + ("alma".safe_char_at(666)) + "<"
println "53. ",",".join(["abrak","a","dabra","lonak","zabla"])
println "54. ","aaa".md5()
println "55. ","aaa".sha_1()
println "56. ","aaa".sha_256()
println "57. ","aaa".sha_512()
println "60. ","aaa".digest("MD5")
println "61. ",61.hex()
println "62. ","mut z = if a == 3 :  3 else: 5;".turi_lex()
println "63. ","mut M= \"\"; for i=0 ; i < 8 ; i++ : M = M + i; M".execute()
println "64. ",M
println "65. ","65".int() , "is 65... literally"
println "65. ","3.14".float(), " is 3.14"
println "66. ","0765".number(8), " is ", 8*8*7+8*6+5
// end snippet

// snippet hexNumber
mut z = 0xFfE3;
println z
// end snippet

// snippet string
print "this is a simple string"
// end snippet

// snippet mlstring
println """
Hello,
  This is a multiline string.
Goodbye.
"""
// end snippet

// snippet simpleWith
mut x = {a:1,b:2};
mut y = {a:4,c:5};
with x,y {
    println a
    println b
    println c
}
// end snippet

// snippet modifyWith
mut x = {a:1,b:2};
mut y = {a:4,c:5};
with x, y {
    a = 0
    b = 0
    c = 0
    mut k = 55;
    pin b
}
try: x.b = 55 catch e: println e
println x
println y
// end snippet

// snippet valueWith
mut x = {a:1,b:2};
mut y = {a:4,c:5};
println {with x,y : a * b + c}
// end snippet

// snippet print_redirect
class Printer {
    fn init(m:str="");
    fn write(s:str){
        if !len(m) == 0 && !m.ends_with("\n"):
            m = m + " "
        m = m + s;
    }
    fn flush {
        println "flushing is essential"
    }
    fn entry {
        this
    }
    fn exit(e){
    }

    fn get {
        m
    }
}


let printer = Printer();

with printer as print_target {
    println "Once upon a midnight dreary","Edgar"
    println "God in his wisdom made the fly","Ogden"
    }
println "Are you mental mixing poems?"
println printer.get()

{
mut print_target = {|message:str|
                        let print_target = none;
                        if message == "\n" :
                            println ;
                        print "Said the raven:", message;
                        }
println "never more, to the fly";
}
// end snippet

// snippet entryAndExitWith
class A {
    fn init {
        let res = Resource();
    }

    fn entry {
        println $"entry to A ${this}"
        res
    }

    fn exit( e: err|none = none) {
        println $"exit fom A ${this} with ${e} as exception"
        res.close()
        return true; // suppress  exceptions
    }
}

mut object_counter = 0;

class Resource {
    fn init {
        global object_counter;
        let me_counter = object_counter;
        object_counter++;
    }
    fn printf(x,[rest]){
        println s % rest
    }
    fn close(){
        println $"closing resource ${me_counter}"
    }
}

let x = A();
with x as a {
    println $"a resource id is ${a.me_counter}"
    println "executing with A and B"
    die "mad dog"
}
// end snippet

// snippet entryAndExitWith2
class A {
    fn init(a=1,b=2);
    fn entry {
        println "entry to A"
        { a: 7, b:8 }
    }
    fn exit e:err|none {
        println "exit fom A"
    }
}
class B {
    fn init(a=4,c=5);
    fn entry {
        println "entry to B"
    }
    fn exit (e){
        println "exit fom B"
    }
}
with A() as x, B() as y {
  println x.a,x.b,y.c
}
// end snippet
// snippet withAs
class ResourceManager {
    fn init {
        // each resource manager object can manage one resource object
        let res = Resource();
    }

    fn entry {
        println $"entry to ResourceManager ${this}"
        res
    }

    fn exit( e: err|none = none) {
        println $"exit fom ResourceManager ${this} with \"${e}\" as exception"
        if e != none : // we handle the exception printing it
            println e
        res.close() // close the resource
        return true; // suppress exceptions
    }
}

class Resource {
    fn init {
        println "Creating resource"
    }
    fn printf(s,[rest]){
        println "printf was called"
        println s % rest
    }
    fn close(){
        println $"closing resource"
    }
}

with ResourceManager() as r {
    println $"r resource is ${r}"
    r.printf("executing with resource %s %s",1,2)
    die "mad dog"
}
println "did not die"
// end snippet

// snippet is_type
class A {}
class B : A {}
mut K = class : B {}
mut z = K()
println is_type(z,"A")," yes"
println is_type(z,"H")," no"
println is_type(z,"K")," no" // it is a no named class
println is_type(z,K)," yes"
println is_type(z,A)," yes"
println is_type(z,"#undefined")," yes" // bit strange, but actually
// end snippet

// snippet parents
class A {}
class B : A {}
mut K = class : B {}
println([ ..parents(K) -> type(it()) ])
// end snippet

// snippet all_parents
class A {}
class B : A {}
mut K = class : B {}
println all_parents(K)
println([ ..all_parents(K) -> type(it()) ])
// end snippet

// snippet rng
let z = rng(0,9223372036854775807)
mut i = 0
for each k in z {
  print k, " "
  i++
} until i > 5
// end snippet

// snippet rngThousand
mut z = rng(0,1000)
mut array = [ ..z ] // this creates an array of 1000 elements
println len(array)
print( [..array[0 .. 5], "...", ..array[-5 .. len(array)]])
// end snippet

// snippet objectAttachment
class B {
    fn a {
        if is_defined(this) :
            println $"hello ${this}, ${cls}  ${it}";
        else :
            println $"hello ${none}, ${cls}  ${it}";
    }
}
let b = B()
let z = [ 1,2,3 ]
let k = [ ..z with b];
let h = [ ..z with B];
b.Kukk = 2;
k.a();
println k.Kukk
println "Now with h"
h.a()
println h.Kukk

let w = k[1..3]
w.a()
// end snippet

// snippet rngRange
// a range does not store the numbers only where to start, end, and the step
mut z = rng(100,9223372036854775807,100)
// a range indexed is still only a range with a minimal memory footprint
mut range = z[20..2000000]
// the values come from the sub-range
print( [..range[0 .. 5], "...", ..range[-5 .. len(range)]])
// end snippet

// snippet rngErrs
try:
    rng(1,10,-1)
catch e1:
    println e1.message
try:
    rng(10,1,+1)
catch e2:
    println e2.message
try:
    rng(10,11,0)
catch e3:
    println e3.message

println "Special zero element range can have zero as step %s" % [rng(10,10,0)]
println "but it is just the same as %s" % [rng(10,10)]

// end snippet

// snippet range
// import the Turicum range function to get named parameters for range
sys_import turi.range

// start from zero
// also note ranges print wisely, when they are long
println range(end=10)
// all elements are printed when not more than five
println range(end=5)
println range(start=100, 200, 50)
println range(end=200, 100, 50)
// range object has one field: 'length'
println "length=",range(end=200, 100, 50).length
// you can also index a range object, it will not allocate memory
println "r[1]=",range(end=200, 100, 50)[1]
println range(100,100)
println range(100,100,step=0)
// end snippet

// snippet asyn_list
fn sleeper(x) {
    sleep 0.1
    x
    }
{
mut start = nano_time()
mut serial = [sleeper(1), sleeper(2), sleeper(3)]
mut end = nano_time()
println serial
println( (end-start)/1000000, "ms")
}
{
mut start = nano_time()
mut serial = [ ..async([sleeper(1), sleeper(2), sleeper(3)]) -> it.get() ]
mut end = nano_time()
println serial
println( (end-start)/1000000, "ms")
}
// end snippet

// snippet example_flow_squareroot
mut _sqrt = {
    flow until epsilon < 0.0001 {
        a <- 13;
        a <- {
            mut newA = (a + 13 / a) / 2;
            println("a =", newA);
            newA;
        }
        epsilon <- abs(a - (a + 13 / a) / 2);
        yield a
    }
}

println("sqrt(13) ≈ ", _sqrt);
println("sqrt(13) ≈ ", sqrt(13), " calculated by java Math");
println("square ≈ ", _sqrt * _sqrt);
// end snippet

// snippet glob1
sys_import "turi.io"

println jsonify_beauty(glob("**/test-classes/**/*.class", recursive=true))
// end snippet

// snippet glob2
sys_import "turi.io", "glob"

println jsonify_beauty(glob("*"))
// end snippet


// snippet env1
println env().JAVA_HOME
// end snippet

// snippet env2
println env("JAVA_HOME")
// end snippet

// snippet env3
println env("JAVA_*")
// end snippet

// snippet example_flow_timeout
mut result = {try {
    flow timeout 0.01 {  // 10 milliseconds
        counter <- 0;
        counter <- {
            mut n = counter + 1;
            println("counter =", n);
            sleep(0.005);  // 5 milliseconds per step
            n;
        }
        yield counter
    }
}catch e: println e}

println("Final counter = ", result);
// end snippet

// snippet example_flow_limit

mut result = {try {
               flow limit 5 {
                   x <- 1;
                   x <- {
                       mut newX = x + 1;
                       println("x =", newX);
                       newX;
                   }
                   yield x
               }
           } catch e: println e.message}

           println("Final x = ", result);
// end snippet

//  flow_mermaid_output
mut norm = command({flow test {
        a <- 3;
        b <- 4;
        a <- {
            println "update a: a=%s b=%s" % [a,b]
            if a > 10 { println("a fini"); fini } else{ a + 1 };
            }
        b <- {
            println "update b: a=%s b=%s" % [a,b]
            if b > 1 { println("b fini"); non_mutat } else{ b + 2 };
            }
        yield [a,b]
    }
})

println("graph TD;")
mut d_cells = norm.commands[0].dependentCells
for each k in keys(d_cells) {
    for each dep in d_cells[k] {
        println("    %s-->%s" % [k, dep.id])
    }
}
//

// snippet min_max
println max(3,5,8,7,4,11,-1)
println max([3,5,8,7,4,11,-1])
println min(3,5,8,7,4,11,-1)
println min([3,5,8,7,4,11,-1])

println max( "giraffe", "zibra", "elephant" )
println min( "affe", "zibra", "elephant" )

class Complex {
    fn init( real:float|num, imaginary:float|num ){
        pin real
        pin imaginary
    }
    fn `<`(other:Complex):bool = real*real + imaginary*imaginary < (with other: real*real + imaginary*imaginary);
    fn to_string()= $"${real}+i${imaginary}"
}

println min( Complex(1,1), Complex(3,2), Complex(0.5,1.7))
println max( Complex(1,1), Complex(3,2), Complex(0.5,1.7))

try: max( Complex(1,1), "Donald")
catch e: println e
// end snippet

// snippet thunk_unthunk
// thunk is a macro, gets the block before it evaluates, and it does not evaluate it
mut z = thunk({mut x = 3; println "hello"})
println "before eval"
// unthunking will evaluate the block, as a block
unthunk(z)
println "after eval"
// 'x' was defined as a mutable variable inside the block, so here it is undefined
println is_defined(x) // will print false
// this will evaluate the block unwrapped
unthunk(unwrap(z))
// the block was unwrapped, so 'x' is defined in this context
println is_defined(x) // will print true and
println x             // then the value
// end snippet

// snippet as_object
let z = thunk({let k = 5})
println as_object(z)
// end snippet

// snippet nano_time
println nano_time()
// end snippet

// snippet block_list
mut commands = block_list(thunk({k = 13; suss = "huss"; mut x = 3; println "hello"}))
println "before execution"
mut i = 1;
for each command in commands {
    mut suss;
    println "%s. before is_defined(x) = %s" % [i,is_defined(x)]
    if i == 1 {
        try: unthunk(command) catch e: println "ERROR: %s" % [e];
    } else {
        unthunk(command)
        println "%s. after is_defined(x) = %s" % [i,is_defined(x)]
    }
    i++
}
// end snippet

// snippet while_result
println {
    mut k = 0
    while k < 10 : k++
}
// end snippet
// snippet for_result
println {
    mut k = 0
    for ; k < 10 ; : k++
}
// end snippet

// snippet for_each_result
println {
    for each t with i in [1,2,3] : t + 10*i
}
// end snippet

// snippet for_list
println {for i=0; i < 10 ; i++ list: i}
// end snippet

// snippet for_each_list
println {
    for each z with i in [1,2,3] list { 10*i + z }
    }
// end snippet

// snippet while_list
mut k = 0;
println{ while k < 5 list{
            mut h = k;
            k++;
            h
         }
}
// end snippet


// snippet break1
println {
    for i=0 ; i < 10 ; i++ {
      println ".. ",i;
      break if i == 2
    }
}
// end snippet

// snippet break2
println {
    for i=0 ; i < 10 ; i++ {
      println ".. ",i;
      break -2 if i == 2
    }
}
// end snippet

// snippet break3
println {
    for i=0 ; i < 10 ; i++ list{
      break if i == 2
      i;
    }
}
// end snippet

// snippet break4
println {
    for i=0 ; i < 10 ; i++ list{
      break -2 if i == 2
      i;
    }
}
// end snippet

// snippet break5
println {
    for i=0 ; i < 10 ; i++ list{
      break none if i == 2
      i;
    }
}
// end snippet

// snippet break6
println {
    for i=0 ; i < 4 ; i++ {
      if i == 2 : break;
      println i;
    }
}
println "however"
println {
    for i=0 ; i < 4 ; i++ {
      if i == 2 { break };
      println i;
    }
}
// end snippet

// snippet incremento
mut k = 3;
let z = k++; // valid it is only a variable
let w = ++k; // valid, it is only a variable

let x = [1,2,3]
x[0]++; // valid, it is a statement
// let h = x[0]++; it would not compile
let h = (x[0]++); // valid, there is a command between ( and )
// let t = ++x[0]; it would not compile
let t = (++x[0]); // valid again, enclosed
// end snippet

// snippet incrementable1
class Incrementable {
    fn init(counter:num=0);

    fn `++`{
         Incrementable(counter+1)
    }

    fn p(name:str) {
        println name,": ",counter;
    }
}

mut h = Incrementable();
h.p("h original");
println "h id=%X" % id_hash(h);
let k = h++;
h.p("h after post increment");
k.p("k");
println "h id=%X" % id_hash(h);
println "k id=%X" % id_hash(k);
let z = ++h;
h.p("h after pre increment");
z.p("z")
println "h id=%X" % id_hash(h);
println "z id=%X" % id_hash(z);
// end snippet

// snippet incrementable2
class Incrementable {
    fn init(counter:num=0);

    fn `++`{
         counter++
         this
    }

    fn p(name:str) {
        println name,": ",counter;
    }
}

mut h = Incrementable();
h.p("h original");
println "h id=%X" % id_hash(h);
let k = h++;
h.p("h after post increment");
k.p("k");
println "h id=%X" % id_hash(h);
println "k id=%X" % id_hash(k);
let z = ++h;
h.p("h after pre increment");
z.p("z")
println "h id=%X" % id_hash(h);
println "z id=%X" % id_hash(z);
// end snippet

// snippet decrementable1
class Decrementable {
    fn init(counter:num=0);

    fn `--`{
         Decrementable(counter-1)
    }

    fn p(name:str) {
        println name,": ",counter;
    }
}

mut h = Decrementable();
h.p("h original");
println "h id=%X" % id_hash(h);
let k = h--;
h.p("h after post decrement");
k.p("k");
println "h id=%X" % id_hash(h);
println "k id=%X" % id_hash(k);
let z = --h;
h.p("h after pre decrement");
z.p("z")
println "h id=%X" % id_hash(h);
println "z id=%X" % id_hash(z);
// end snippet

// snippet decrementable2
class Decrementable {
    fn init(counter:num=0);

    fn `--`{
         counter--
         this
    }

    fn p(name:str) {
        println name,": ",counter;
    }
}

mut h = Decrementable();
h.p("h original");
println "h id=%X" % id_hash(h);
let k = h--;
h.p("h after post decrement");
k.p("k");
println "h id=%X" % id_hash(h);
println "k id=%X" % id_hash(k);
let z = --h;
h.p("h after pre decrement");
z.p("z")
println "h id=%X" % id_hash(h);
println "z id=%X" % id_hash(z);
// end snippet

// snippet break7
println {
    for i=0 ; i < 4 ; i++ {
      break (if i == 2 : 3 else : 4) if i == 2;
      println i;
    }
}
// end snippet

// snippet return1
fn a(x) {
    if x == 2 {
        return 2
    }
    return
}
println a(1)
println a(2)
println a(3)
// end snippet


// snippet continue1
sys_import "turi.range"

for each i in range(start=0, end=5) list{
    println i
}
// end snippet

// snippet math_functions
println "Testing math functions:"
println "sin(1) = ", sin(1)
println "cos(1) = ", cos(1) 
println "acos(0.5) = ", acos(0.5)
println "asin(0.5) = ", asin(0.5)
println "atan(1) = ", atan(1)
println "atan2(1,1) = ", atan2(1,1)
println "cbrt(27) = ", cbrt(27)
println "ceil(3.2) = ", ceil(3.2)
println "abs(-3) = ", abs(-3)
println "exp(1) = ", exp(1)
println "floor(3.8) = ", floor(3.8)
println "log(2.718281828459045) = ", log(2.718281828459045)
println "log10(100) = ", log10(100)
println "sqrt(16) = ", sqrt(16)
println "tan(1) = ", tan(1)
println "tanh(1) = ", tanh(1)
println "sinh(1) = ", sinh(1)
println "cosh(1) = ", cosh(1)
println "to_degrees(3.14159) = ", to_degrees(3.14159)
println "to_radians(180) = ", to_radians(180)
println "pow(3,3) =", pow(3,3)
println "copy_sign(3.5,-2.1) = ", copy_sign(3.5,-2.1)
println "get_exponent(123.456) = ", get_exponent(123.456)
println "hypot(3,4) = ", hypot(3,4)
println "ieee_remainder(5,2) = ", ieee_remainder(5,2)
println "next_after(1.0,2.0) = ", next_after(1.0,2.0)
println "next_down(1.0) = ", next_down(1.0)
println "next_up(1.0) = ", next_up(1.0)
println "rint(3.7) = ", rint(3.7)
println "round(3.7) = ", round(3.7)
println "signum(-3.7) = ", signum(-3.7)
println "ulp(1.0) = ", ulp(1.0)
println "scalb(2.0,3) = ", scalb(2.0,3)
// end snippet

// snippet assign_calculate
mut z = 3
println "z=",z
z += 1;
println "z +=1 :",z
z -= 1;
println "z -=1 :",z
z *= 4;
println "z *=4 :",z
z /= 2;
println "z /=2 :",z
z %= 5;
println "z %=5 :",z
z |=128;
println "z |=128 :",z
z &= 7;
println "z &=0x7F :",z
z ^= 0xFF;
println "z ^=0xFF :",z
z **= 2;
println "z **=2 :",z
z or= inf;
println "z or=inf :",z
z <<= 2
println "z <<=2 :",z
z >>=2
println "z >>=2 :",z
z >>>=2
println "z >>>=2 :",z
z >>>=2
println "z >>>=2 :",z
z >>>=2
println "z >>>=2 :",z
z >>>=2
println "z >>>=2 :",z
z >>>=2
println "z >>>=2 :",z
z >>>=2
println "z >>>=2 :",z
z >>>=2
println "z >>>=2 :",z
z >>>=2
println "z >>>=2 :",z

mut b = true
println "b=",b
b &&= false;
println "b &&=false :",b
b ||= true;
println "b ||=true :",b
// end snippet

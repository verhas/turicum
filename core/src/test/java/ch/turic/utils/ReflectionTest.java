package ch.turic.utils;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import java.lang.reflect.Method;
import java.util.List;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

class ReflectionTest {

    // Test interfaces for accessibility scenarios
    public interface PublicInterface {
        void publicInterfaceMethod();

        default void defaultMethod() {
        }
    }

    private interface PrivateInterface {
        void privateInterfaceMethod();
    }

    // Test classes for various scenarios
    public static class PublicTestClass implements PublicInterface {
        public void publicMethod() {
        }

        protected void protectedMethod() {
        }

        private void privateMethod() {
        }

        void packagePrivateMethod() {
        }

        public void methodWithPrimitives(int i, boolean b, char c) {
        }

        public void methodWithWrappers(Integer i, Boolean b, Character c) {
        }

        public void methodWithObjects(String s, Object o) {
        }

        public void varargMethod(String... args) {
        }

        public void mixedVarargMethod(int fixed, String... args) {
        }

        @Override
        public void publicInterfaceMethod() {
        }

        // Synthetic method will be generated by compiler for bridge methods in some cases
        public void overloadedMethod(String s) {
        }

        public void overloadedMethod(Object o) {
        }
    }

    private static class PrivateTestClass implements PublicInterface, PrivateInterface {
        public void publicMethod() {
        }

        private void privateMethod() {
        }

        @Override
        public void publicInterfaceMethod() {
        }

        @Override
        public void privateInterfaceMethod() {
        }
    }

    // Inner class to test accessibility issues
    class InnerTestClass implements PublicInterface {
        private void privateInnerMethod() {
        }

        @Override
        public void publicInterfaceMethod() {
        }
    }

    // Local class factory for testing
    private Object createLocalClass() {
        class LocalTestClass implements PublicInterface {
            private void localPrivateMethod() {
            }

            @Override
            public void publicInterfaceMethod() {
            }
        }
        return new LocalTestClass();
    }

    @Nested
    @DisplayName("getMethod() basic functionality tests")
    class GetMethodBasicTests {

        @Test
        @DisplayName("Should find public method")
        void shouldFindPublicMethod() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "publicMethod", new Class<?>[0]);

            assertNotNull(method);
            assertEquals("publicMethod", method.getName());
            assertTrue(method.canAccess(obj));
        }

        @Test
        @DisplayName("Should find protected method")
        void shouldFindProtectedMethod() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "protectedMethod", new Class<?>[0]);

            assertNotNull(method);
            assertEquals("protectedMethod", method.getName());
        }

        @Test
        @DisplayName("Should find private method")
        void shouldFindPrivateMethod() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "privateMethod", new Class<?>[0]);

            assertNotNull(method);
            assertEquals("privateMethod", method.getName());
        }

        @Test
        @DisplayName("Should find package private method")
        void shouldFindPackagePrivateMethod() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "packagePrivateMethod", new Class<?>[0]);

            assertNotNull(method);
            assertEquals("packagePrivateMethod", method.getName());
        }

        @Test
        @DisplayName("Should return null for non-existent method")
        void shouldReturnNullForNonExistentMethod() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "nonExistentMethod", new Class<?>[0]);

            assertNull(method);
        }
    }

    @Nested
    @DisplayName("getMethod() interface accessibility tests")
    class InterfaceAccessibilityTests {

        @Test
        @DisplayName("Should find method from public interface when class method is accessible")
        void shouldFindMethodFromPublicInterface() {
            PrivateTestClass obj = new PrivateTestClass();
            Method method = Reflection.getMethod(obj, "publicInterfaceMethod", new Class<?>[0]);

            assertNotNull(method);
            assertEquals("publicInterfaceMethod", method.getName());
            assertTrue(method.canAccess(obj));
        }

        @Test
        @DisplayName("Should find method from public interface when class method is not accessible")
        void shouldFindMethodFromInterfaceForInaccessibleMethod() {
            final var sut = java.util.Arrays.asList("apple", "banana", "cherry");

            // This won't be accessible from the implementation only from the interface 'List'
            Method method = Reflection.getMethod(sut, "size", new Class<?>[0]);

            assertNotNull(method);
            assertEquals("size", method.getName());
            assertTrue(method.canAccess(sut));
        }

        @Test
        @DisplayName("Should handle private interface method")
        void shouldHandlePrivateInterfaceMethod() {
            PrivateTestClass obj = new PrivateTestClass();
            Method method = Reflection.getMethod(obj, "privateInterfaceMethod", new Class<?>[0]);

            // This may return null if the private interface method is not accessible
            // The exact behavior depends on JVM module system restrictions
            if (method != null) {
                assertEquals("privateInterfaceMethod", method.getName());
            }
        }

        @Test
        @DisplayName("Should find default interface method")
        void shouldFindDefaultInterfaceMethod() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "defaultMethod", new Class<?>[0]);

            assertNotNull(method);
            assertEquals("defaultMethod", method.getName());
            assertTrue(method.canAccess(obj));
        }
    }

    @Nested
    @DisplayName("JDK API accessibility tests")
    class JdkApiAccessibilityTests {

        @Test
        @DisplayName("Should handle List interface methods")
        void shouldHandleListInterfaceMethods() {
            List<String> list = List.of("test");
            Method method = Reflection.getMethod(list, "size", new Class<?>[0]);

            assertNotNull(method);
            assertEquals("size", method.getName());
            assertTrue(method.canAccess(list));
        }

        @Test
        @DisplayName("Should find Object methods on any object")
        void shouldFindObjectMethods() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "toString", new Class<?>[0]);

            assertNotNull(method);
            assertEquals("toString", method.getName());
            assertTrue(method.canAccess(obj));
        }

        @Test
        @DisplayName("Should handle String methods")
        void shouldHandleStringMethods() {
            String str = "test";
            Method method = Reflection.getMethod(str, "length", new Class<?>[0]);

            assertNotNull(method);
            assertEquals("length", method.getName());
            assertTrue(method.canAccess(str));
        }
    }

    @Nested
    @DisplayName("Parameter type matching tests")
    class ParameterTypeMatchingTests {

        @Test
        @DisplayName("Should match exact parameter types")
        void shouldMatchExactParameterTypes() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "methodWithPrimitives",
                    new Class<?>[]{int.class, boolean.class, char.class});

            assertNotNull(method);
            assertEquals("methodWithPrimitives", method.getName());
        }

        @Test
        @DisplayName("Should match wrapper types to primitives")
        void shouldMatchWrapperTypesToPrimitives() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "methodWithPrimitives",
                    new Class<?>[]{Integer.class, Boolean.class, Character.class});

            assertNotNull(method);
            assertEquals("methodWithPrimitives", method.getName());
        }

        @Test
        @DisplayName("Should match primitives to wrapper parameters")
        void shouldMatchPrimitivesToWrapperParameters() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "methodWithWrappers",
                    new Class<?>[]{int.class, boolean.class, char.class});

            assertNotNull(method);
            assertEquals("methodWithWrappers", method.getName());
        }

        @Test
        @DisplayName("Should handle Object parameter with String argument")
        void shouldHandleObjectParameterWithStringArgument() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "methodWithObjects",
                    new Class<?>[]{String.class, String.class});

            assertNotNull(method);
            assertEquals("methodWithObjects", method.getName());
        }
    }

    @Nested
    @DisplayName("Vararg method tests")
    class VarargMethodTests {

        @Test
        @DisplayName("Should match vararg method with no vararg arguments")
        void shouldMatchVarargMethodWithNoVarargArguments() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "varargMethod", new Class<?>[0]);

            assertNotNull(method);
            assertEquals("varargMethod", method.getName());
            assertTrue(method.isVarArgs());
        }

        @Test
        @DisplayName("Should match vararg method with vararg arguments")
        void shouldMatchVarargMethodWithVarargArguments() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "varargMethod",
                    new Class<?>[]{String.class, String.class});

            assertNotNull(method);
            assertEquals("varargMethod", method.getName());
            assertTrue(method.isVarArgs());
        }

        @Test
        @DisplayName("Should match mixed vararg method")
        void shouldMatchMixedVarargMethod() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "mixedVarargMethod",
                    new Class<?>[]{int.class, String.class, String.class});

            assertNotNull(method);
            assertEquals("mixedVarargMethod", method.getName());
            assertTrue(method.isVarArgs());
        }

        @Test
        @DisplayName("Should not match mixed vararg method vararg mismatch")
        void shouldNotMatchMixedVarargMethod() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "mixedVarargMethod",
                    new Class<?>[]{int.class, String.class, StringBuffer.class});

            assertNull(method);
        }

        @Test
        @DisplayName("Should not match mixed vararg method vararg mismatch")
        void shouldNotMatchMixedVarargMethodFixedMismatch() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "mixedVarargMethod",
                    new Class<?>[]{String.class, String.class, String.class});

            assertNull(method);
        }

        @Test
        @DisplayName("Should match mixed vararg method with only fixed parameter")
        void shouldMatchMixedVarargMethodWithOnlyFixedParameter() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "mixedVarargMethod",
                    new Class<?>[]{int.class});

            assertNotNull(method);
            assertEquals("mixedVarargMethod", method.getName());
            assertTrue(method.isVarArgs());
        }
    }

    @Nested
    @DisplayName("Null parameter validation tests")
    class NullParameterValidationTests {

        @Test
        @DisplayName("Should throw NPE for null object")
        void shouldThrowNPEForNullObject() {
            assertThrows(NullPointerException.class,
                    () -> Reflection.getMethod(null, "method", new Class<?>[0]));
        }

        @Test
        @DisplayName("Should throw NPE for null method name")
        void shouldThrowNPEForNullMethodName() {
            PublicTestClass obj = new PublicTestClass();
            assertThrows(NullPointerException.class,
                    () -> Reflection.getMethod(obj, null, new Class<?>[0]));
        }

        @Test
        @DisplayName("Should throw NPE for null args array")
        void shouldThrowNPEForNullArgsArray() {
            PublicTestClass obj = new PublicTestClass();
            assertThrows(NullPointerException.class,
                    () -> Reflection.getMethod(obj, "method", null));
        }
    }

    @Nested
    @DisplayName("Edge cases and special scenarios")
    class EdgeCasesTests {

        @Test
        @DisplayName("Should handle inner class methods")
        void shouldHandleInnerClassMethods() {
            InnerTestClass obj = new InnerTestClass();
            Method method = Reflection.getMethod(obj, "publicInterfaceMethod", new Class<?>[0]);

            assertNotNull(method);
            assertEquals("publicInterfaceMethod", method.getName());
        }

        @Test
        @DisplayName("Should handle local class methods")
        void shouldHandleLocalClassMethods() {
            Object obj = createLocalClass();
            Method method = Reflection.getMethod(obj, "publicInterfaceMethod", new Class<?>[0]);

            assertNotNull(method);
            assertEquals("publicInterfaceMethod", method.getName());
        }

        @Test
        @DisplayName("Should handle overloaded methods")
        void shouldHandleOverloadedMethods() {
            PublicTestClass obj = new PublicTestClass();

            Method stringMethod = Reflection.getMethod(obj, "overloadedMethod", new Class<?>[]{String.class});
            Method objectMethod = Reflection.getMethod(obj, "overloadedMethod", new Class<?>[]{Object.class});

            assertNotNull(stringMethod);
            assertNotNull(objectMethod);
            assertNotEquals(stringMethod, objectMethod);
        }

        @Test
        @DisplayName("Should exclude synthetic methods")
        void shouldExcludeSyntheticMethods() {
            PublicTestClass obj = new PublicTestClass();

            // Try to find all methods and ensure no synthetic methods are returned
            Method[] allMethods = obj.getClass().getDeclaredMethods();
            for (Method method : allMethods) {
                if (method.isSynthetic()) {
                    Method found = Reflection.getMethod(obj, method.getName(), method.getParameterTypes());
                    // If found is not null, it should not be the synthetic method
                    if (found != null) {
                        assertFalse(found.isSynthetic());
                    }
                }
            }
        }

        @Test
        @DisplayName("Should handle empty parameter arrays")
        void shouldHandleEmptyParameterArrays() {
            PublicTestClass obj = new PublicTestClass();
            Method method = Reflection.getMethod(obj, "publicMethod", new Class<?>[0]);

            assertNotNull(method);
            assertEquals("publicMethod", method.getName());
            assertEquals(0, method.getParameterCount());
        }
    }
}
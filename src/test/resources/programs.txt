// snippet EmptyBlockIsObject
// null
let a = {}
a.field

// snippet singleLineComments
// null
null // is undefined so it is null in the Java world

// snippet noneSymbol
// null
∅

// snippet multiLineComment
// null
/*
 * A variable that is not defined is null, and it is like that in the Java caller
 */
null

// snippet multiLineNestedComment
// null
/*
 * A variable that is not defined is null, and it is like that in the Java caller
 *  /* comments can also be nested inside of each other */
 */
null

// snippet sample1
// Long
// "42"
1 + 41

// snippet sample2
// Long
// "42"
1 + 41

// snippet basicCommands
// Long
// 60
let h = []
h[3].b = []
h[3].b[2] = 5
let z = h[3].b[2]
let a = {}
a.x = 10; let c = 30; let b = []; b[c] = 20; a.x + b[30] + c

//
// Each snippet entry is formatted as follows:
//
// // snippet <snippetName>
// // <expected class>
// // "<expected value>"
// <program code...>
//

// snippet testArithmeticOperations
// Long
// "0"
let x = 100;
let y = 50;
let z = x - y * 2;
z;

// snippet testFieldAccess
// String
// "suss84"
let arr =  {}
, z = {}
arr.h = 42;
z["field"] = "suss"
z.field + ({arr}.h + arr["h"]);


// snippet testArrayAccess
// String
// "suss84"
let arr = []
arr[3] = 42;
let z = {}
z["field"] = "suss"
z.field + {arr}[3] * 2;

// snippet testNestedArrayAccess
// Long
// "84"
let arr = []
arr[3][2] = 42;
arr[3][2] * 2;

// snippet testMultipleAssignments
// Long
// "17"
let obj = {}
obj.a = 5;
obj.b = obj.a * 3;
let arr = []
arr[1] = obj.b + 2;
arr[1];

// snippet testComplexExpressions
// Long
// "30"
let x = {}
x.val = 10;
let y = []
y[{7}] = 5;
let z = 2;
let result = (x.val + y[7]) * z;
result;

// snippet testFloatingPointOperations
// Double
// "18.3125"
let x = 10.5;
let y = 3.25;
let z = x * y + 2.5;
z / 2;

// snippet testIfStatement1
// Long
// "20"
let x = 10;
let result = {
    if x > 5 {
        result = x * 2;
    } else {
        result = x / 2;
    }
}
result;

// snippet testIfStatement2
// Double
// "1.5"
let x = 3;
let result = {if x > 5 {
    x * 2;
} else {
    x / 2;
}}
result;

// snippet testExportAssignment1
// String
// "ok"
let x = 10;
{ let z = 1 }
{ if z {"not ok"} else {"ok"} }

// snippet testExportAssignment2
// Long
// "20"
let x = 10;
let z = 7;
{ z = 2 }
x * z;

// snippet testExportAssignment3
// Long
// "20"
let x = 10;
let z = 7;
{{{{{{ z = 2 }}}}}}
x * z;

// snippet testGlobalDeclaration
// Long
// "5"
let x = 10;
let z = 7;
let h = 6;
{ global x,z,h }
5;

// snippet testFunctionDeclaration
// null
fn function x2, z, h {
} null; //anything undefined is null

// snippet testFinalDeclaration1
// Long
// "2"
let a=1, b=2;
pin a, b;
a*b;

// snippet testFinalDeclaration2
// Exception
// ""
final a=1, b=2;
let a = 3;

// snippet NoEmptyParentList
// Exception
// ""
class z : {
}


// snippet testQuotedIdentifier1
// Long
// "2"
let `a`=1, `pin`=2
pin `a`, `pin`;
a*`pin`;

// snippet testQuotedIdentifier2
// Long
// "2"
let a=1, `this is a\\nmulti-line identifier`=2;
pin a, `this is a\\nmulti-line identifier`;
a *`this is a\\nmulti-line identifier`;

// snippet testCallingFunction1
// Long
// "3"
fn f a,b,c {
    a + b + c
}
f(1,1,1);

// snippet testCallingFunction2
// Long
// "3"
let f = fn(a,b,c) {
    a + b + c
}
f(1,1,1);

// snippet testCallingFunction3
// Long
// "3"
let f = {}
f.k = fn z(a,b,c) {
    a + b + c
}
f.k(1,1,1);

// snippet testClassDeclaration
// String
// "it works12"
class meClass {
    global some = "it works";
    let other = "local";
    fn a {1}
    fn b {2}
}
global some = "it works";
some + meClass.a() + meClass.b();

// snippet testClassInstanceCreation
// Long
// "3"
class meClass {
    fn a {1}
    fn b {2}
}
let object = meClass();
object.a() + object.b();

// snippet testClassInheritance
// Long
// "3"
class Parent {
    fn a {1}
}
class meClass : Parent {
    fn b {2}
}
let object = meClass();
object.a() + object.b();

// snippet testMultipleInheritance
// String
// "1234"
class P1 {
 fn p1 {1}
}
class P2 : P1 {
 fn p2 {2}
}
class P3 {
    fn p3 {3}
}
class P4 : P3, P2 {
    fn p4 {4}
}
let object = P4();
"" + object.p1() + object.p2() + object.p3() + object.p4();

// snippet testinitInheritance
// String
// "1234"
class P1 {
 fn p1 {this.a}
}
class P2 : P1 {
 fn p2 {b}
}
class P3 {
    fn p3 {this.c}
}
class P4 : P3, P2 {
    fn init(a,b,c){}
    fn p4 {
        a =4;
        p1()
    }
}
let object = P4(1,2,3);
"" + object.p1() + object.p2() + object.p3() + object.p4();

// snippet testMethodInheritance
// Long
// "1"
class Parent {
 fn parent {1}
}
class Child : Parent {
 fn child { parent() }
}
let child = Child();
child.child();

// snippet testThisIsFinal
// Exception
// ""
class Class {
 fn fun {
   this = 55
  }
}
`class` = Class();
`class`.fun();

// snippet testPipeOperator1
// Long
// "1"
let a = 1
let b = a or 2

// snippet testPipeOperator2
// Long
// "2"
let a = 1
let b = c
or 2

// snippet testClassExtension
// Long
// "3"
class Class {}
Class.z = fn () {
  3
}
Class().z();

// snippet classDefinedWithAssignment
// String
// "csaka haha fogorvos hihi segithet huhu"
global msg = ""
let PrinterClass = class {
  let print = fn (message){
    global msg;
    msg = msg + message
    }
}
pin PrinterClass
let p = PrinterClass()
p.print("csaka haha ")
p.print("fogorvos hihi ")
p.print("segithet huhu")

// snippet ifNoBlock
// Long
// "1"
if 1: 1 else: 2

// snippet constantTrue
// Exception
// ""
let true = 0

// snippet constantFalse
// Exception
// ""
let false = 0

// snippet constantNone
// Exception
// ""
let none = 0

// snippet looping1
// Long
// 10
/*
 while loop condition and body is executed in a local loop environment
*/
let i = 1
while i < 10 : i = i + 1

// snippet looping2
// Long
// 10
let i = 1
let z
while i < 10 { i = i + 1;
  z = i}
z

// snippet looping3
// Long
// 10
global i = 1
fn inci {
  global i
  i =  i + 1
}
let z
while i < 10 : z = inci()
z

// snippet looping4
// Long
// 10
/*

here we define a function that increments the loop variable, which is a global variable.
Even the loop body is not enclosed between '{' and '}' it is executed in a new local environment

 */
global i = 1
fn inci {
  global i
  i =  i + 1
}
global z = 0
while i < 10 : global z = inci()
z

// snippet looping5
// Long
// 9
let i = 1
while i < 10 { i = i + 1 } until i == 9;;;;

// snippet looping6
// Long
// 9
let i = 1
while( i < 10 )  i = i + 1 ; until i == 9;;;;

// snippet forLoop1
// Long
// 9
let z = 0
for i=1 ; i<10 ; i=i+1 : z=i
z

// snippet forLoop2
// Long
// 9
let z = 0
for let i=1 ; i<10 ; i=i+1 : z=i
z

// snippet forLoop3
// Long
// 9
let z = 0
for( i=1 ; i<10 ; i=i+1 ): z=i
z

// snippet forLoop5
// Long
// 8
let z = 0
for i=1 ; i<10 ; i=i+1 : z=i until i == 8
z

// snippet forLoop6
// Long
// 9
let z = 0
for (i=1 ; i<10 ; i=i+1 )  z=i
z

// snippet forLoop7
// String
// 1234567890
let i = 0
let msg : str = ""
// the loop variable is local for the loop and
// you do not explicitly write it to be 'let i ='...
for i=1 ; i<10 ; i=i+1 :  msg = msg + i
msg + i

// snippet forLoop8
// String
// 1234567890
let i = 0
let msg : str = ""
// the loop variable is local for the loop and
// you can explicitly write it to be 'let i ='... even with a type
for let i : num =1 ; i<10 ; i=i+1 :  msg = msg + i
msg + i

// snippet forLoop9
// String
// 1234567890
let i = 0
let msg : str = ""
// the loop variable is local for the loop and
// you can explicitly write it to be 'let i ='... even with a type
for let i : float  =1 ; i<10 ; i=i+1 :  msg = msg + i
msg + i

// snippet forLoop10
// String
// 12345678910
let i = 0
let msg : str = ""
// the loop variable is inherited in this case
for {i=1} ; i<10 ; i=i+1 :  msg = msg + i
msg + i

// snippet closure1
// Long
// 3
let z = {| a,b,c | a+1 } ; z(2,3,4)

// snippet closure2
// Long
// 3
{| a,b,c | a+1 }(2,3,4)

// snippet closure3
// Long
// 3
let z = {| a,b,c | a+1 } ; z(2,3,4)

// snippet boost
// Long
// 2
+{fn map(x) {
  x * 2
}}(1)
//burst b = 0 ; { for i = 1 ; i < 3 ; i++ : yield i } → map → {|a| a * 2} →  {|a| b = b + a }

// snippet range
// Range
// "13..2"
13..2

// snippet listLiteral1
// Long
// 1
[1,2,3][0]

// snippet listLiteral2
// Long
// 2
[1..3][1]

// snippet listLiteral3
// Long
// 2
let a = [1..3];
[..a,7][1]

// snippet forEachLoop1
// Long
// 6
let a = [1..4];
let k = 0;
for each z in a : k = k + z


// snippet pinExample
// String
// "3 7 7 7"
"""
pin signals that a variable cannot be modified any more in the given scope.
It does not prevent code in enclosing scopes.
It also does not prevent any inner/enclosed scopes to use the variable as modifiable, however any modification will
be local to that level.
"""
let i = 3; pin i; let j = 3, s = 5, k = 0;
{
   s = s + 1;
   pin s;
   // you cannot do that, if 'i' is local then it is local
   // you cannot eat your cake and have it, not even if you are the UB
   // let i = i + 4;
   k= i + 4
   j = j + 4;
}
s = s + 1;
""+i+" "+k+" "+j+" "+s
// fn reducer(acc,item)= acc+item
// { burst init_expression ; generator_expression ? filter → map ? filter ... >>= reducer with unit=expression}

// snippet minusOperatorSample
// Long
// 3
class A {
  fn init(zumba){}
  fn `+`(right) {
     if( right != null ) {
          A(this.zumba + right.zumba)
     } else {
          this
     }
  }
  let `-` = macro({|right|
         if( right ≠ null ) {
              A(this.zumba - evaluate(right).zumba)
         } else {
              A(-this.zumba)
         }
     })
}
let a = -A(1);
let b = A(2);
(b-a).zumba

// snippet initAsFactory
// String
// "Y says: csaka haha fogorvos hihi segithet huhu"
class PrinterClass{
  fn init {
    this.msg = ""
  }
  let print = fn (message){
    this.msg = this.msg + message
    }
}

class z{
    fn init {
      this = PrinterClass();
      this.msg = "Z says: "
    }
}
class y : PrinterClass {
    fn init {
      this.msg = "Y says: "
    }
}

let p = PrinterClass()
p.print("csaka haha ")
p.print("fogorvos hihi ")
p.print("segithet huhu\n")
z = z()
z.print("csaka haha ")
z.print("fogorvos hihi ")
z.print("segithet huhu\n")
y = y()
y.print("csaka haha ")
y.print("fogorvos hihi ")
y.print("segithet huhu")


// snippet stringIndexing1
// String
// "zebra"
let string = "zabraa"
string[1] = "e"
string[0..-1]

// snippet StringIndexing2
// String
// 17754
let MESSAGE = "1234"
// you can replace part of the string in an assignment
// it can be longer than the part replaces, can be shorter, even empty
MESSAGE[1..3] = 775
MESSAGE

// snippet StringIndexing3
// String
// 13
let X = {}
X.MESSAGE = "1234"
X.MESSAGE[1..3] = 32
X.MESSAGE[-∞..2] // bad luck

// snippet reclosingClosure
// String
// "55 77 63 63 99 77"
let MESSAGE = ""
let z = 55;
let y = 77;
let x = {|| MESSAGE = MESSAGE + z + " "
        z = y;
    };
x(); // 55, z <- 77
{
  let z = 63;
  x(); // 77
  MESSAGE = MESSAGE + z + " " // 77
  y = 99;
  reclose(x)(); // 63
  MESSAGE = MESSAGE + z + " " // 99
}
MESSAGE = MESSAGE + z + " " // 77
MESSAGE = MESSAGE[0…-1]

// snippet catchingException
// String
// "It is not possible to invoke 'nonexistent' because its value is 'null' and not something I can invoke.It is a f5g null"
let MESSAGE = ""
try {
  let h = nonexistent()
}catch exception {
  MESSAGE = exception.message
}
MESSAGE

// snippet DeclareType
// String
// "alma ata"

let a : any|str = "alma ata"

// snippet badType
// String
// "Cannot set variable 'a' to value '13' as it does not fit any of the accepted type of the variable (str)"
let ex;
try {
    let a: str = 13
    }catch exception: ex = exception
"" + ex

// snippet fnPositionalOnly
// null
fn f(!a, !b, !c) { }
none

// snippet fnPositionalAndOptional
// null
fn f(a, b = 2, c = 3) { }
none

// snippet fnNamedOnly
// null
fn f(@a = 1, @b = 2) { }
none

// snippet fnMixedParams
// null
fn f(!a, b, c = 3, @d = 4) { }
none

// snippet fnWithRestParam
// null
fn f(a, [args]) { }
none

// snippet fnWithMetaParam
// null
fn f(a, {kwargs}) { }
none

// snippet fnWithClosureParam
// null
fn f(a, ^block) { }
none

// snippet fnWithAllParamKinds
// null
fn f(!a, b = 2, @x = 3, [rest], {meta}, ^closure) { }
none

// snippet fnClosureOnly
// null
fn f(^callback) { }
none

// snippet fnRestBeforeMeta
// Exception
// ""
fn f({meta}, [rest]) { }

// snippet fnMetaBeforeClosure
// null
fn f(@a = 1, {meta}, ^block) { }
none

// snippet fnClosureNotLast
// Exception
// ""
fn f(^block, a) { }

// snippet fnDuplicateParamNames
// Exception
// ""
fn f(a, a) { }

// snippet fnDuplicateRestMetaClosure
// Exception
// ""
fn f([x], [x]) { }

// snippet closureWithNamedOnly
// null
let f = {| @x=1, @y=(2|3) | }
none

// snippet closureWithAllParamKinds
// null
let f = {| !a, b = 2, @x = 3, [rest], {meta}, ^block| }
none

// snippet closureRestAfterClosure
// Exception
// ""
let f = {| a, ^block, [rest] | }

// snippet namedArguments1
// String
// "12"
fn fun(@a:str, @b=2){
  a + b
}
fun(a="1")

// snippet namedArguments2
// String
// "13"
fn fun(@a:str, @b=2){
  a + b
}
fun(a="1",b=3)

// snippet namedArguments3
// String
// "13"
fn fun(@a:str, {meta}){
  a + meta["b"]
}
fun(a="1",b=3)

// snippet namedArguments4
// String
// "1345"
fn fun(@a:str, [rest]){
  a + rest[0] + rest[1]
}
fun(a="1",3, 45)

// snippet namedArguments5
// String
// "1345ka"
fn fun(@a:str, [rest],{meta}){
  a + rest[0] + rest[1] + meta.b
}
fun(a="1",3, 45, b="ka")

// snippet namedArguments6
// String
// "ka4531"
fn fun(@a:str, [rest],{meta},^closurea){
  closurea(a , rest[0] , rest[1] , meta.b)
}
fun(a="1",3, 45, b="ka",{|a,b,c,d| ""+ d + c + b + a })

// snippet closureArgument1
// String
// "ka4531"
fn fun(@a:str, [rest],{meta},^closurea){
  closurea(a , rest[0] , rest[1] , meta.b)
}
fun(a="1",3, 45, b="ka"){|a,b,c,d| ""+ d + c + b + a }

// snippet closureArgument2
// String
// "ka453345ka"
fn fun(@a:bool, [rest],{meta},^closurea){
  if a :
    closurea(a , rest[0] , rest[1] , meta.b)
  else:
    ""+rest[0] + rest[1] + meta.b
}
let x = fun(a=true,3, 45, b="ka"){|a,b,c,d| ""+ d + c + b }
let klos = {|a,b,c,d| ""+ d + c + b }
let y = fun(a=false,3, 45, b="ka", klos)
x + y
// snippet positionalOnly1
// String
// "13"
fn fun(!a, b){
  "" + a + b
}
fun(1, 3)

// snippet positionalOptional1
// String
// "1default"
fn fun(a, b="default"){
  "" + a + b
}
fun(1)

// snippet positionalDefaultSkipped
// Exception
// ""
fn fun(!a, b=2, c=3){
  "" + a + b + c
}
fun(1, , 4) // skipping b isn't allowed

// snippet mixedPositionalNamed
// String
// "13"
fn fun(!a, @b){
  "" + a + b
}
fun(1, b=3)

// snippet namedWithDefaultSkipped
// String
// "1default"
fn fun(@a, @b="default"){
  "" + a + b
}
fun(a="1")

// snippet shadowingInMeta
// String
// "metaValue"
fn fun(!a, {meta}){
  meta.a
}
fun("real", a="metaValue")

// snippet restAndMetaOverlap
// String
// "45ka"
fn fun([rest], {meta}){
  "" + rest[0] + rest[1] + meta["b"]
}
fun(4,5,b="ka")

// snippet invalidTypeInNamed
// Exception
// ""
fn fun(@a:num){
  a + 1
}
fun(a="stringValue")

// snippet closureAsNamedNotCallable
// Exception
// ""
fn fun(@a:str, ^cb){
  cb()
}
fun(a="val", cb="notAFunction")

// snippet multipleCallablesTrailing
// Exception
// ""
fn fun(@a, ^cb){
  cb() // too few arguments
}
fun(a="hi") {|a| a }

// snippet closureInlineWithMeta
// String
// "META3"
fn fun(@a, {meta}, ^cb){
  cb(a, meta.x)
}
fun(a="META", x=3) {|a,b| "" + a + b }

// snippet preprocessorSample
// String
// "hello huhu hihi hangyavadasz"
fn adhoc(){ // this will be deleted, it only exists in the preprocessor context
  "huhu "
}
# {|lexes|
["""
    let M:str = ""
    fn adhic(){
      "hihi "
    }
    M = M + "hello ";
    M = M + (adhoc() or "none ");
""",..lexes]
}
M = M + adhic() + "hangyavadasz"

// snippet jsonLazyObject
// String
// "12"
let z = &{
a : k, b : println("hubabba")
}
let M = ""
let k = 1
M = M + z.a
k = 2
M = M + z.a

// snippet defineEquals
// String
// "truefalse"

class A {
  fn `==`(other){
    this.a == other.a
  }
}

let x = A()
let y = A()
let z = {}

x.a = 1
x.b = "x"

y.a = 1
y.b = "y"

z.a = 1
z.b = "z"

""+ (x == y) + (y == z)

// snippet pinObject
// null
let a = {x:1,y:2};
pin {a}
let hu = { try {
    a.x = 3
    print("huhh")
}catch e {
    break 55
}};

hu

// snippet typeExpression
// String
// "kuka"
let a :("str") = "kuka"

// snippet async
// null
fn generator a=0, b=10 {
    for( i = a; i < b; i = i + 1 ) {
        println("sleeping")
        sleep(0.1);
        yield i;
        }
    }
fn future {
  global mikka_makka
  "abraka dabra " + mikka_makka
}
let a = 1
let b = 3
let k = [ .. {async {let a = 7, b = 9 ;generator(a,b);}},keys()]
println("The value of a is ", a);
println(k)
global mikka_makka = "Maminti"
let f = async {let a=5;future()}
println(await f)

// snippet streaming
// Long
// 1000
fn gen_1_to_10 {
    for i=1 ; i <= 10 ; i = i + 1:
        yield i;
    return 1000
}

let st = async gen_1_to_10();
println( st );
while st.has_next() :
    println(st.next());
await[10000] st

// snippet fibonacci
// Long
// 89
    fn k(x){
        if x == 1 || x ==  0 : 1
        else: k(x-1)+k(x-2)
    }


k(10)
// snippet localFibonacci
// Long
// 89
{
    fn k(x,this=me){
        if x == 1 || x ==  0 : 1
        else: me(x-1) + me(x-2)
    }
k(10)
}

// snippet LoopContext
// Long
// 10
let i = 0
while i < 10 {
  let k = 5; // this is okay in a loop context
  println( k + i)
  // this is wrong, but since we are dynamic, Turi accepts it
  if i > 0 : let k = 7
  i = i + 1
}

// snippet argumentSpreading
// String
// "1 2 3 4 1 2 3 4 "
fn a(@a,@b,@c,@d){
    "%s %s %s %s " % [a,b,c,d]
}
fn b(!a,!b,!c,!d){
    "%s %s %s %s " % [a,b,c,d]
}

a(..{a:1,b:2,c:3,d:4}) + b(..[1,2,3,4])

// snippet typeRdefinition
// null
class K {fn p(){println "original K" }}
fn h():K = K()
let t:fn = {
   let _K = K;
   {|| _K()}
}
class K {fn p(){println "overwritten K" }}
h().p()
t().p()

none
// snippet EmptyBlockIsObject
// null
let a = {}
a.field

// snippet singleLineComments
// null
null // is undefined so it is null in the Java world

// snippet multiLineComment
// null
/*
 * A variable that is not defined is null, and it is like that in the Java caller
 */
null

// snippet multiLineNestedComment
// null
/*
 * A variable that is not defined is null, and it is like that in the Java caller
 *  /* comments can also be nested inside of each other */
 */
null

// snippet sample1
// Long
// "42"
1 + 41

// snippet sample2
// Long
// "42"
1 + 41


// snippet basicCommands
// Long
// 60
let h = []
h[3].b = []
h[3].b[2] = 5
let z = h[3].b[2]
let a = {}
a.x = 10; let c = 30; let b = []; b[c] = 20; a.x + b[30] + c

//
// Each snippet entry is formatted as follows:
//
// // snippet <snippetName>
// // <expected class>
// // "<expected value>"
// <program code...>
//

// snippet testArithmeticOperations
// Long
// "0"
let x = 100;
let y = 50;
let z = x - y * 2;
z;

// snippet testFieldAccess
// String
// "suss84"
let arr =  {}
, z = {}
arr.h = 42;
z["field"] = "suss"
z.field + ({arr}.h + arr["h"]);


// snippet testArrayAccess
// String
// "suss84"
let arr = []
arr[3] = 42;
let z = {}
z["field"] = "suss"
z.field + {arr}[3] * 2;

// snippet testNestedArrayAccess
// Long
// "84"
let arr = []
arr[3][2] = 42;
arr[3][2] * 2;

// snippet testMultipleAssignments
// Long
// "17"
let obj = {}
obj.a = 5;
obj.b = obj.a * 3;
let arr = []
arr[1] = obj.b + 2;
arr[1];

// snippet testComplexExpressions
// Long
// "30"
let x = {}
x.val = 10;
let y = []
y[{7}] = 5;
let z = 2;
let result = (x.val + y[7]) * z;
result;

// snippet testFloatingPointOperations
// Double
// "18.3125"
let x = 10.5;
let y = 3.25;
let z = x * y + 2.5;
z / 2;

// snippet testIfStatement1
// Long
// "20"
let x = 10;
let result = {
    if x > 5 {
        result = x * 2;
    } else {
        result = x / 2;
    }
}
result;

// snippet testIfStatement2
// Double
// "1.5"
let x = 3;
let result = {if x > 5 {
    x * 2;
} else {
    x / 2;
}}
result;

// snippet testExportAssignment1
// String
// "ok"
let x = 10;
{ let z = 1 }
{ if z {"not ok"} else {"ok"} }

// snippet testExportAssignment2
// Long
// "20"
let x = 10;
let z = 7;
{ z = 2 }
x * z;

// snippet testExportAssignment3
// Long
// "20"
let x = 10;
let z = 7;
{{{{{{ z = 2 }}}}}}
x * z;

// snippet testGlobalDeclaration
// Long
// "5"
let x = 10;
let z = 7;
let h = 6;
{ global x,z,h }
5;

// snippet testFunctionDeclaration
// null
fn function x2, z, h {
} null; //anything undefined is null

// snippet testFinalDeclaration1
// Long
// "2"
pin a=1, b=2;
a*b;

// snippet testFinalDeclaration2
// Exception
// ""
final a=1, b=2;
let a = 3;

// snippet NoEmptyParentList
// Exception
// ""
class z : {
}


// snippet testQuotedIdentifier1
// Long
// "2"
pin `a`=1, `pin`=2;
a*`pin`;

// snippet testQuotedIdentifier2
// Long
// "2"
pin a=1, `this is a\\nmulti-line identifier`=2;
a *`this is a\\nmulti-line identifier`;

// snippet testCallingFunction1
// Long
// "3"
fn f a,b,c {
    a + b + c
}
f(1,1,1);

// snippet testCallingFunction2
// Long
// "3"
let f = fn(a,b,c) {
    a + b + c
}
f(1,1,1);

// snippet testCallingFunction3
// Long
// "3"
let f = {}
f.k = fn z(a,b,c) {
    a + b + c
}
f.k(1,1,1);

// snippet testClassDeclaration
// String
// "it works12"
class meClass {
    global some =  "it works";
    let other = "local";
    fn a {1}
    fn b {2}
}
let some = "it works";
some + meClass.a() + meClass.b();

// snippet testClassInstanceCreation
// Long
// "3"
class meClass {
    fn a {1}
    fn b {2}
}
let object = meClass();
object.a() + object.b();

// snippet testClassInheritance
// Long
// "3"
class Parent {
    fn a {1}
}
class meClass : Parent {
    fn b {2}
}
let object = meClass();
object.a() + object.b();

// snippet testMultipleInheritance
// String
// "1234"
class P1 {
 fn p1 {1}
}
class P2 : P1 {
 fn p2 {2}
}
class P3 {
    fn p3 {3}
}
class P4 : P3, P2 {
    fn p4 {4}
}
let object = P4();
"" + object.p1() + object.p2() + object.p3() + object.p4();

// snippet testConstructorInheritance
// String
// "1234"
class P1 {
 fn p1 {this.a}
}
class P2 : P1 {
 fn p2 {b}
}
class P3 {
    fn p3 {this.c}
}
class P4(a,b,c) : P3, P2 {
    fn p4 {
        a =4;
        p1()
    }
}
let object = P4(1,2,3);
"" + object.p1() + object.p2() + object.p3() + object.p4();

// snippet testMethodInheritance
// Long
// "1"
class Parent {
 fn parent {1}
}
class Child : Parent {
 fn child { parent() }
}
let child = Child();
child.child();

// snippet testThisIsFinal
// Exception
// ""
class Class {
 fn fun {
   this = 55
  }
}
`class` = Class();
`class`.fun();

// snippet testPipeOperator1
// Long
// "1"
let a = 1
let b = a or 2

// snippet testPipeOperator2
// Long
// "2"
let a = 1
let b = c
or 2

// snippet testClassExtension
// Long
// "3"
class Class {}
Class.z = fn () {
  3
}
Class().z();

// snippet classDefinedWithAssignment
// String
// "csaka haha fogorvos hihi segithet huhu"
let msg = ""
pin PrinterClass = class {
  let print = fn (message){
    global msg;
    msg = msg + message
    }
}

pin p = PrinterClass()
p.print("csaka haha ")
p.print("fogorvos hihi ")
p.print("segithet huhu")

// snippet ifNoBlock
// Long
// "1"
if 1: 1 else: 2

// snippet constantTrue
// Exception
// ""
let true = 0

// snippet constantFalse
// Exception
// ""
let false = 0

// snippet constantNone
// Exception
// ""
let none = 0

// snippet looping1
// Long
// 10
/*
 while loop condition and body is executed in a local loop environment
*/
let i = 1
while i < 10 : i = i + 1

// snippet looping2
// Long
// 10
let i = 1
let z
while i < 10 { i = i + 1;
  z = i}
z

// snippet looping3
// Long
// 10
let i = 1
fn inci {
  global i
  i =  i + 1
}
let z
while i < 10 : z = inci()
z

// snippet looping4
// Long
// 10
/*

here we define a function that increments the loop variable, which is a global variable.
Even the loop body is not enclosed between '{' and '}' it is executed in a new local environment

 */
let i = 1
fn inci {
  global i
  i =  i + 1
}
global z = 0
while i < 10 : z = inci()
z

// snippet looping5
// Long
// 9
let i = 1
while i < 10 { i = i + 1 } until i == 9;;;;

// snippet looping6
// Long
// 9
let i = 1
while( i < 10 )  i = i + 1 ; until i == 9;;;;

// snippet forLoop1
// Long
// 9
let z = 0
for i=1 ; i<10 ; i=i+1 : z=i
z

// snippet forLoop2
// Long
// 9
let z = 0
for let i=1 ; i<10 ; i=i+1 : z=i
z

// snippet forLoop3
// Long
// 9
let z = 0
for( i=1 ; i<10 ; i=i+1 ): z=i
z

// snippet forLoop5
// Long
// 8
let z = 0
for i=1 ; i<10 ; i=i+1 : z=i until i == 8
z

// snippet forLoop6
// Long
// 9
let z = 0
for (i=1 ; i<10 ; i=i+1 )  z=i
z

// snippet closure1
// Long
// 3
let z = {| a,b,c | a+1 } ; z(2,3,4)

// snippet closure2
// Long
// 3
{| a,b,c | a+1 }(2,3,4)

// snippet closure3
// Long
// 3
let z = {| a,b,c | a+1 } ; z(2,3,4)

// snippet boost
// Long
// 2
+{fn map(x) {
  x * 2
}}(1)
//burst b = 0 ; { for i = 1 ; i < 3 ; i++ : yield i } -> map -> {|a| a * 2} ->  {|a| b = b + a }

// snippet range
// Range
// "13..2"
13..2

// snippet listLiteral1
// Long
// 1
[1,2,3][0]

// snippet listLiteral2
// Long
// 2
[1..3][1]

// snippet listLiteral3
// Long
// 2
let a = [1..3];
[..a,7][1]

// snippet forEachLoop1
// Long
// 6
let a = [1..4];
let k = 0;
for each z in a : k = k + z


// snippet pinExample
// String
// "3 7 7 7"
"""
pin signals that a variable cannot be modified any more in the given scope.
It does not prevent code in enclosing scopes.
It also does not prevent any inner/enclosed scopes to use the variable as modifiable, however any modification will
be local to that level.
"""
let i = 3; pin i; let j = 3, s = 5, k = 0;
{
   s = s + 1;
   pin s;
   // you cannot do that, if 'i' is local then it is local
   // you cannot eat your cake and have it, not even if you are the UB
   // let i = i + 4;
   k= i + 4
   j = j + 4;
}
s = s + 1;
""+i+" "+k+" "+j+" "+s
// fn reducer(acc,item)= acc+item
// { burst init_expression ; generator_expression ? filter -> map ? filter ... >>= reducer with unit=expression}

// snippet minusOperatorSample
// Long
// 3
class A(zumba) {
  fn `+`(right) {
     if( right != null ) {
          A(this.zumba + right.zumba)
     } else {
          this
     }
  }
  let `-` = macro({|right|
         if( right != null ) {
              A(this.zumba - evaluate(right).zumba)
         } else {
              A(-this.zumba)
         }
     })
}
let a = -A(1);
let b = A(2);
(b-a).zumba

// snippet constructorAsFactory
// String
// "Y says: csaka haha fogorvos hihi segithet huhu"
class PrinterClass{
  fn constructor {
    this.msg = ""
  }
  let print = fn (message){
    this.msg = this.msg + message
    }
}

class z{
    fn constructor {
      this = PrinterClass();
      this.msg = "Z says: "
    }
}
class y : PrinterClass {
    fn constructor {
      this.msg = "Y says: "
    }
}

let p = PrinterClass()
p.print("csaka haha ")
p.print("fogorvos hihi ")
p.print("segithet huhu\n")
z = z()
z.print("csaka haha ")
z.print("fogorvos hihi ")
z.print("segithet huhu\n")
y = y()
y.print("csaka haha ")
y.print("fogorvos hihi ")
y.print("segithet huhu")


// snippet stringIndexing1
// String
// "zebra"
let string = "zabraa"
string[1] = "e"
string[0..-1]

// snippet StringIndexing2
// String
// 17754
let MESSAGE = "1234"
// you can replace part of the string in an assignment
// it can be longer than the part replaces, can be shorter, even empty
MESSAGE[1..3] = 775
MESSAGE

// snippet StringIndexing3
// String
// 13
let X = {}
X.MESSAGE = "1234"
X.MESSAGE[1..3] = 32
X.MESSAGE[-inf..2] // bad luck

// snippet reclosingClosure
// String
// "55 77 63 63 99 77"
let MESSAGE = ""
let z = 55;
let y = 77;
let x = {|| MESSAGE = MESSAGE + z + " "
        z = y;
    };
x(); // 55, z <- 77
{
  let z = 63;
  x(); // 77
  MESSAGE = MESSAGE + z + " " // 77
  y = 99;
  reclose(x)(); // 63
  MESSAGE = MESSAGE + z + " " // 99
}
MESSAGE = MESSAGE + z + " " // 77
MESSAGE = MESSAGE[0..-1]

// snippet catchingException
// String
// "It is not possible to invoke 'nonexistent' because it is 'null'"
let MESSAGE = ""
try {
  let h = nonexistent()
}catch exception {
  MESSAGE = exception.message
}
MESSAGE
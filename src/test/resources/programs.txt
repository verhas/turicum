// snippet EmptyBlockIsUndef
// null
{}

// snippet singleLineComments
// null
null // is undefined so it is null in the Java world

// snippet multiLineComment
// null
/*
 * A variable that is not defined is null, and it is like that in the Java caller
 */
null

// snippet multiLineNestedComment
// null
/*
 * A variable that is not defined is null, and it is like that in the Java caller
 *  /* comments can also be nested inside of each other */
 */
null

// snippet sample1
// Long
// "42"
1 + 41

// snippet sample2
// Long
// "42"
1 + 41


// snippet basicCommands
// Long
// 60
h[3].b[2] = 5
z = h[3].b[2]
a.x = 10 c = 30 b[c] = 20 a.x + b[30] + c

//
// Each snippet entry is formatted as follows:
//
// // snippet <snippetName>
// // <expected class>
// // "<expected value>"
// <program code...>
//

// snippet testArithmeticOperations
// Long
// "0"
x = 100;
y = 50;
z = x - y * 2;
z;

// snippet testFieldAccess
// String
// "suss84"
arr.h = 42;
z["kaka"] = "suss"
z.kaka + {arr}.h * 2;


// snippet testArrayAccess
// String
// "suss84"
arr[3] = 42;
z["kaka"] = "suss"
z.kaka + {arr}[3] * 2;

// snippet testNestedArrayAccess
// Long
// "84"
arr[3][2] = 42;
arr[3][2] * 2;

// snippet testMultipleAssignments
// Long
// "17"
obj.a = 5;
obj.b = obj.a * 3;
arr[1] = obj.b + 2;
arr[1];

// snippet testComplexExpressions
// Long
// "30"
x.val = 10;
y[{7}] = 5;
z = 2;
result = (x.val + y[7]) * z;
result;

// snippet testFloatingPointOperations
// Double
// "18.3125"
x = 10.5;
y = 3.25;
z = x * y + 2.5;
z / 2;

// snippet testIfStatement1
// Long
// "20"
x = 10;
result ={
    if x > 5 {
        result = x * 2;
    } else {
        result = x / 2;
    }
}
result;

// snippet testIfStatement2
// Double
// "1.5"
x = 3;
result = {if x > 5 {
    x * 2;
} else {
    x / 2;
}}
result;

// snippet testExportAssignment1
// String
// "ok"
x = 10;
{ z = 1 }
{ if z {"not ok"} else {"ok"} }

// snippet testExportAssignment2
// Long
// "20"
x = 10;
z = 7;
{ z := 2 }
x * z;

// snippet testExportAssignment3
// Long
// "20"
x = 10;
z = 7;
{{{{{{ z := 2 }}}}}}
x * z;

// snippet testLocalAssignment
// Long
// "10"
x = 10;
z = 7;
h = 6;
{ h= {z = 1};
  local z,h=2;
  z = 2 }
x * z * h;

// snippet testGlobalDeclaration
// Long
// "5"
x = 10;
z = 7;
h = 6;
{ global x,z,h }
5;

// snippet testFunctionDeclaration
// null
fn function x2, z, h {
} null; //anything undefined is null

// snippet testFinalDeclaration1
// Long
// "2"
pin a=1, b=2;
a*b;

// snippet testFinalDeclaration2
// Exception
// ""
final a=1, b=2;
a = 3;

// snippet NoEmptyParentList
// Exception
// ""
class z : {
}


// snippet testQuotedIdentifier1
// Long
// "2"
pin `a`=1, `pin`=2;
a*`pin`;

// snippet testQuotedIdentifier2
// Long
// "2"
pin a=1, `this is a\\nmulti-line identifier`=2;
a *`this is a\\nmulti-line identifier`;

// snippet testCallingFunction1
// Long
// "3"
fn f a,b,c {
    a + b + c
}
f(1,1,1);

// snippet testCallingFunction2
// Long
// "3"
f = {fn(a,b,c) {
    a + b + c
}}
f(1,1,1);

// snippet testCallingFunction3
// Long
// "3"
f.k = {fn z(a,b,c) {
    a + b + c
}}
f.k(1,1,1);

// snippet testClassDeclaration
// String
// "it works12"
class meClass {
    global some =  "it works";
    other = "local";
    fn a {1}
    fn b {2}
}
some =  "it works";
some + meClass.a() + meClass.b();

// snippet testClassInstanceCreation
// Long
// "3"
class meClass {
    fn a {1}
    fn b {2}
}
object = meClass();
object.a() + object.b();

// snippet testClassInheritance
// Long
// "3"
class Parent {
    fn a {1}
}
class meClass : Parent {
    fn b {2}
}
object = meClass();
object.a() + object.b();

// snippet testMultipleInheritance
// String
// "1234"
class P1 {
 fn p1 {1}
}
class P2 : P1 {
 fn p2 {2}
}
class P3 {
    fn p3 {3}
}
class P4 : P3, P2 {
    fn p4 {4}
}
object = P4();
"" + object.p1() + object.p2() + object.p3() + object.p4();

// snippet testConstructorInheritance
// String
// "1234"
class P1 {
 fn p1 {this.a}
}
class P2 : P1 {
 fn p2 {b}
}
class P3 {
    fn p3 {this.c}
}
class P4(a,b,c) : P3, P2 {
    fn p4 {
        a =4;
        p1()
    }
}
object = P4(1,2,3);
"" + object.p1() + object.p2() + object.p3() + object.p4();

// snippet testMethodInheritance
// Long
// "1"
class Parent {
 fn parent {1}
}
class Child : Parent {
 fn child { parent() }
}
child = Child();
child.child();

// snippet testThisIsFinal
// Exception
// ""
class Class {
 fn fun {
   this = 55
  }
}
`class` = Class();
`class`.fun();

// snippet testPipeOperator1
// Long
// "1"
a = 1
b = a or 2

// snippet testPipeOperator2
// Long
// "2"
a = 1 b = c or 2

// snippet testClassExtension
// Long
// "3"
class Class {}
Class.z = fn () {
  3
}
Class().z();

// snippet classDefinedWithAssignment
// String
// "csaka haha fogorvos hihi segithet huhu"
msg = ""
final PrinterClass = class {
  print = fn (message){
    global msg;
    msg = msg + message
    }
}

p = PrinterClass()
p.print("csaka haha ")
p.print("fogorvos hihi ")
p.print("segithet huhu")

// snippet ifNoBlock
// Long
// "1"
if 1: 1 else: 2

// snippet exitingBlockWithBreak
// Long
// "1"
{
1 ; 2; break 1; 3 ; 4

}

// snippet constantTrue
// Exception
// ""
true = 0

// snippet constantFalse
// Exception
// ""
false = 0

// snippet constantNull
// Exception
// ""
null = 0

// snippet conditionalBreak
// Long
// 5
{
1 ; 2; break 1 if true; 3 ; 4
} + {
    1 ; 2; break 1 if false; 3 ; 4
    }


// snippet looping1
// Long
// 10
/*
 while loop condition and body is executed in a local loop environment
*/
i = 1
while i < 10 : i = i + 1

// snippet looping2
// Long
// 10
i = 1
while i < 10 { i = i + 1;
  z := i}
z

// snippet looping3
// null
i = 1
fn inci {
  global i
  i =  i + 1
}
while i < 10 : z = inci()
z

// snippet looping4
// Long
// 10
/*

here we define a function that increments the loop variable, which is a global variable.
Even the loop body is not enclosed between '{' and '}' it is executed in a new local environment

 */
i = 1
fn inci {
  global i
  i =  i + 1
}
while i < 10 : z := inci()
z

// snippet looping5
// Long
// 9
i = 1
while i < 10 { i = i + 1 } until i == 9;;;;

// snippet looping6
// Long
// 9
i = 1
while( i < 10 )  i = i + 1 ; until i == 9;;;;

// snippet forLoop1
// Long
// 9
for i=1 i<10 i=i+1 : z:=i
z

// snippet forLoop2
// Long
// 9
for i=1 ; i<10 ; i=i+1 : z:=i
z

// snippet forLoop3
// Long
// 9
for( i=1 ; i<10 ; i=i+1 ): z:=i
z

// snippet forLoop4
// Long
// 9
for { i:=1} ; i<10 ; i=i+1 : z:=i
z

// snippet forLoop5
// Long
// 8
for { i:=1} ; i<10 ; i=i+1 : z:=i until i == 8
z

// snippet forLoop6
// Long
// 9
for (i=1  i<10  i=i+1 )  z:=i
z

// snippet closure1
// Long
// 3
 z = {| a,b,c | a+1 } ; z(2,3,4)

// snippet closure2
// Long
// 3
{| a,b,c | a+1 }(2,3,4)

// snippet closure3
// Long
// 3
 z = {| a,b,c | a+1 } ; z(2,3,4)

// snippet boost
// Long
// 2
+{fn map(x) {
  x * 2
}}(1)
//burst b = 0 ; { for i = 1 ; i < 3 ; i++ : yield i } -> map -> {|a| a * 2} ->  {|a| b = b + a }

// snippet range
// Range
// "13..2"
13..2

// snippet listLiteral1
// Long
// 1
[1,2,3][0]

// snippet listLiteral2
// Long
// 2
[1..3][1]

// snippet listLiteral3
// Long
// 2
a = [1..3];
[..a,7][1]

// snippet forEachLoop1
// Long
// 6
a = [1..4];
k = 0;
for each z in a : k = k + z


// snippet blabla
println("blala")
// end snippet

// snippet first_sample
print("Hello,");
println(" World")
for i=1 ; i < 3 ; i = i+1 : println(i)
// end snippet

// snippet if_value
let z : num = {if 232 % 2 == 0 : 1 else: 2 }
println(z)
// end snippet

// snippet block_value
let z = {
    let k = "Hi";
    k + "cory"
    }
println(z)
// end snippet

// snippet scope1
let z = "cory"
z = { // z is global
    println("just a print")
    let k = "Hi" // k is local
         + z // z is accessible
    // the value of the block is the last commands, value
    // 'let' assignments result the value assigned
    }
println(z)
println(k)
// end snippet

// snippet local_redefined_error
let z = 5
try{
    z = {
        println(z);
        let z = 3
        }
}catch e {
    println(e)
}
// end snippet

// snippet function_scope
let glb = "global variable";
class A {
  fn z(){
    println("You can read glb, which is a " + glb)
    try{
       // you cannot change it without declaring that it is global
       glb = 5;
    }catch(e){
        println("exception 1:",e)
    }
    try{
       // you touched it as global, you cannot declare it as local anymore
       let glb = 5;
    }catch(e){
        println("exception 2:",e)
    }
    global glb;
    glb = "modified"
    return "You can access glb here it is " + glb ;
  }
}
let obj = A()
println(obj.z())
// end snippet

// snippet class_definition
class X {
  let s = "hu"
}
println("class var ", X.s)
let x = X();
println("object var ", x.s)
// end snippet

// snippet object_scope
class X {
  let s = "class field"
  cls.h = "another class field"
  fn constructor {
    let g = "object field"
  }
  fn t(){
    // access object field explicitly through 'this'
    println("this.g=",this.g)
    // the object wraps the class scope and not the other way around
    // there is no 'g' defined in the class
    println("cls.g=",cls.g)
    // 'g' is in the wrapped scope of the object scope
    // this is same as 'this.g'
    println("g=",g)
    // 'this.h' is the same as 'cls.h' because of wrapping
    println("this.h=",this.h)
    println("cls.h=",cls.h)
    println("h=",h)
    // the same is true for the other field
    // does not matter how it was defined
    println("this.s=",this.s)
    println("cls.s=",cls.s)
    println("s=",s)
  }
}
let x = X();
x.t()
// end snippet

// snippet closure_example
let c = {
    let whom = "World!";
    {|greeting|
        println(greeting,whom);
        whom = "Universe!"
    }
}
c("Hello, ")
c("Hi, ")
// end snippet

// snippet macro_example
let c = macro(
    {|condition,then,`else`|
        if evaluate(condition) : evaluate(then) else: evaluate(`else`)
    })

print(

    c(true,"yes, it is true",{ println("this will never be printed") })

    );
// end snippet

// snippet let_with_types_example
let c : str |num = 3;
c = "" + c + " == " + c
println(c)
// end snippet

// snippet pinning
let turicum = 13
let list = [1,2,3]
let object = { x:1, y:2};
pin turicum, [list], {object}

try {
  turicum = 14;
}catch e: println("could not change the variable")

try {
  list[1] = 0;
}catch e: println("could not change the list")
list = [ 0, ..list, 4]
println("variable 'list' still can be changed: ", list)

try {
  object.x = 3;
}catch e: println("could not change the object")
object = { x:1, y:3 }
println("variable 'object' still can be changed: ", object)

// end snippet

// snippet ifCommand
let a= 13
if a%2 == 0: println("even") else: println("odd")
a = {if a%2 == 0: "even" else: "odd"}
print("again ",a)
// end snippet

// snippet whileLoop
let i = 1;
while i < 5 {
  print(i," ");
  i = i + 1;
}until i % 3 == 0;
// end snippet

// snippet whileLoop2
let i = 1;
while i < 5 :
  i = i + 1;
until i % 3 == 0;
println(i)
// end snippet

// snippet for1
for i = 1 ; i < 5 ; i=i+1 {
  print(i," ")
}until i%3 == 0 ;
// end snippet
// snippet for2
for( i = 1 ; i < 5 ; i=i+1 ){
  print(i," ")
}
// end snippet
// snippet for3
// same as 'for( let i = 1 ;' ...
for( i = 1 ; i < 5 ; i=i+1 ){
  print(i," ")
}until i%3 == 0 ;
println("i at end=",i);
// end snippet
// snippet for4
let i;
for {i = 1} ; i < 5 ; i=i+1 :  print(i," "); until i%3 == 0;
println("i at end=",i);
// end snippet
// snippet foreach1
for each i in [1,2,3,4]: print(i," ");
// end snippet
// snippet foreach2
for each i in [1,2,3,4]: print(i," "); until i%3 == 0
// end snippet

// snippet yield1
fn gen_1_to_10 {
    for i=1 ; i <= 10 ; i = i + 1:
        yield i;
}

println([ .. stream(gen_1_to_10()) ])
// end snippet

// snippet yield2
fn gen_1_to_10 {
    for i=1 ; i <= 10 ; i = i + 1:
        yield i;
}

let st = stream(gen_1_to_10());
while st.has_next() :
    println(st.next());
// end snippet

// snippet fun1
fn inc(x) {
  x+1
}
println(inc)
println(inc(1))
// end snippet

// snippet fun3
fn inc x {
  x+1
}
println(inc)
println(inc(1))
// end snippet

// snippet fun2
let inc = fn (x) {
  x+1
}
println(inc)
println(inc(1))
// end snippet

// snippet fun4
fn inc !x, @how_much {
  x+how_much
}
println(inc)
println(inc(1,how_much=5))
// end snippet

// snippet fun5
fn inc !x, @how_much=1 {
  x+how_much
}
println(inc(1,how_much=5))
println(inc(1))
// end snippet

// snippet fun6
fn wrong !x, h, !k {
  // just don't do
}
try: wrong(1,3, h= 2)
catch e: println("There is an error",e)
// end snippet

// snippet restParameters
let f = fn (a,b,[rest]) {
  println("a=",a)
  println("b=",b)
  for each r in rest: print("%s " % r)
}

f(1,2,3,4,5,6)
// end snippet

// snippet metaParameters
let f = fn (a,b,{meta}) {
  println("a=",a)
  println("b=",b)
  for each r in keys(meta): print("%s=%s\n" % [r , meta[r]])
}

f(1,b=2,k=3,x=4,juice=5,six=6)
// end snippet

// snippet metaRestParameters
let f = fn (a,b,[rest],{meta}) {
  println("a=",a);
  println("b=",b);
  for each r in keys(meta): print("%s=%s\n" % [r , meta[r]]);
  println("rest:");
  for each r in rest: print("%s " % r);
}

f(1,b=2,k=3,x=4,juice=5,7,six=6);
// end snippet

// snippet closureArgument
let f = fn (a,b,^closure) {
  println("a=",a);
  println("b=",b);
  println(closure(a,b))
}

f(2,3){|x,y| x+y}
f(2,3){|x,y| x*y}
// end snippet


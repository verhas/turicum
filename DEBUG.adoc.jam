= Debugging Turicum

This document describes how you can debug a Turicum program.
Later chapters also describe how the debugger is implemented.

== Using the Debugger

In the current version the debugger can be used, using the REPL command line version of Turicum.
To start the REPL functionality, you can type at the command line:

    turi -REPL

What you will see will be something like

[source]
----
$ turi -REPL
WARNING: A restricted method in java.lang.System has been called
WARNING: java.lang.System::load has been called by org.jline.nativ.JLineNativeLoader in an unnamed module (file:/Applications/turicum.app/Contents/app/jline-3.30.0.jar)
WARNING: Use --enable-native-access=ALL-UNNAMED to avoid a warning for callers in this module
WARNING: Restricted methods will be blocked in a future release unless native access is enabled

Turicum REPL with JLine (//help for more info)
>>>
----

The `>>>` at the bottom of the screen is the input prompt, where you can type in commands.

The first command to debug a program is

    sys_import turi.debug

This will import the helper functions that you can use while debugging the code.
Instead, you can

    sys_import turi.debug_short

that will define the same functions and also abbreviation aliases, like `si` for `step_into`, `so` for `step_over`, and so on.

It is usually a good practice to put one of these commands into the `.repl.turi` file along with a command mode setting:

..repl.turi
[source]
----
sys_import turi.debug_short;""
// set command_mode=on
----

The second line will tell the REPL application to call commands that have no arguments automatically.
With that, you can type `line` and you do not need to type `line()` to call the function.
Without setting command mode on, typing `line` just prints `fn()`, which is the string representation of the value held by the variable `line`.

The second command you want to issue is

    debug "debugged.turi"

to load and start the file, you want to debug.
This command will compile the Turicum code `debugged.turi` and execute it, stopping before the first command.

The next command you may want to execute is `line()`

[source]
----
>>> line()
1. {
2.     let k  = 13
3.
4.     global zummamma  = "harbaropi tukirrama"
5.     fn sumabva(kirta : num , jurtka : str , zeruomo : any){
6.         return str(kirta)+jurtka +str(zeruomo)
7.     }
8.     println "Hello, World!"
9.     let muthafa  = "ka"
10.     println $"Hello, ${sumabva(629541.3,\" jippieee \", muthafa)}"
11. }
>>>
----

The debugger will list the lines of the code of the current command.
Since the first command is the whole program, that you can step into, it will list all the lines as in the example above.

You can start the execution issueing the command `step_into()` to step into the program.
In the example above the first command is a block, which includes the same lines as the whole program.
In this example you also have to step into this one to get to the line 2.

[source]
----
>>> step_into();
done
done

>>> line()
1. {
2.     let k  = 13
3.
4.     global zummamma  = "harbaropi tukirrama"
5.     fn sumabva(kirta : num , jurtka : str , zeruomo : any){
6.         return str(kirta)+jurtka +str(zeruomo)
7.     }
8.     println "Hello, World!"
9.     let muthafa  = "ka"
10.     println $"Hello, ${sumabva(629541.3,\" jippieee \", muthafa)}"
11. }
11. }

>>> step_into();
done
done

>>> line()
2.  let k  = 13
none
>>>
----

In the followings, this document lists all the commands that are available to debug the application.

=== `debug(file_name : str , @timeout  = 1000 /*one sec*/ )`

Open the file `file_name` for debugging.
It should load and start in a second, unless the named `@timeout` parameters defines larger timeout.
If the list of the threads after loading the application contains the thread `main`, it is automatically selected.

The threads can be listed using the `threads()` function.
A specific thread can be selected using the `thread(name)` function.

The function prints out an error mesaage or that the debugging was started.
The function returns `none`.


=== `command()`

This function prints out the current command, and it also returns the command.
The function returns the command object itself and not a string.

=== `breakpoints()`

The function prints out and also returns a list containing the line numbers of the lines that have breakpoints on them.
This function gives the list of the currently selected threads breakpoints.
These breakpoints have only effect when the interpreter executes the thread they belong to.

=== `global_breakpoints()`

The function prints out and also returns a list containing the line numbers of the lines that have breakpoints on them.
This function gives the list of the global breakpoints.
These breakpoints have an effect when the interpreter executes any thread.


=== `pos()`

This command prints out the start and end position of the current command.
This is in the format `[start_line:start_column - end_line:end_column]`.
The function also returns an object

[source]
----
{
start :{line : start_line , column : start_column},
end :{line : end_line , column : end_column}
}
----

=== `line(start  = none , end  = none)`

List the lines of the code between `start` and `end`.
If the parameters are missing, then the lines of the current command are printed.


=== `threads`

Print the names of the threads running.

=== `thread(name : str)`

Select the named thread.
Subsequent commands, such as setting a breakpoint, stepping, and running, will be performed on this thread.

=== `finished`

Prints `FINISHED` or `RUNNING` to see if the debugged program has terminated.
It also returns a boolean value `true` when the program has finished.


=== `globals`

It lists, and it also returns the global variables.

=== `locals(@no_globals  = false)`

This command lists the local variables.
These are the variables in the local context and all the wrapping contexts.
The `no_globals` option can instruct the command not to list the global variables.
It makes sense when we are in a context that directly or transitively wraps the global context.



=== `step_into``

Step into the current command.
It is not only to step into a function or closure call, but also to execute the command step by step individually, executing the subcommands.
For example, a whole program is a command consisting of a list of subcommands.

Another example can be a `print` command with a string.
`step_into` will step to evaluate the string argument first, and then it stops for further debugger instructions.

=== `step_over`

Execute the current command and step over it to the next command.

=== `run`

Execute the commands till the next break point.

=== `add_breakpoint(line : int)`

Add a breakpoint to the line with the line number as an argument.
Line numbers start at 1.
Adding a breakpoint with this function will stop the execution only of the currently selected thread.

=== `remove_breakpoint(line : int)`

Remove the breakpoint from the currently selected thread's breakpoints.

=== `add_global_breakpoint(line : int)`

Add a breakpoint that affects every thread.

=== `remove_global_breakpoint(line : int)`

Remove the global breakpoint for the line.

=== `help`

Will print a short help text with up-to-date, but short command descriptions.

== Debugger Architecture

When you start a program using the debugger, it starts a new interpreter in the same process in a separate thread in debug mode.
When an interpreter starts in debug mode, it stops it

* has a non-blocking channel to communicate with the debugger thread, and
* the interpreter will stop the execution before each command.

When the interpreter stops in any thread, it sends a debug command object (DCO) to the channel.
The debugger gets the DCO, and with that, it knows that there is a thread waiting for a debugger command.
When a debugger command is executed, the debugger modifies the DCO, filling in the command parameters, and decrements a counter signalling the thread that the DCO now contains a command ready for the thread to execute.

The thread executes the command and sends the result back in a new DCO to the debugger.

The debugger communication is implemented in Java and is callable from Turicum.
The `DebugSessionFactory` class is a `TuriFunction` that creates a `DebugSession` object.
This class implements various methods for communicating with debugged threads.

When you issue `list`, `step_into`, and other commands in the REPL application, you essentially run Turicum code executing debugging functions debugging a different application.

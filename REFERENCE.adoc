= Turicum Programming Language Reference










== Introduction

=== What is Turicum?

Turicum is a modern programming language designed for expressiveness, safety, and concurrency.
It combines functional and object-oriented paradigms with a clean and coherent syntax.
Its preprocessing capabilities and dynamic nature make it a uniquely powerful tool for programming.

=== Turicum Is

* **Functional**
+
Functions, closures, and macros are first-class citizens in Turicum.
Any of these can be used as values.
Every command evaluates to a value, so any command can appear within an expression, and every expression is also a command.

* **Object-Oriented**
+
Programs can define classes, methods, multiple inheritance,
and objects that inherit properties from their class.

* **Dynamic**
+
All definitions are created at runtime and can be modified at runtime.
For example, a class or function is created when its definition is executed, and it exists within the defining context.
Methods are just fields containing closures or function values, and they can be added to any class or object—even after creation.

* **Flexible**
+
The interpreter can evaluate loaded code at any time, passing the remaining lexical tokens to a preprocessor.
This preprocessor—written in Turicum as a function or closure—can transform the token stream, enabling arbitrary syntactic extensions to the language.

* **Multithreaded**
+
The interpreter is built on Java 21 and supports for Virtual Threads, using native language constructs.

* **Typed and Scoped**
+
Variables can be optionally typed, and assignments are dynamically type-checked at runtime.

Turicum functions both as a scripting language and as an embeddable engine.
It can run as a standalone command-line tool or be integrated into Java or Kotlin applications as a library.

Turicum is implemented in Java and is designed to be approachable for JVM developers while introducing powerful new abstractions.

The name “Turicum” is the ancient Roman name for the city of Zürich, Switzerland, where the language is being developed.

=== Implementations

The interpreter is currently available in three different applications:

* command line version

* as a Maven extension

* as a Java library.

== Command Line

The command line version is available as an installation kit for Windows, Linux, and macOS.
The kits are available on GitHub, and they include everything you need to run Turicum programs.

To get an on-screen help type

  turi -h

after the installation.

== Maven Extension
== Java library

=== Design Goals and Philosophy

Turicum was designed with the following principles:

* A **concise syntax** that remains readable and expressive.
* A **functional-first** execution model with support for **side effects** when necessary.
* **Multithreading and pipeline constructs** are built directly into the language.
* **Safe scoping and closures**, including *reclosable* closures, which can adapt to new context bindings.
Closure reclosing is a unique feature of the language.
* **Macro-based metaprogramming**, allowing deferred and explicit evaluation of arguments.
* A flexible **parameter system**, supporting:
- `normal` parameters,
- positional-only,
- named-only,
- rest parameters (`[x]`),
- meta parameters (`+{x}+`),
- and trailing callable parameters (`^x`).

The language is intended for **experienced developers**, especially those working with the JVM, who require a powerful scripting or DSL tool that feels natural but scales to complex architectural needs.

=== Lexical and Syntax Conventions

Turicum syntax is clean, indentation-insensitive, and largely expression-oriented.
It does not aim to reinvent syntax, so it will feel familiar to programmers coming from Java, C, and—occasionally—Python.
At the same time, it avoids syntactically superfluous elements, such as mandatory parentheses `()` around `if` conditions, or loop header parts.

The core syntactic conventions are as follows:

* Semicolons (`;`) can be used to separate commands but are generally optional.
It is recommended to use semicolons to avoid ambiguity.
* Code blocks are enclosed in curly braces `+{}+` and evaluate to the result of the last executed command.
* Single-line comments begin with `//` and continue to the end of the line.
* Multiline comments start with `+/*+` and end with `*/`, like in Java, C, Go etc.
Unlike Java, nested multiline comments are supported.
* Identifiers follow conventional naming rules and are case-sensitive.
* Any string enclosed between backticks (`pass:[`]`) is treated as an identifier (similar to Kotlin).
* All keywords are lowercase.
* Strings enclosed in double quotes (`"`) must terminate on the same line.
Multiline strings are enclosed in triple double quotes (`"""`).
* String literals preceded with a `$` character are interpolated.


More details about expressions, control flow, and declarations can be found in the chapters that follow.

== Basic Concepts

A Turicum program is a list of commands, executed from start to end.


.source of snippet `first_sample`
[source]
----
print "Hello,";
println " World"
for i=1 ; i < 3 ; i = i+1 : println(i)


----




.output of snippet `first_sample`
[source]
----
Hello, World
1
2

----



A command is usually terminated by a semicolon (`;`).
A semicolon can sometimes be replaced by a newline at the end of a command.
Some commands explicitly require the use of `;`, like the `for` loop.

Commands can be grouped into blocks, enclosed in `+{+` and `+}+`.
Everything in Turicum has a value.
Even commands result in a value.
For example, an `if` statement returns the value of the executed command:

* the branch after the `if` condition,
* the `else` block if the condition is `false` and an `else` is present, or
* `none` if there is no `else` block.


.source of snippet `if_value`
[source]
----
mut z : num = {if 232 % 2 == 0 : 1 else: 2 }
println(z)


----




.output of snippet `if_value`
[source]
----
1

----



Command blocks can appear within expressions.
The value of a command block is the result of the last executed expression.


.source of snippet `block_value`
[source]
----
mut z = {
    mut k = "Hi";
    k + "cory"
    }
println(z)


----




.output of snippet `block_value`
[source]
----
Hicory

----



Expressions can contain:

* Literals:
** strings
** numbers
** JSON values
* Variables
* Operators (with precedences fixed)
* Function calls
* Closure calls
* Macro calls
* Method calls
* Async expressions
* Code blocks
* block commands enclosed between `+{+` and `+}+` or `(` and `)`.

Symbolic constants are `true`
// has the constant boolean __true__ value.
`false`
// has the constant boolean __false__ value.

`none`
// is the undefined value.
// The Java representation of the undefined value is `null`.

`inf`
// is the infinite numeric value.

`fini`
// is the special value that, when returned from a cell command, prevents the cell from updating
// but it also signals that this cell is stopped, should not be evaluated any further

`non_mutat`
// is the special value that, when returned from a cell command, prevents the cell from updating
// its value and halts propagation to dependent cells in a flow.

`nan`
// is the special IEEE-754 "not a number" floating-point value.

pinned (immutable, final) global variables.

==== Shebang

The interpreter ignores the first line of the program if it begins with `#!`.
This applies not only to the command line version but to all embeddings.
This helps use the same source code across any embedding on any operating system.

==== Whitespace and Line Breaks

Whitespace—including spaces, tabs, and line breaks—is generally insignificant, except where indentation aids readability.
Multiple blank lines are allowed between tokens and commands.
Line breaks alone do not terminate a command.

Whitespace terminates tokens, so `1 2` are two tokens, and `12` is one.

==== Identifiers

Identifiers are names used for variables, functions, classes, and other user-defined symbols.

* Identifiers must begin with a Unicode letter or an underscore (`_`), and can contain letters, digits, and underscores.

* You can explicitly define an identifier using backticks: `+`non-standard-id`+`.
This allows you to use any string as an identifier—even reserved words, symbols, or operators.
The primary use of this feature is to override operators, such as `+`==`+`.

* Identifiers are case-sensitive.

Some Unicode characters like `∞` (infinity) and `∅` (none) are automatically translated into meaningful identifiers (`inf`, `none`).

[NOTE]
====
Many languages allow operator overloading through specially named methods.
For example, in Python, you can override the `+` operator by defining a method named `pass:[__plus__]`.
Turicum does not require such special naming conventions.
You can simply define a method with the name `pass:[`+`]`.
====

==== Reserved Words

Turicum defines a set of reserved keywords that cannot be used as identifiers—unless the name is enclosed in backticks, like `if`.

The reserved keywords are:




`as`
`async`
`await`
`break`
`catch`
`class`
`continue`
`die`
`each`
`else`
`elseif`
`finally`
`flow`
`fn`
`for`
`global`
`if`
`in`
`let`
`list`
`mut`
`or`
`pin`
`print`
`println`
`return`
`try`
`until`
`when`
`while`
`with`
`yield`


== Expressions and Operators

=== Literals

Turicum supports a rich set of literals, including numeric values, strings, JSON-like constants, and lists.
All literals are expressions that evaluate to immutable values.

==== Numeric Literals

Numeric literals can be either integers or floating-point numbers.

* Integers are written as sequences of digits, e.g., `42`, `0`, `123456`.
* or in hexadecimal with `0x` prefix


.source of snippet `hexNumber`
[source]
----
mut z = 0xFfE3;
println z


----




.output of snippet `hexNumber`
[source]
----
65507

----



* Floating-point numbers contain a decimal point or exponent part, e.g., `3.14`, `2e10`, `1.0e-3`.

There is no special suffix for numeric types.
Type promotion is automatic and based on the context of usage.
The internal implementation of numerical types uses `Long` and `Double`.

There is no hexadecimal floating point literal like in Java.
Turicum does not implement a feature just because it is fancy.

==== String Literals

Strings in Turicum are enclosed in double quotes(`"`), e.g., ``"hello world"``.

Backslash escapes are supported:

* `\n` — newline
* `\t` — tab
* `\"` — double quote
* `\\` — backslash

Example:


.source of snippet `string`
[source]
----
print "this is a simple string"


----




.output of snippet `string`
[source]
----
this is a simple string
----



==== Multiline Strings

Multiline string literals are enclosed between triple quotes `pass["""]`.

They preserve line breaks and indentation exactly as written.
Escape sequences are still processed.

Example:

.source of snippet `mlstring`
[source]
----
println """
Hello,
  This is a multiline string.
Goodbye.
"""


----




.output of snippet `mlstring`
[source]
----

Hello,
  This is a multiline string.
Goodbye.


----



==== Interpolated Strings

A string literal starting with `$"` or `$"""` is interpolated every time it is used.
Interpolation means that the parts of the string enclosed between `${}` and `$()` are executed as command blocks and their result takes their place in the string.


.source of snippet `istring1`
[source]
----
let a = 3;
println $"a is ${a}"


----




.output of snippet `istring1`
[source]
----
a is 3

----



The blocks are executed in the same context as the string.
The `${}` being a wrapping block opens a new local context.
On the other hand, `$()` does not open a new local context.
That way any declaration inside the `$()` will happen in the surrounding context.


.source of snippet `istring2`
[source]
----
println $"define a, but local ${let a = 3}"
println $"define b, not local $(let b = 4)"
println "is a defined? ", if is_defined(a) : $"yes, it is ${a}" else: "no"
println "is b defined? ", if is_defined(b) : $"yes, it is ${b}" else: "no"


----




.output of snippet `istring2`
[source]
----
define a, but local 3
define b, not local 4
is a defined? no
is b defined? yes, it is 4

----




You can use any expression or Turicum command inside interpolated strings, but the following rules apply:

* Within the interpolated sections:
** From `${` to `+}+`
** From `$(` to `)`

* The number of opening and closing brackets must match:
** The number of `+{+` must equal the number of `+}+`
** The number of `(` must equal the number of `)`

This restriction is usually simple and should not affect your code in most cases.

However, in more complex scenarios—especially when you try to include string literals inside the interpolated parts—it can confuse the parser. That’s why the rule exists.

If you find this rule limiting, you are likely overcomplicating your usage of interpolation.

Prefer simpler expressions and commands within interpolated strings.

Here is a convoluted example that you have to avoid:


.source of snippet `istring3`
[source]
----
println $"${ $\"${6*6}\"}"


----




.output of snippet `istring3`
[source]
----
36

----



It's best to use simple, clear expressions and straightforward commands that avoid nested structures or embedded string literals.

[NOTE]
====
To implement string interpolation, we selected `${}` because it is
widely recognized and familiar from other languages such as JavaScript, Kotlin, and Bash.
It clearly delimits the interpolated expression and is easy to parse when balanced.
By using `${}`, Turicum allows embedding full expressions, including blocks, directly into strings.

Instead of making all strings implicitly interpolated when `${` appears, which would introduce
ambiguity and reduce readability, Turicum requires an explicit prefix. The character `$` was
chosen as the prefix for interpolated strings (e.g. `$"..."`) because:

- It is widely associated with interpolation (e.g., C#, PowerShell).
- It is not allowed as part of an identifier in Turicum, so there is no syntactic ambiguity.
- It is visually lightweight and avoids keyword clashes that might arise from using prefixes like `s`, `f`, or `t`.

Turicum extends the interpolation mechanism with two syntactic forms, each with distinct semantics:

- `+${expression}+` evaluates the given expression in a *new temporary context*. This is useful when
a local computation is needed that should not affect the surrounding environment.
- `+$(expression)+` evaluates the expression in the *surrounding context*, allowing modifications
(e.g., variable definition useing `let` or `mut`) to persist beyond the interpolated expression.

This dual syntax provides clarity and control over variable scope and side effects inside interpolated strings,
supporting both functional and imperative styles of expression.
====

==== JSON Constants

Turicum supports JSON-like literals directly in the language syntax. These can be written using JavaScript-style object and array literals:


.source of snippet `json1`
[source]
----
mut project = {
      name : "turicum-parent",
      packaging : "pom",
      groupId : "ch.turic",
      artifactId : "turicum-parent",
      version : "1.0.0-SNAPSHOT",
      description : "Turicum programming language",
      modules : [ "core", "maven", "cli" ]
      }
println project.name
println project.packaging


----




.output of snippet `json1`
[source]
----
turicum-parent
pom

----



JSON keys can be identifiers or strings.
The values can be presented by any Turicum expression.
The value of a JSON expression is a class-less Turicum object.
The values are evaluated when the literal is evaluated.

==== Lazy JSON

To defer the evaluation of a JSON literal until it is accessed, Turicum provides _lazy JSON_ literals.

These are written with a `+&+` prefix before the JSON object:


.source of snippet `lazy_json1`
[source]
----
fn get_name(){
    println "Getting name";
    "turicum-parent"
}
mut project = &{
      name : get_name(),
      packaging : "pom",
      groupId : "ch.turic",
      artifactId : "turicum-parent",
      version : "1.0.0-SNAPSHOT",
      description : "Turicum programming language",
      modules : [ "core", "maven", "cli" ]
      }
println project.name
println project.packaging
println project.name


----




.output of snippet `lazy_json1`
[source]
----
Getting name
turicum-parent
pom
Getting name
turicum-parent

----



Lazy JSON is not evaluated at definition time.
Each field is computed lazily, on demand, using the current execution context wrapping the context where the JSON was defined.
This behavior is similar to that of closures.

In the example above `get_name()` is only invoked if and when the field `name` is accessed.
However, it is called both times the field was accessed.
Lazy JSON objects are pinned, a.k.a. it is not possible to change any of their fields.

==== List Literals

Lists can be defined using square brackets `+[]+`.

List elements are expressions and are separated by commas:


.source of snippet `ListLiteral1`
[source]
----
mut computed = {fn(a,b) = a + b}(1,2);
println [1, 2, 3, 4]
println ["apple", "banana", "cherry"]
println [1 + 2, computed]


----




.output of snippet `ListLiteral1`
[source]
----
[1, 2, 3, 4]
[apple, banana, cherry]
[3, 3]

----



Lists are mutable by default and can be indexed using the `+[]+` operator.
They support iteration in `+for each+` loops.

Empty lists can be written simply as `+[]+`.

Lists can contain mixed types, but you are encouraged to use homogeneous lists for clarity.

List literals also support flattening other lists using the `..` prefix.
For example:


.source of snippet `ListLiteral2`
[source]
----
mut a = [1, 2, 3, 4]
mut b = ["apple", ..a, "banana", "cherry"]
println b


----




.output of snippet `ListLiteral2`
[source]
----
[apple, 1, 2, 3, 4, banana, cherry]

----



This is also the way to concatenate lists:


.source of snippet `ListLiteral3`
[source]
----
mut a = [1, 2, 3, 4]
mut b = [5, 6, 7]
println([..a, ..b])


----




.output of snippet `ListLiteral3`
[source]
----
[1, 2, 3, 4, 5, 6, 7]

----



The `pass:[+]`, `-` and `*` operators are also defined for lists.


.source of snippet `ListLiteral4`
[source]
----
mut a = [1, 2, 3, 4]
mut b = [1, 3]
println a,"+",b,"=", a+b
println a,"-",b,"=", a-b
println a,"*", b,"=", a*b
println a,"+\"sixteen\"=", a+"sixteen"
println a,"-",2,"=", a-2


----




.output of snippet `ListLiteral4`
[source]
----
[1, 2, 3, 4]+[1, 3]=[1, 2, 3, 4, 1, 3]
[1, 2, 3, 4]-[1, 3]=[2, 4]
[1, 2, 3, 4]*[1, 3]=[[1, 1], [1, 3], [2, 1], [2, 3], [3, 1], [3, 3], [4, 1], [4, 3]]
[1, 2, 3, 4]+"sixteen"=[1, 2, 3, 4, sixteen]
[1, 2, 3, 4]-2=[1, 3, 4]

----



The `pass:[+]` will concatenate the two lists, or append a single element to the list.
If you want to append a list to a list instead of concatenation, you have to enclose it into a list.


.source of snippet `ListLiteral5`
[source]
----
mut a = [1, 2, 3, 4]
mut b = [1, 3]
println a+[b]


----




.output of snippet `ListLiteral5`
[source]
----
[1, 2, 3, 4, [1, 3]]

----



The `-` will remove the elements from the list.

The operator `*` will create the Descartes product of the two lists.

If you want to remove a certain element or part of the list, you can compose a new list from the necessary parts:


.source of snippet `ListLiteral6`
[source]
----
mut a = [1, 2, 3, 4]
println [a[0],..a[2..inf]]


----




.output of snippet `ListLiteral6`
[source]
----
[1, 3, 4]

----



List literals also support filters and mappers.
For example:


.source of snippet `ListLiteral7`
[source]
----
mut a = [1, 2, 3, 4 ? {|x| x % 2 == 0 } ]
println a


----




.output of snippet `ListLiteral7`
[source]
----
[2, 4]

----



will select only the even elements from the list. The expression or closure following the `?` works as a filter.

You can also apply mappers following a `->`, for example:


.source of snippet `ListLiteral8`
[source]
----
mut a = [1, 2, 3, 4 ? {|x| x % 2 == 0 } -> {|z| return z/2 }]
println a


----




.output of snippet `ListLiteral8`
[source]
----
[1, 2]

----



selects only the even elements and divides each with two.
You can have multiple mappers and filters following each other mixed.

The mappers and the filters are usually closures and have one argument.
As a little syntactic sugar the variable `it` is defined when evaluating them.
It can save up using an argument:


.source of snippet `ListLiteral9`
[source]
----
mut a = [1, 2, 3, 4 ? {|| it % 2 == 0 } -> {|| return it/2 }]
println a


----




.output of snippet `ListLiteral9`
[source]
----
[1, 2]

----



To ease more the syntax, you can use ordinary expressions instead of closures:


.source of snippet `ListLiteral10`
[source]
----
mut a = [1, 2, 3, 4 ? it % 2 == 0  -> it/2 ]
println a


----




.output of snippet `ListLiteral10`
[source]
----
[1, 2]

----



This makes writing filters and mappers very easy.

.Some deep technical detail
[NOTE]
====
The closure definition `+{|x|x*2}+` is technically an expression.
Saying that the mappers and filters can be an expression OR a closure is a bit sloppy, because closures are also results of an expression.
What really happens is that the interpreter evaluates the expression, and if the result is a closure, then it will apply it.
In other cases it just uses the result of the expression.
In the case of filters, the value has to be something that can be interpreted as a boolean value.
In the case of mappers, the value of the expression is used as is.

How does the interpreter know that you want the closure to be evaluated and not use the closure itself as the new value?
Closures are just objects and can be in a list.

The answer is that it does not.
If it sees a closure as the result of the expression, it will evaluate it.

If you want to map a list element to a closure, then you have to write a closure that returns that closure you want to be the list element.
====

==== Operators and Symbols

The lexer recognizes both symbolic and word-based operators in expressions.
Operators are tokenized with priority for the **longest matching operator**.

Recognized symbols are:


"--", "++", "pass:[->]", "pass:[<-]", "(", ")", ",", ".", "?.",
"&{", "{", "}", "[", "]", ";", ":", "|", "?", "@", "^", "#", "**"

 

=== Field Access

Objects have fields that the code can set and read.
They are accessed

* using the `.` operator followed by the identifier of the field, or
* using the field identifier, as a string between `[`, and `]`.


.source of snippet `field_access`
[source]
----
let a = {}
a.k = 55
a["z"] = a["k"]
die if a.z != 55
println "it is ok"


----




.output of snippet `field_access`
[source]
----
it is ok

----



Creating new fields in an object requires less care than creating new variables.
You do not need to use the `let` or `mut` keyword to create a new field.
As soon as you assign a value to a field, it will be added to the object.

By default, fields are mutable, but you can pin them.
You cannot write `pin a.b`, however.
It would be a syntax error.
`pin` works on identifiers and not on expressions.

On the other hand, you can use the `pin` command inside the class functions, where the fields are a kind of local variables,
and you can also use the `with` command.

The following example demonstrates how the code can pin a field and leave another mutable:


.source of snippet `pinned_field`
[source]
----
class Car {
    fn init(power:num=125, color:str="red"){
        pin power
    }
    fn repaint(color:str){
        this.color = color
    }
}
let my_porsch = Car(power=467)
my_porsch.repaint("yellow")
try {
    with my_porsch {
        power = power + 100;
    }
}catch e : println "You cannot do home tuning on a porsch";
print $"The color of my porsch is ${my_porsch.color}"


----




.output of snippet `pinned_field`
[source]
----
You cannot do home tuning on a porsch
The color of my porsch is yellow
----



The following example gives you an example to pin a field of a classless object.


.source of snippet `pinned_field_with`
[source]
----
let a = {}
a.b = 13
with a : pin b
try{ a.b = 14 } catch e: println e
println a.b


----




.output of snippet `pinned_field_with`
[source]
----
pinned variable cannot be altered 'b'
13

----



The automatic creation of the fields is transitive.


.source of snippet `field_transitive_creation`
[source]
----
let a = {}
a.b.c.d.e.f = 1
println a


----




.output of snippet `field_transitive_creation`
[source]
----
{b: {c: {d: {e: {f: 1}}}}}

----



You do not need to create `b`,`c`,`d`, and `e` one by one.
They will become automatically an `+{}+` classless object.

Accessing a field on the right-hand side of an assignment, or in any expression is more restrictive.
You can still access a field that is nonexistent, and the value will be `none`, but you cannot access a field on `none`.
To overcome this, you can use the `or` operator as in the example, or use can use the `?.` field access.


.source of snippet `field_none_access`
[source]
----
let a  = {}
println $"is a.b defined? ${with a: is_defined(b)}"
try: let q = a.b.c
catch e: println e
// q is still undefined we can assign
let p = (a.b or {}).c
// the same, but shorter
let q = a.b?.c
println $"q is ${q}.. eventually, but at least exists..."
println $"a was not changed ${a}"


----




.output of snippet `field_none_access`
[source]
----
is a.b defined? false
Cannot access the field 'c' because the object it is used on is undefined.
q is none.. eventually, but at least exists...
a was not changed {}

----



In the example above we cannot directly access `a.b.c`, but `a.b?.c` works.
It is also important that accessing the non-existent `a.b` this way will *not* insert a new classless object into `a`.
It is just a lenient way of accessing fields.

On the left side of the `?.` can be any expression resulting in an object or `none`, even a `["xxx"]` style field access.
On the other hand, there is no `?.` equivalent accessing a field through the `["xxx"]`.
In that case the only remedy is the `or` operator:


.source of snippet `field_none_indexed_access`
[source]
----
let a  = {}
let q = (a["b"] or {}) ["c"]
println $"q is ${q}"


----




.output of snippet `field_none_indexed_access`
[source]
----
q is none

----



=== Defined Operators

Operators have precedence and are evaluated from left to right.
You can use `(` and `)` to change the evaluation order.
The operators are the following in order of growing precedence:

* `or` results the left side expression if it is defined and the right side if the left side value is `none` (undefined).
The operator does short-cut evaluation.
The right side is only evaluated if the left side is `none`.


.source of snippet `oror`
[source]
----
println none or 3


----




.output of snippet `oror`
[source]
----
3

----



* `||` logical OR operation, shortcut evaluated.
The example below demonstrates the shortcut evaluation, as it works and does not throw an exception:


.source of snippet `logical_or`
[source]
----
if (7&2) == 2 || 5/0 == inf {
    println "dandy"
}else{
    println "something is wrong"
}


----




.output of snippet `logical_or`
[source]
----
dandy

----



* `&&` logical AND operation, shortcut evaluated.
The example below demonstrates the shortcut evaluation, as it works and does not throw an exception:


.source of snippet `and`
[source]
----
if (7&2) == 3 && 5/0 == inf {
    println "something is wrong"
}else{
    println "dandy"
}


----




.output of snippet `and`
[source]
----
dandy

----


Note, that you cannot divide by zero, the result is an error and not `inf`.

* `..` range operator. `start..end`` will result a range to index a list.
The first index is `start`, the last is `end-1`.
Ranges can be used to index lists as values and also in left values to replace a part of a list.
When used as a unary prefix operator, it must be inside a list literal and in front of a list to flatten the list content into the literal.
+
It is also used to flatten objects or lists to function parameter passing.

* `|` bitwise OR operation.
+
The operator works the conventional ways on integers.
+
The operator is also defined for lists.
The result is the union of the two lists with the unique elements.
That way you can also create a "set" from a list `|`-ing it with an empty list, as in the example below:
+
+
The operator is further defined for objects. The result is a merged object that includes all fields from both operands.
If a field exists in both objects and is not itself an object, the value from the second object is used.
If the field values in both objects are objects, the result is their recursive merge using the `|` operation.
If the field values in both objects are lists, the result is the concatenation of those lists.


.source of snippet `bor1`
[source]
----
println 1 | 2
println( [1,1,2,3,3,2,1] | [])
println ( { a:1, b: 2, c: { h: 1, z:2} w: ["k","h","dr."] }
            | { a:11, b: 22, c: { k:7} , w : [1,2,3]} )
try:
    3.0 | 3.14
catch e: println e


----




.output of snippet `bor1`
[source]
----
3
[1, 2, 3]
{a: 11, b: 22, c: {h: 1, z: 2, k: 7}, w: [k, h, dr., 1, 2, 3]}
Cannot calculate '3.0' | '3.14'

----



You cannot `|` floating point numbers.

* `^` bitwise XOR operation for integer values and power in the case of double values.
It calculates the symmetric difference of lists (the concatenation of the two lists without the elements that appear in both).


.source of snippet `xor1`
[source]
----
println 12 ^ 2
println ?(12.0 ^ 2) or "does not work for floating points"
println( [1,2,3] ^ [3,4,5] )


----




.output of snippet `xor1`
[source]
----
14
does not work for floating points
[1, 2, 4, 5]

----



* `&` bitwise AND operation.
+
This operator behaves conventionally for integers.
+
It is also defined for lists, where it returns the intersection of the two lists, containing only unique elements.
+
The `+&+` operator is not defined for floating-point numbers.


.source of snippet `band1`
[source]
----
println 7 &  2
println [1,1,2,3,3,2,1] & [2, 3, 7]
try:
    3.0 & 3.14
catch e: println e


----




.output of snippet `band1`
[source]
----
2
[2, 3]
Cannot calculate '3.0' & '3.14'

----



* `===`, ==`, `!=`, `in` are "the same", equal, not equal, and part-of operators.
The `in` operator works on a list to check if an element is in that list,
or on strings to check the existence of a substring.


.source of snippet `equal1`
[source]
----
mut k = { a:1 , b:2 }
mut q = { a:1 , b:2 }
mut w = "ohmy"
println 1 == 1, " one is one"
println 1 == 2, " one is not two"
println 1 === 1, " one is the same as one"
println 1 === 2, " one is not the same as two"
println k == q, " k equals q, but"
println k === q, " k is not the same as q"
println w == "ohmy", " w is 'ohmy'"
println w === "ohmy", " w is not that 'ohmy'"


----




.output of snippet `equal1`
[source]
----
true one is one
false one is not two
true one is the same as one
false one is not the same as two
true k equals q, but
false k is not the same as q
true w is 'ohmy'
false w is not that 'ohmy'

----



The operator `===` tests that the two objects are the same.
Numerical values are compared by value, but all other objects are tested for being the same, even strings.

The `in` operation works for strings checking if a string is part of another, as well as for lists.


.source of snippet `inop`
[source]
----
println "raka" in "avraka dabra", " there is 'raka' in 'avraka dabra'"
println "raka" in "evreke debre", " there is no raka in 'evreke debre'"
println 3 in [1,2,3], " 3 is in [1,2,3]"
println 3 in [1,2,4], " 3 is not in [1,2,4]"


----




.output of snippet `inop`
[source]
----
true there is 'raka' in 'avraka dabra'
false there is no raka in 'evreke debre'
true 3 is in [1,2,3]
false 3 is not in [1,2,4]

----




* `<`, `+<=+`, `>`, `>=` usual size comparison operators.


.source of snippet `compare`
[source]
----
println 1 < 2
println 3 <= 3
println 4 > 3
println 4 >= 4


----




.output of snippet `compare`
[source]
----
true
true
true
true

----




* `<<`, `>>`, `>>>` left shift, right shift, and signed right shift operators.

The `>>` works also on strings and lists.
It merges the characters/elements of the two operands:


.source of snippet `shr1`
[source]
----
println 8>>2
println "artany" >> "...... ..."
println([1,2,3] >> [-1,-2,-3])


----




.output of snippet `shr1`
[source]
----
2
a.r.t.a.n.y. ...
[1, -1, 2, -2, 3, -3]

----




* `+`, `-` binary and unary plus and minus.

Unary `+` does not check anything, it works on all objects and just returns the object itself.


* `pass:[*]`, `/`, `%` binary multiply, divide, and remainder operators.
The `pass:[*]` and `%` are also used in the case of strings and lists.
A string multiplied by a number will result in the string that many times concatenated to itself.
The `%` operator is also used for formatting.
The left-hand side is the format string, and the right-hand side is a single element or list of elements.

In the case of lists `pass:[*]` will result in the Descartes product of the two lists.
You cannot `pass:[*]` a list and something else, like a number.

`%` for lists creates the symmetric difference, thus the elements of the two lists which are presented mutually only in one of them.
The following example shows the use of these operators and also the Turicum list literal filtered equivalent for the symmetric difference calculation.


.source of snippet `mod1`
[source]
----
println "2*3=%s" % [2*3]
println "2/3=%s" % [2/3]
println "2%%3=%s" % [2%3]
println "aa " * 6
println( [1,2] * [6])
println( [1,2,3] % [3,4,5] )
println( [1,2,3 ? it in [3,4,5]] )


----




.output of snippet `mod1`
[source]
----
2*3=6
2/3=0.6666666666666666
2%3=2
aa aa aa aa aa aa 
[[1, 6], [2, 6]]
[3]
[3]

----



.functions argument default values
[NOTE]
====
The bitwise OR `|` is not allowed in the expression specifying a default value for a function or closure argument.
You can however freely enclose the expression or a part of it between `(` and `)` and use the operator freely.
====

=== Pre-, and Post- Increment, and Decrement

Turicum implements the pre- and post-increment and decrement operators as assignments.
`pass:[a++]` or `pass:[a--]` are technically assignments that return the value of the variable before the modification.
Similarly `pass:[++a]` and `pass:[--a]` are assignments returning the value after the modification.

The expression analyzer recognizes and allows you to use pre-increment and pre-decrement operator in side an expression.
It is easy to recognize for the parser —and similarly for the programmer— reading the code that a `++` or `--` introduces a pre-increment/pre-decrement assignment.

On the other hand, a `++` or `--` after a complex left value may be hard to read.
For this reason the language permits the post-increment and post-decrement operators inside an expression only if it is applied on a simple variable left value.
If you want to apply a post-increment or a post-decrement operator on a field value or a list element, then you have to enclose it between `(` and `)`.


.source of snippet `incremento`
[source]
----
mut k = 3;
let z = k++; // valid it is only a variable
let w = ++k; // valid, it is only a variable

let x = [1,2,3]
x[0]++; // valid, it is a statement
// let h = x[0]++; it would not compile
let h = (x[0]++); // valid, there is a command between ( and )
// let t = ++x[0]; it would not compile
let t = (++x[0]); // valid again, enclosed


----




.output of snippet `incremento`
[source]
----

----



Although the increment and decrement operators are implemented as commands, they can be overloaded for objects.
If a class defines the method `pass:[`++`]` and/or `pass:[`--`]` it will be invoked when the program uses the pre- or post-increment or decrement operator.

The method should work on the object `this`, must have no argument, and should return the modified object.
It may be the same object or it may create a new object.
The examples show four implementations, two for increment and two for decrement.
One implementation in each pair treats the object immutable and returns a new object.
The other mutates the object and returns the modified object.

The example functionality is incrementing, decrementing a field, but the actual use can be anything.


.source of snippet `incrementable1`
[source]
----
class Incrementable {
    fn init(counter:num=0);

    fn `++`{
         Incrementable(counter+1)
    }

    fn p(name:str) {
        println name,": ",counter;
    }
}

mut h = Incrementable();
h.p("h original");
println "h id=%X" % id_hash(h);
let k = h++;
h.p("h after post increment");
k.p("k");
println "h id=%X" % id_hash(h);
println "k id=%X" % id_hash(k);
let z = ++h;
h.p("h after pre increment");
z.p("z")
println "h id=%X" % id_hash(h);
println "z id=%X" % id_hash(z);


----




.output of snippet `incrementable1`
[source]
----
h original: 0
h id=2E61D218
h after post increment: 1
k: 0
h id=3569FC08
k id=2E61D218
h after pre increment: 2
z: 2
h id=20B12F8A
z id=20B12F8A

----



You can track the different object instances using the hex output from the `id_hash` function.


.source of snippet `incrementable2`
[source]
----
class Incrementable {
    fn init(counter:num=0);

    fn `++`{
         counter++
         this
    }

    fn p(name:str) {
        println name,": ",counter;
    }
}

mut h = Incrementable();
h.p("h original");
println "h id=%X" % id_hash(h);
let k = h++;
h.p("h after post increment");
k.p("k");
println "h id=%X" % id_hash(h);
println "k id=%X" % id_hash(k);
let z = ++h;
h.p("h after pre increment");
z.p("z")
println "h id=%X" % id_hash(h);
println "z id=%X" % id_hash(z);


----




.output of snippet `incrementable2`
[source]
----
h original: 0
h id=7D42C224
h after post increment: 1
k: 1
h id=7D42C224
k id=7D42C224
h after pre increment: 2
z: 2
h id=7D42C224
z id=7D42C224

----



In this example the identity of the object remains the same, all the identity hex codes are the same.
There is only one object created.
It also means that there is not much difference between pre-, and post-increment.

The next two example implements the same functionality for the `--` operator.


.source of snippet `decrementable1`
[source]
----
class Decrementable {
    fn init(counter:num=0);

    fn `--`{
         Decrementable(counter-1)
    }

    fn p(name:str) {
        println name,": ",counter;
    }
}

mut h = Decrementable();
h.p("h original");
println "h id=%X" % id_hash(h);
let k = h--;
h.p("h after post decrement");
k.p("k");
println "h id=%X" % id_hash(h);
println "k id=%X" % id_hash(k);
let z = --h;
h.p("h after pre decrement");
z.p("z")
println "h id=%X" % id_hash(h);
println "z id=%X" % id_hash(z);


----




.output of snippet `decrementable1`
[source]
----
h original: 0
h id=522A32B1
h after post decrement: -1
k: 0
h id=5E01A982
k id=522A32B1
h after pre decrement: -2
z: -2
h id=5DDEA849
z id=5DDEA849

----



.source of snippet `decrementable2`
[source]
----
class Decrementable {
    fn init(counter:num=0);

    fn `--`{
         counter--
         this
    }

    fn p(name:str) {
        println name,": ",counter;
    }
}

mut h = Decrementable();
h.p("h original");
println "h id=%X" % id_hash(h);
let k = h--;
h.p("h after post decrement");
k.p("k");
println "h id=%X" % id_hash(h);
println "k id=%X" % id_hash(k);
let z = --h;
h.p("h after pre decrement");
z.p("z")
println "h id=%X" % id_hash(h);
println "z id=%X" % id_hash(z);


----




.output of snippet `decrementable2`
[source]
----
h original: 0
h id=3FB6CF60
h after post decrement: -1
k: -1
h id=3FB6CF60
k id=3FB6CF60
h after pre decrement: -2
z: -2
h id=3FB6CF60
z id=3FB6CF60

----



See also the next section about operator overloading.

=== Operator Overloading

Operators work for numerical types, string types as usually, and they can also work on any object that defines them.
The name of the method implementing the operator should be the operator itself.
There is not any name association, like in Python dunder plus.
Instead, you can use it, for example, `pass:[`+`]` as an operator identifier.

The operator methods must have one single positional argument, usually named `other`.
The functionality should implement the operation and return the result of "`this` operation `other`".
When an operation is used as prefix unary operator the value of other will be `none` and `this` will hold the value on the right of the operator.

Only `+`, `-`, `~`, `!`, `..`, `?` can be used as unary operators.

As mentioned above `+`, `-`, and `..` are binary as well as unary operators.

The unary operator `!` is logical negation.
The unary operator `~` is bitwise negation.
The unary operator `?` returns the original value without any modification or `none` if the calculation of the argument resulted in an error.
The original value can also be `none`.


.source of snippet `bnot`
[source]
----
println $"negating all bits in 3 ${~3}"
println $"!true is ${!true}"
println $"+13 is just ${+13}"
println $"-13 is just ${-(13)}"


----




.output of snippet `bnot`
[source]
----
negating all bits in 3 -4
!true is false
+13 is just 13
-13 is just -13

----



NOTE: The character `?` can have different meaning based on the context.
It can be part of conditional field access, when used as `a?.b` returning `none` when `a` is `none` or has no field `b`.
It can also signal the start of a filter in a list literal.

Operators can be overridden in the classes.
If you have a method named the same name as an operator, it will be invoked to perform the calculation.


.source of snippet `objectAddition1`
[source]
----
class LN {
    fn init( a ){

    }
    fn `+` ( other ){
            LN( this.a * other.a )
    }
}
println (LN(2) + LN(4)).a


----




.output of snippet `objectAddition1`
[source]
----
8

----



In the example above the class is redefining the `+` operator, and it returns an object that has the product of the fields `a`.
Thus `LN(2) + LN(4)` is `LN(8)`.

You can override any of the predefined operators.

When overriding the operator `==` the result has to be something that can be converted to boolean.


.source of snippet `myEqual`
[source]
----
class A {
  fn `==`(other) : bool {
    this.a == other.a
  }
}

mut x = A()
mut y = A()
mut z = { a: 1, b: "x" }

x.a = 1
x.b = "x"

y.a = 1
y.b = "y"

println "x == y is %s" % (x == y)
println "y == z is %s" % (y == z)


----




.output of snippet `myEqual`
[source]
----
x == y is true
y == z is true

----



Class `A` redefines the `==` operator to compare only the field `a`.
If there is a difference in other fields, the instances of the class are still the same.

The default implementation compares all the fields in the two objects, and it also checks that the two objects are instances of the same class.

In the example, all the objects are equal.

If we modify the equality check to consider the classes, we get a different result:


.source of snippet `myEqual2`
[source]
----
class A {
  fn `==`(other) : bool {
    return false if cls != other.cls
    a == other.a
  }
}

mut y = A()
mut z = { a: 1, b: "x" }

y.a = 1
y.b = "y"

println "y == z is %s" % (y == z)


----




.output of snippet `myEqual2`
[source]
----
y == z is false

----



=== Using parentheses


The different operators have their precedences as in most of the programming languages.

The operator's table is defined in the source file `BinaryExpressionAnalyzer.java`.


|===
|Precedence |Operators

|0
|or

|1
|`&#124;&#124;`

|2
|`&&`

|3
|`..`

|4
|`&#124;`

|5
|`^`

|6
|`&`

|7
|`===`, `==`, `!=`, `in`

|8
| `<`, `<=`, `>`, `>=`

|9
| `+`, `-`

| 10
| `*`, `/`, `%`, `**`

| 11
| `.`, `?.`
|===

The higher precedence operators are executed first, and the lower precedence operators are executed on the results.
When the order of the operator execution can be altered using parenthese.
This is a widespread practice in most programming languages.

The usual practice is that you can have a whole expression between `()` characters.
Turicum is more liberal and gives much more freedom to the developer.
You can have a whole code block between the `()` characters, similarly to `+{}+`.

The major difference between the two is that the code between `()` is executed in the same context as the expression, while the code block between `+{}+` opens a new context.


.source of snippet `pscope`
[source]
----

println "2*3=",2*(mut s=3)
println "s is defined and it is ",s
println "2*3=",2*{mut k=3}
try : mut h = 2*k
catch e : println e;


----




.output of snippet `pscope`
[source]
----
2*3=6
s is defined and it is 3
2*3=6
Variable 'k' is undefined.

----



Because not only every command is a value but also every expression is a command, you can use the `()` to group commands to be executed in the same context as the code environment.


== Variables and Context

Variables can be global or local.
They are defined in scopes.
Scopes are wrapped around each other.
The top level context is the global context.

Scopes are created in run-time, like everything in Turicum.

=== Block scopes

Code blocks open a new context, and they wrap the surrounding context.


.source of snippet `scope1`
[source]
----
mut z = "cory"
z = { // z is global
    println "just a print"
    mut k = "Hi" // k is local
         + z // z is accessible
    // the value of the block is the last command executed
    // 'mut' assignments result the value assigned
    }
println(z)
try:
    println(k)
catch err: println err


----




will output


.output of snippet `scope1`
[source]
----
just a print
Hicory
Variable 'k' is undefined.

----


The variable `k` is local inside the code block, and it has no value outside.
The variable `z` is part of the wrapped context, and in this case it is global.
The block executes in its own context, and this context wraps the global context.

You can nest scopes.

You can use a variable name defined in a wrapped (outer) context essentially hiding the outer variable, but only if you do not use the outer variable in the inner context.
You cannot refer to both in a context.
When you use a variable defined in a wrapped (outer) context, you cannot define it after that as local using `let` or `mut`.


.source of snippet `local_redefined_error`
[source]
----
mut z = 5
try{
    z = {
        println(z);
        mut z = 3
        }
}catch ex {
    println(ex)
}


----




will output:


.output of snippet `local_redefined_error`
[source]
----
5
Variable cannot be local, it is already used as non-local 'z'

----


=== Class, object and function context

Class declarations and functions do not wrap the surrounding context.
In the following example, modifying the global variable `glb` is not possible without declaration.
The class and the function do not wrap the surrounding, global context.


.source of snippet `function_scope`
[source]
----
mut glb = "global variable";
class A {
  fn z(){
    println("You can read glb, which is a " + glb)
    try{
       // you cannot change it without declaring that it is global
       glb = 5;
    }catch(e1){
        println("exception 1:",e1)
    }
    try{
       // you touched it as global, you cannot declare it as local anymore
       mut glb = 5;
    }catch(e2){
        println("exception 2:",e2)
    }
    global glb;
    glb = "modified"
    return "You can access glb here it is " + glb ;
  }
}
mut obj = A()
println(obj.z())


----




The output of the program is:


.output of snippet `function_scope`
[source]
----
You can read glb, which is a global variable
exception 1:Variable 'glb' is not defined.
You can access glb here it is modified

----


The methods, a.k.a. functions defined inside a class wrap the context of the class.
Whenever a method is called its own context is created and the "local variables" `cls` and `this` are created.
Unless the method is a constructor (named aptly as `constructor`) these variables are pinned, cannot be changed.

Code inside a class, outside any method is executed when the class is defined.


.source of snippet `class_definition`
[source]
----
class X {
  mut s = "hu"
}
println("class var ", X.s)
mut x = X();
println("object var ", x.s)


----




The code above defines a class named `X`.
This class has a class context variable `s`.
It can be accessed as a field of the class itself `X.s`.

Variable `x` is initialized to hold an instance of this class.
Using `x.s` will reference the same variable, because objects wrap the context of the class.


.output of snippet `class_definition`
[source]
----
class var hu
object var hu

----


The following example details these different access scenarios:


.source of snippet `object_scope`
[source]
----
class X {
  mut s = "class field"
  cls.h = "another class field"
  fn constructor {
    mut g = "object field"
  }
  fn t(){
    // access object field explicitly through 'this'
    println("this.g=",this.g)
    // the object wraps the class scope and not the other way around
    // there is no 'g' defined in the class
    try: println("cls.g=",cls.g) catch err1: println err1
    // 'g' is in the wrapped scope of the object scope
    // this is same as 'this.g'
    try: println("g=",g) catch err2: println err2
    // 'this.h' is the same as 'cls.h' because of wrapping
    println("this.h=",this.h)
    println("cls.h=",cls.h)
    println("h=",h)
    // the same is true for the other field
    // does not matter how it was defined
    println("this.s=",this.s)
    println("cls.s=",cls.s)
    println("s=",s)
  }
}
mut x = X();
x.t()


----





.output of snippet `object_scope`
[source]
----
this.g=none
cls.g=none
g=Variable 'g' is undefined.
this.h=another class field
cls.h=another class field
h=another class field
this.s=class field
cls.s=class field
s=class field

----


=== Closure scopes

Closures are blocks with arguments.
The general syntax is:

[source]
----
  {|arguments declaration| commands}
----

Note that executing a closure and calling a closure are two different things.
When the closure command definition is executed, it returns the closure.
When a closure is called, the arguments are evaluated in the actual context, and the closure is called in its context.
The context of the closure does not wrap the context of the caller.
It does wrap the context of the definition, where we created the closure.

Technically functions are closures that do not wrap their definition contexts.

In the following example, the closure can access and even modify the variable `whom` inside a block.


.source of snippet `closure_example`
[source]
----
mut c = {
    mut whom = "World!";
    {|greeting|
        println(greeting,whom);
        whom = "Universe!"
    }
}
c("Hello, ")
c("Hi, ")


----




.output of snippet `closure_example`
[source]
----
Hello, World!
Hi, Universe!

----



The variable `whom` lives only inside the block.
The closure wraps this context and keeps the variable alive so long as long the closure is there and also modifies the content of the variable.

[NOTE]
====
The closure arguments follow the same syntax as the function arguments.
There is however, a small difference.

When a closure argument list defines types and alternatives for the types, how does the parser know that the `|` is separating different types or close the closure argument list.
For example, in the next example

  {|a:str| "*" + a + "*" }

`a:str|` could continue with alternative types, like `a:str|any`.
The syntax analyzer looks ahead a few tokens, and in the case of closures it treats the `|` as a type alternatives separator if

* the next token after it is an identifier and after that another `|`, a `=`, or `,` follows, or
* the next token is `(`.

This analysis is heuristic and can cause issue.
To avoid those:

* Do not start the first command of the closure with `(` if the closure's last argument has type.

====

=== Macro scopes

macro scopes are the same as closure scopes.
Macros are closures that get their arguments unevaluated.
You can create a macro using the built-in global function `macro` with a closure or function as an argument.
Code inside macros can call the global function `evaluate` on the arguments.

This way macros can decide which arguments to evaluate and what order, or how many times.
The following simple macro reimplements the `if` command's functionality using it:


.source of snippet `macro_example`
[source]
----
mut c = macro(
    {|condition,then,`else`|
        if evaluate(condition) : evaluate(then) else: evaluate(`else`)
    })

print(

    c(true,"yes, it is true",{ println("this will never be printed") })

    );


----




.output of snippet `macro_example`
[source]
----
yes, it is true
----



When a macro calls the function `evaluate` the evaluation happens in the caller context.
This ensures the same context and variable visibility like calling a function or closure.
The caller does not need to know that the implementation of the something it calls is a function, closure, or macro.

=== Variable Declaration

Upon first assignment the code has to use the keyword `let` or `mut` to define the variable.
Until that happens, you cannot use a variable.

Variables defined using the keyword `let` are not mutable.
Variables defined using the keyword `mut` are mutable.
Mutable variables can be pinned, made immutable any time using the `pin` command.
Immutable variables remain immutable forever.

You cannot read an undefined variable.
If a variable is not defined, it will throw an exception.

NOTE: There is a subtle difference between an undefined variable and a defined variable having the value `none`.
An undefined variable was never defined.
An already defined variable can have the value of `none`, and it can also have type declaration.
Also, you can assign values to object fields without the `let` keyword, even to define them.

The syntax of a `let` and `mut` command is the following:

[source]
----
let identifier:type = expression
mut identifier:type = expression
----

or

[source]
----
let {identifier:type , ... } = expression
mut {identifier:type , ... } = expression
----

or

[source]
----
let [identifier:type ...] = expression
mut [identifier:type ...] = expression
----

In the first version you assign a value to an identifier and optionally define the type.
If the type is defined, only values that match the type can be assigned to the variable.
Type is one of the predefined types or the name of the class or a java object type.
You can specify multiple types separated using `|` character.

Note that if you do not define an expression, but you define a type that is not `any` or `none` then you should also specify `|none` as an alternative, because the initial value will be `none`.

The `: type` and the `= expression` parts are optional.
If the type is not defined, then the variable can get any value.
If the expression is missing the value will be `none`, but the variable becomes defined.
There can be multiple `identifier: type = expression` after the `let` keyword comma separated.
There are predefined type names.

* `bool`
 boolean type
* `str`
 string
* `num`
 any numeric type, integer or float
* `float`
 float type
* `any`
 the variable can hold any value
* `obj`
 the variable can hols any object without restriction on the class of that object
* `lst`
 the variable has to be a list
* `que`
 the variable has to be a queue
* `task`
 the variable has to be an asynchronous task
* `err`
 the variable has to be an asynchronous task
* `cls`
 the variable has to be a class
* `fn`
 the variable value has to be a function of closure
* `macro`
 the variable value has to be a macro
* `none`
 the variable can hold the value `none`
* `some`
 the variable can hold any value, except `none`



If the name starts with `java.`, then the variable can hold a Java object.
For example, `java.java.math.BigInteger` can hold any `java.math.BigInteger` object.

In other cases the type can be the name of a class defined in the program.
The class has to be defined by the time the variable is defined.

If the name of the type is specified between `(` and `)` then the expression between the parentheses is evaluated and the string value is used as a type name.

[NOTE]
====
Note that a variable can hold `none` only if

* there is no type defined,

* `none` is among the allowed types, or

* `any` is among the allowed types.

For example, `let a:num;` will fail, because it allows only numerical values, but missing the initial value will try to set it to `none`.
====

You can define multiple types for a variable separating the types with `|`. For example `let a:num|str|myClass` makes `a` eligible to store a numeric value, a string or an instance of `MyClass`.

The following example declares a variable that can hold a string or a numeric value.


.source of snippet `let_with_types_example`
[source]
----
mut c : str |num = 3;
c = "" + c + " == " + c
println(c)


----




.output of snippet `let_with_types_example`
[source]
----
3 == 3

----



If you use the format `let { identifier list } = expression` then the identifiers are not followed by expressions individually.
Instead, the expression after the `=` is evaluated once, used as an object and the fields are assigned to the variables of the same name on the left side.


.source of snippet `flat_let_object1`
[source]
----

mut z = { a: "apple", b:"bier", c : "count" }
mut {a, b, c} = z
println a
println b
println c


----




.output of snippet `flat_let_object1`
[source]
----
apple
bier
count

----



It is not an error if there are fields in the object not read during the assignment and also if some of the variables do not have matching fields.


.source of snippet `flat_let_object2`
[source]
----

mut z = { a: "apple", b:"bier", c : "count" , d: "not used" }
mut {a, b, c, f} = z
println a
println b
println c
println f


----




.output of snippet `flat_let_object2`
[source]
----
apple
bier
count
none

----



If you use the format `let [ identifier list ] = expression` then the identifiers are not followed by expressions individually.
Instead, the expression after the `=` is evaluated once, used as a list and the elements are assigned to the variables.


.source of snippet `flat_let_list1`
[source]
----
mut [a, b, c] = [1,2,3]
println a
println b
println c


----




.output of snippet `flat_let_list1`
[source]
----
1
2
3

----



It is an error if there are not enough or too many elements in the list on the right-hand side.


.source of snippet `flat_let_list2`
[source]
----
try:
    mut [a, b, c, f] = [1,2,3]
catch err: println err


----




.output of snippet `flat_let_list2`
[source]
----
[multi-let] assignment right hand side has too few values

----




.source of snippet `flat_let_list3`
[source]
----
try:
    mut [a, b] = [1,2,3]
catch err: println err


----




.output of snippet `flat_let_list3`
[source]
----
[multi-let] assignment right hand side has too many values

----



If you have too many elements, you can cut the list:


.source of snippet `flat_let_list4`
[source]
----
mut [a, b] = [1,2,3,4,5,6,7,8][0..2]
println a
println b


----




.output of snippet `flat_let_list4`
[source]
----
1
2

----



If you have too few you can extend the list:


.source of snippet `flat_let_list5`
[source]
----
fn adjust(_x, @to){
    mut x = _x
    if len(x) < to :
        while len(x) < to :
            x = [..x, none]
    else :
        x = x[0..len(x)]
    x
}
mut [a, b, c, d] = adjust(to=4,[1,2])
println a
println b
println c
println d


----




.output of snippet `flat_let_list5`
[source]
----
1
2
none
none

----



or even


.source of snippet `flat_let_list6`
[source]
----
fn adjust(@to,[_x]){
    mut x = _x
    if len(x) < to :
        while len(x) < to :
            x = [..x, none]
    else :
        x = x[0..len(x)]
    x
}
mut [a, b, c, d] = adjust(to=4, 1,2)
println a
println b
println c
println d


----




.output of snippet `flat_let_list6`
[source]
----
1
2
none
none

----



==== Updating a Variable

Mutable variables can get new value any time.
The assignment that updates a variable does not have the `let` or `mut` keyword and does not define a type.
The syntax is

[source]
----
LEFT_VALUE ASSIGNMENT_OPERATOR EXPRESSION
----

which is simply loks like `a = 5*3` in most of the cases.
The left value can be

* a variable identifier, (`my_variable`)
* object field access, (`object.field`)
* list element access, (`list[index]`).

The `ASSIGNMENT_OPERATOR` can be

`=`,`+=`,`-=`,`*=`,`/=`,`%=`,`&=`,`|=`,`^=`,`pass:[**]=`,`or=`,`&&=`,`||=`,`pass:[<<=]`,`>>=`,`>>>=`,

The `=` is the usual assignment.
It calculates the expression on the right side and replaces the current value of the variable with the new value.
The other assignments do three steps:

. Calculate the current value of the left value.
. Execute the operator that stands before the `=` sign applying it on the left value and the expression.
. Update the left value with the new value.

[NOTE]
====
The operations are responsible for evaluating the operands, and they may decide not to.
For example, the `or` operation evaluates the right-hand side only if the left-hand side is `none`.
They work on commands and not already calculated values.

To accommodate this, the evaluation of the left value creates a temporary command.
This temporary command returns the current value of the left value when evaluated.
====


.source of snippet `assign_calculate`
[source]
----
mut z = 3
println "z=",z
z += 1;
println "z +=1 :",z
z -= 1;
println "z -=1 :",z
z *= 4;
println "z *=4 :",z
z /= 2;
println "z /=2 :",z
z %= 5;
println "z %=5 :",z
z |=128;
println "z |=128 :",z
z &= 7;
println "z &=0x7F :",z
z ^= 0xFF;
println "z ^=0xFF :",z
z **= 2;
println "z **=2 :",z
z or= inf;
println "z or=inf :",z
z <<= 2
println "z <<=2 :",z
z >>=2
println "z >>=2 :",z
z >>>=2
println "z >>>=2 :",z
z >>>=2
println "z >>>=2 :",z
z >>>=2
println "z >>>=2 :",z
z >>>=2
println "z >>>=2 :",z
z >>>=2
println "z >>>=2 :",z
z >>>=2
println "z >>>=2 :",z
z >>>=2
println "z >>>=2 :",z
z >>>=2
println "z >>>=2 :",z

mut b = true
println "b=",b
b &&= false;
println "b &&=false :",b
b ||= true;
println "b ||=true :",b


----




.output of snippet `assign_calculate`
[source]
----
z=3
z +=1 :4
z -=1 :3
z *=4 :12
z /=2 :6
z %=5 :1
z |=128 :129
z &=0x7F :1
z ^=0xFF :254
z **=2 :64516
z or=inf :64516
z <<=2 :258064
z >>=2 :64516
z >>>=2 :16129
z >>>=2 :4032
z >>>=2 :1008
z >>>=2 :252
z >>>=2 :63
z >>>=2 :15
z >>>=2 :3
z >>>=2 :0
b=true
b &&=false :false
b ||=true :true

----




==== Pinned Variables

Pinning a variable makes it illegal to change it in the context.
The syntax of the `pin` command is

[source]
----
  pin list
----

The list is comma separated elements, can be

* a variable name, like `turic`,

* a variable name enclosed between `+{+` and `+}+`, like `+{object}+`, or

* a variable name enclosed between `[` and `]`, like `[list]`.

A variable in the list will make the variable in the current context pinned.
If the variable name is decorated with `+{}+` then the object, which is the value of the variable gets pinned.
Note that this is changing the mutability of the object itself and not the variable.


.source of snippet `pin_object`
[source]
----
let a = {a:1, b:2};
pin {a};

try: a.k = 13 catch e: println e



----




.output of snippet `pin_object`
[source]
----
You cannot change a pinned object

----



If the variable name is decorated with `[]` then the list, which is the value of the variable gets pinned.
Note that this is changing the mutability of the list itself and not the variable.


.source of snippet `pin_list`
[source]
----
let a = [1,2,3,4];
pin [a];

try: a[0] = 13 catch e: println e


----




.output of snippet `pin_list`
[source]
----
Cannot change a pinned list.

----



It is an error using the decoration on a variable that is not an object or list.


.source of snippet `pin_wrong`
[source]
----
let a = [1,2,3,4];
try: pin {a}; catch e1: println e1
let b = {a:1, b:2, c:3}
try: pin [b]; catch e2: println e2


----




.output of snippet `pin_wrong`
[source]
----
value of 'a' is not an object to be pinned
value of 'b' is not a list to be pinned

----



The following example demonstrates the different pinning possibilities:


.source of snippet `pinning`
[source]
----
mut turicum = 13
mut `list` = [1,2,3]
mut object = { x:1, y:2};
pin turicum, [`list`], {object}

try {
  turicum = 14;
}catch e1: println("could not change the variable")

try {
  `list`[1] = 0;
}catch e2: println("could not change the `list`")
`list` = [ 0, ..`list`, 4]
println("variable 'list' still can be changed: ", `list`)

try {
  object.x = 3;
}catch e3: println("could not change the object")
object = { x:1, y:3 }
println("variable 'object' still can be changed: ", object)



----




.output of snippet `pinning`
[source]
----
could not change the variable
could not change the `list`
variable 'list' still can be changed: [0, 1, 2, 3, 4]
could not change the object
variable 'object' still can be changed: {x: 1, y: 3}

----



== `print`, `println` commands

`print` and `println` are implemented as commands.
They both accept a list of expressions separated by commas.
`print` prints out the values from left to right.
`println` does the same, but also appends a new line character at the end.

By default, the output goes to the standard output using the Java `System.out` static field.

The output of `print` and `println` can also be redirected.
If the variable `+print_target+` is defined and is an object or closure the output of the statements will be redirected.

When the `+print_target+` is an object the method `+write+` is used to send the strings and
`+flush+` is called to close every print statement.
`+write+` has to be defined, `+flush+` is optional, but when defined it has to be a method.

When the `+print_target+` is a closure it is used to send the strings and flushing is ignored.

The following example shows how to use this feature:


.source of snippet `print_redirect`
[source]
----
class Printer {
    fn init(m:str="");
    fn write(s:str){
        if !len(m) == 0 && !m.ends_with("\n"):
            m = m + " "
        m = m + s;
    }
    fn flush {
        println "flushing is essential"
    }
    fn entry {
        this
    }
    fn exit(e){
    }

    fn get {
        m
    }
}


let printer = Printer();

with printer as print_target {
    println "Once upon a midnight dreary","Edgar"
    println "God in his wisdom made the fly","Ogden"
    }
println "Are you mental mixing poems?"
println printer.get()

{
mut print_target = {|message:str|
                        let print_target = none;
                        if message == "\n" :
                            println ;
                        print "Said the raven:", message;
                        }
println "never more, to the fly";
}


----




.output of snippet `print_redirect`
[source]
----
flushing is essential
flushing is essential
Are you mental mixing poems?
Once upon a midnight drearyEdgar
God in his wisdom made the flyOgden

Said the raven:never more, to the fly
Said the raven:

----




== Control Flow

=== Conditional Execution (`if` / `elseif` / else`)

Command `if` is very conventional and similar to any other programming language.
The syntax of the command is:

[source]
----
'if' EXPRESSION ( ':' COMMAND | BLOCK ) [ 'else' ( ':' COMMAND | BLOCK )] ;
----

If the expression is `true` the command executes the first command or block.
If the expression is `false` it executes the second command or block following the `else` keyword.
The second command or block along with the keyword `else` is optional.

The block is a series of commands enclosed between `+{+` and `+}+`.
If there is only a single command after the condition or the keyword `else` it can be preceded with a `:`, or enclosed in a block.

The conditional expression can, but does not need to be enclosed between parentheses.

The result of the command is the value of the command or block executed.
If the condition is `false` and there is no "else" block or command, then the result is `none`.


.source of snippet `ifCommand`
[source]
----
mut a= 13
if a%2 == 0: println("even") else: println("odd")
a = {if a%2 == 0: "even" else: "odd"}
print("again ",a)


----




.output of snippet `ifCommand`
[source]
----
odd
again odd
----



The `if` command does not open a new context.
The condition, and the commands following it, and the optional one after the `else` keyword evaluated and executed in the context the `if` statement is.

If, however, the "then" or "else" commands are block commands, then they themselves execute in a new context wrapping the actual context.

=== Loops

There are three types of loops in Turicum:

* `while`

* `for`

* `for each` loop.

Loops, like any command, have a result value.
The value of a loop is either the last executed command or a list of the last executed command for each iteration.
If the loop is skipped then the value is either `none` or an empty list.


.source of snippet `emptyLoopResult`
[source]
----
println { for i=0 ; i < 0 ; i=i+1 : "anything, not executed, will print none" }
println { for i=0 ; i < 0 ; i=i+1 list: "anything, not executed, will print []" }


----




.output of snippet `emptyLoopResult`
[source]
----
none
[]

----



==== `while`

A while loop is front and tail conditioned.
The front condition, following the keyword `while` is checked before each execution of the loop body.
The body of the loop will only be executed if the front condition is `true`.

The tail condition is optional, and follows the body of the loop with the `until` keyword.
It is checked after the execution of the loop body.
Execution of the loop stops when the tail condition is `true`.


.source of snippet `whileLoop`
[source]
----
mut i = 1;
while i < 5 {
  print(i," ");
  i++;
}until i % 3 == 0;


----




.output of snippet `whileLoop`
[source]
----
1 2 
----



The body of the loop can be a command block, or it can be a single command.
If the body is a single command, not enclosed between `+{+` and `+}+` it has to be preceded by a `:`.


.source of snippet `whileLoop2`
[source]
----
 mut i = 1;
while i < 5 :
  i++;
until i % 3 == 0;
println(i)


----




.output of snippet `whileLoop2`
[source]
----
3

----



The value of the loop is the result of the last executed command.


.source of snippet `while_result`
[source]
----
println {
    mut k = 0
    while k < 10 : k++
}


----




.output of snippet `while_result`
[source]
----
9

----



The loop can also be used to result a list.
The list will contain the results of each body loop execution.


.source of snippet `while_list`
[source]
----
mut k = 0;
println{ while k < 5 list{
            mut h = k;
            k++;
            h
         }
}


----




.output of snippet `while_list`
[source]
----
[0, 1, 2, 3, 4]

----



To get the list as a result, you have to write the `list` keyword in front of the loop body.

[NOTE]
====

When a loop executes, two distinct contexts are used: an *outer context* and an *inner context*.

* The *outer context* is created before the loop begins and is discarded after the loop ends.
* The *inner context* is created freshly for each execution of the loop body and is discarded immediately after that execution completes.

The outer context *wraps* the surrounding scopes, and the inner context *wraps* the outer context. This means that both contexts have access to all variables defined in the surrounding code. Additionally, the inner context can read and modify variables from the outer context and the scopes it wraps. However, *new variables defined in the inner context do not propagate into the outer context*.

* The *head condition* following the `+while+` keyword is evaluated in the outer context.

* The *loop body* and the *exit condition* following the `+until+` keyword are evaluated in the inner context.

This design ensures that each iteration of the loop starts in a clean environment. Variables defined inside a previous iteration are *not available* in the next iteration, unless explicitly defined in the outer context. This approach avoids unintended side effects and provides a clear and consistent model for variable visibility and lifecycle within loops.
====

==== `for`

The `for` loop is very much similar to the conventional `for` loop we have since it was invented in the language C.
There are some syntactical and some execution differences though.

The syntactical difference is that the start, condition, and end steps do not need to be enclosed between `(` and `)`.
The start, condition, and end parts are separated by `;` and they are commands.
The `;` in this place is not optional.


.source of snippet `for1`
[source]
----
for i = 1 ; i < 5 ; i=i+1 {
  print(i," ")
}until i%3 == 0 ;


----




.output of snippet `for1`
[source]
----
1 2 3 
----



The semantic difference is that you cannot alter the loop variable, or variables if there are multiple inside the loop.


.source of snippet `for5`
[source]
----
mut i;
for i = 1 ; i < 3 ; i=i+1 {
    try: i++
    catch e: println "not possible to change loop variable in the loop it remained ",i
}



----




.output of snippet `for5`
[source]
----
not possible to change loop variable in the loop it remained 1
not possible to change loop variable in the loop it remained 2

----



The `for` loop also has an optional `until` part the same way as `while`.
The next example shows the same loop with the optional parentheses but without the tail condition.


.source of snippet `for2`
[source]
----
for( i = 1 ; i < 5 ; i=i+1 ){
  print(i," ")
}


----




.output of snippet `for2`
[source]
----
1 2 3 4 
----



If the start command is an assignment, it is interpreted as a local assignment.


.source of snippet `for3`
[source]
----
// same as 'for( mut i = 1 ;' ...
for( i = 1 ; i < 5 ; i=i+1 ){
  print(i," ")
}until i%3 == 0 ;
try:
    println("i at end=",i);
catch err { println(); println err ; }


----




.output of snippet `for3`
[source]
----
1 2 3 i at end=
Variable 'i' is undefined.

----



The variable `i` after the loop is still undefined.
To use a variable from the enclosing wrapped context, you can enclose the assignment into a block.


.source of snippet `for4`
[source]
----
mut i;
for {i = 1} ; i < 5 ; i=i+1 :  print(i," "); until i%3 == 0;
println("i at end=",i);


----




.output of snippet `for4`
[source]
----
1 2 3 i at end=3

----



In this last example we also use a single command as the body of the loop.
In this case the command is preceded by a `:` character.

The value of the loop is the result of the last executed command.


.source of snippet `for_result`
[source]
----
println {
    mut k = 0
    for ; k < 10 ; : k++
}


----




.output of snippet `for_result`
[source]
----
9

----



The loop can also be used to result a list.
The list will contain the results of each body loop execution.


.source of snippet `for_list`
[source]
----
println {for i=0; i < 10 ; i++ list: i}


----




.output of snippet `for_list`
[source]
----
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

----



To get the list as a result, you have to write the `list` keyword in front of the loop body.

[NOTE]
====

When a loop executes, two distinct contexts are used: an *outer context* and an *inner context*.

* The *outer context* is created before the loop begins and is discarded after the loop ends.
* The *inner context* is created freshly for each execution of the loop body and is discarded immediately after that execution completes.

The outer context *wraps* the surrounding scopes, and the inner context *wraps* the outer context. This means that both contexts have access to all variables defined in the surrounding code. Additionally, the inner context can read and modify variables from the outer context and the scopes it wraps. However, *new variables defined in the inner context do not propagate into the outer context*.

* The *start*, *condition*, and *step* expressions in the `+for+` loop header are evaluated in the outer context.

* The *loop body* and the *exit condition* following the `+until+` keyword are evaluated in the inner context.

This design ensures that each iteration of the loop starts in a clean environment. Variables defined inside a previous iteration are *not available* in the next iteration, unless explicitly defined in the outer context. This approach avoids unintended side effects and provides a clear and consistent model for variable visibility and lifecycle within loops.
====

==== `for each`

The command `for each` iterates through a list


.source of snippet `foreach1`
[source]
----
for each i in [1,2,3,4]: print(i," ");


----




.output of snippet `foreach1`
[source]
----
1 2 3 4 
----



The `for each` loop can also have a tail condition.


.source of snippet `foreach2`
[source]
----
for each i ∈ [1,2,3,4]: print(i," "); until i%3 == 0


----




.output of snippet `foreach2`
[source]
----
1 2 3 
----



You can also define an index variable following the `with` keyword.


.source of snippet `foreach3`
[source]
----
for each z with i in ["apple", "banana", "orange", "peach"] {
    println "%s. %s" % [i,z]
}


----




.output of snippet `foreach3`
[source]
----
0. apple
1. banana
2. orange
3. peach

----



The index starts from zero and increments with each execution by one.
The index variable is local to the loop.
Without this feature you would need to declare a variable one context higher and then use it in the loop.
That would violate the locality principle, not to rely on anything out of a context that can change and even less modify anything out of the context, which is in this case a loop.

When used in an expression position, a `for each` loop returns the result of the last executed loop body.


.source of snippet `for_each_result`
[source]
----
println {
    for each t with i in [1,2,3] : t + 10*i
}


----




.output of snippet `for_each_result`
[source]
----
23

----



The loop can also return a list: to do so, use the `list` keyword before the loop body.
The result will include the result of each iteration.


.source of snippet `for_each_list`
[source]
----
println {
    for each z with i in [1,2,3] list { 10*i + z }
    }


----




.output of snippet `for_each_list`
[source]
----
[1, 12, 23]

----



To get the list as a result, you have to write the `list` keyword in front of the loop body.

[NOTE]
====

When a loop executes, two distinct contexts are used: an *outer context* and an *inner context*.

* The *outer context* is created before the loop begins and is discarded after the loop ends.
* The *inner context* is created freshly for each execution of the loop body and is discarded immediately after that execution completes.

The outer context *wraps* the surrounding scopes, and the inner context *wraps* the outer context. This means that both contexts have access to all variables defined in the surrounding code. Additionally, the inner context can read and modify variables from the outer context and the scopes it wraps. However, *new variables defined in the inner context do not propagate into the outer context*.

* The *list* is evaluated only once in the outer context.
* The loop variable and the optional loop counter are part of the inner context, but they are pinned.
Pinned variables cannot be modified.

* The *loop body* and the *exit condition* following the `+until+` keyword are evaluated in the inner context.

This design ensures that each iteration of the loop starts in a clean environment. Variables defined inside a previous iteration are *not available* in the next iteration, unless explicitly defined in the outer context. This approach avoids unintended side effects and provides a clear and consistent model for variable visibility and lifecycle within loops.
====

==== `break`

The command can break the execution of the loop and can also specify the value of the loop.

==== `continue`

Will continue the execution of the loop starting the body of the loop again without executing the rest of the commands in the loop body.


=== Returning, Breaking, Continue, and Yielding

These three commands are in one family.
each of them can pass a value, and each can have a conditionality following the expression.
The syntax is

[source]
----
break [expression] [if condition]
return [expression] [if condition]
yield expression [if condition]
----

The expression and the `if condition` parts are optional, except for the `yield`.
When the conditional part is missing, the command is executed like if it was `if true`.

You can interchangeably use the `when` keyword instead of `if` in this case.

==== `break`

The command `break` stops the execution of a loop.
If it is executed, the value of the loop will be the expression that follows the command.
If it is missing then the value `none` will be the result.

There is a slight difference between not having an expression or having an expression returning `none`.
When the `break` command is used in a lis-resulting loop and there is an expression following the `break` keyword the value of this expression will be appended to the list as the last value.
When there is no expression, then the execution of the loop still terminates, but no expression will be appended to the result list.

The following samples demonstrate these cases.


.source of snippet `break1`
[source]
----
println {
    for i=0 ; i < 10 ; i++ {
      println ".. ",i;
      break if i == 2
    }
}


----




.output of snippet `break1`
[source]
----
.. 0
.. 1
.. 2
none

----




.source of snippet `break2`
[source]
----
println {
    for i=0 ; i < 10 ; i++ {
      println ".. ",i;
      break -2 if i == 2
    }
}


----




.output of snippet `break2`
[source]
----
.. 0
.. 1
.. 2
-2

----




.source of snippet `break3`
[source]
----
println {
    for i=0 ; i < 10 ; i++ list{
      break if i == 2
      i;
    }
}


----




.output of snippet `break3`
[source]
----
[0, 1]

----




.source of snippet `break4`
[source]
----
println {
    for i=0 ; i < 10 ; i++ list{
      break -2 if i == 2
      i;
    }
}


----




.output of snippet `break4`
[source]
----
[0, 1, -2]

----




.source of snippet `break5`
[source]
----
println {
    for i=0 ; i < 10 ; i++ list{
      break none if i == 2
      i;
    }
}


----




.output of snippet `break5`
[source]
----
[0, 1, none]

----



The last example shows the difference between using the break statement following an `if` condition.
In the first case the statement executes in the context of the loop and the `break` aborts the execution of the loop.

In the second case the `break` is inside a block, and it aborts the execution of the block itself, the loop is not disturbed.


.source of snippet `break6`
[source]
----
println {
    for i=0 ; i < 4 ; i++ {
      if i == 2 : break;
      println i;
    }
}
println "however"
println {
    for i=0 ; i < 4 ; i++ {
      if i == 2 { break };
      println i;
    }
}


----




.output of snippet `break6`
[source]
----
0
1
none
however
0
1
2
3
none

----



When the expression following the `break` keyword starts with the `if` keyword the expression has to be enclosed between `()` parentheses.


.source of snippet `break7`
[source]
----
println {
    for i=0 ; i < 4 ; i++ {
      break (if i == 2 : 3 else : 4) if i == 2;
      println i;
    }
}


----




.output of snippet `break7`
[source]
----
0
1
3

----



==== `continue`

The continue command will "break" the current loop execution and start the loop over for the next iteration.
In the case of a for loop, the step command will be executed, and the exit condition will also be evaluated.

The `continue` command can have an expression, but it is only allowed if the loop is a list-resulting loop.
In this case the value of the expression will be appended to the resulting list.
If the value of the expression is `none` then `none` as a value will be appended to the list.
If there is no expression after the `continue` keyword, then the resulting list will remain untouched for the actual execution.

The use of `continue` is restricted.
You can use it only inside a loop as a top-level command, and not inside a block, or part of other commands, like `if`.


.source of snippet `bad_continue`
[source]
----
try: let k = {for each z in [1,2,3] { if z%2 == 0 : continue 2*z else: continue 3*z}}
catch e: println e


----




.output of snippet `bad_continue`
[source]
----
Continue executed in non-loop.

----



==== `return`

The command `return` stops the execution of a function, method, closure, or macro.
If it is executed, the value of the function, method, closure, or macro will be the expression that follows the command.

If there is no expression following the `return` keyword then `none` will be returned.


.source of snippet `return1`
[source]
----
fn a(x) {
    if x == 2 {
        return 2
    }
    return
}
println a(1)
println a(2)
println a(3)


----




.output of snippet `return1`
[source]
----
none
2
none

----



==== `yield`

The command yield produces a value, and the execution of the code continues.
It can only be used when the code was started so that another thread is expecting the yielded value.
The typical example is when you execute a command `async` .


.source of snippet `yield1`
[source]
----
fn gen_1_to_10 {
    for i=1 ; i <= 10 ; i++:
        yield i;
}

println([ .. (async gen_1_to_10()) ])


----




.output of snippet `yield1`
[source]
----
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

----



The return value can be used in a `for each` loop, or you can iterate through it the same way you would with any iterator.


.source of snippet `yield2`
[source]
----
fn gen_1_to_10 {
    for i=1 ; i <= 10 ; i++:
        yield i;
}

mut st = async gen_1_to_10();
while st.has_next() :
    println(st.next());


----




.output of snippet `yield2`
[source]
----
1
2
3
4
5
6
7
8
9
10

----



=== `with`

The `with` command executes a block in the context of one or more objects, and also it functions as a resource manager similar to Python.

[source]
----
with object list { block }
----

or

[source]
----
with object list: command
----

The `object list` is a comma separated list of expressions each with an optional `as identifier` part.
When there is an `as identifier` the functionality is similar to that of Python.

When there is an `as ID` after the expression, then the expression is treated as a resource manager.
The method `entry()` is invoked on the resource manager, and the returned value is assigned to the given `ID`.
The returned value is usually a resource object.

For example, handling a file, the resource manager should return an object you can use to write into a file.

The identifier is used in the block following the `with` command referencing the handle returned by `entry`.

If `entry` returns `none`, then the resource manager object itself is used as a resource.
This can be used in simplified cases when the resource manager and the resource object are the same.

When the execution of the block is finished the method `exit` will be invoked on the resource manager.
This method will be invoked even if there was any error during the execution of the block.


.source of snippet `withAs`
[source]
----
class ResourceManager {
    fn init {
        // each resource manager object can manage one resource object
        let res = Resource();
    }

    fn entry {
        println $"entry to ResourceManager ${this}"
        res
    }

    fn exit( e: err|none = none) {
        println $"exit fom ResourceManager ${this} with \"${e}\" as exception"
        if e != none : // we handle the exception printing it
            println e
        res.close() // close the resource
        return true; // suppress exceptions
    }
}

class Resource {
    fn init {
        println "Creating resource"
    }
    fn printf(s,[rest]){
        println "printf was called"
        println s % rest
    }
    fn close(){
        println $"closing resource"
    }
}

with ResourceManager() as r {
    println $"r resource is ${r}"
    r.printf("executing with resource %s %s",1,2)
    die "mad dog"
}
println "did not die"


----




.output of snippet `withAs`
[source]
----
Creating resource
entry to ResourceManager {res: {cls: class Resource}, cls: class ResourceManager}
r resource is {cls: class Resource}
printf was called
executing with resource 1 2
exit fom ResourceManager {res: {cls: class Resource}, cls: class ResourceManager} with "mad dog" as exception
mad dog
closing resource
did not die

----



The argument to the method `exit` is the exception that was raised while processing the block, or `none` if there was not any.
If the return value of the method `exit` is `true` or anything that can be converted to boolean and has the value `true` following the cast, then the exception is treated as caught and handled.
If there is any exception during the closing, then it will be thrown.
Exceptions during resource closing do not get suppressed.

If there are more than one resource in a `with` statement, then their `entry` method is called from left to right and then `exit` methods from right to left.
The last "opened" resource is closed first.

[NOTE]
====
Handling the resources this way is similar to how Python handles the resources with some notable differences:

* There are no underscore characters in the name of the method `entry` and `exit`.
* `exit` cannot exist
* `entry` can return `none`.
It is the same as returning `this`.
* `exit` gets only one argument, the exception that holds all the information.
In Python, you get the stack trace and the exception type in a separate argument.
* You _MUST_ provide an `as` alias for resources, otherwise the expression is not treated as a resource (see below).
====

If the expression following the `with` statement is not followed by an `as` and an alias, it is treated as an ordinary object.
The fields of the object get mapped to the actual context.
It means that the fields of the objects can be used as variables without prefixing them with any object reference.


.source of snippet `simpleWith`
[source]
----
mut x = {a:1,b:2};
mut y = {a:4,c:5};
with x,y {
    println a
    println b
    println c
}


----




.output of snippet `simpleWith`
[source]
----
4
2
5

----



Technically, the command executes the block in a context that references the fields of the object and wraps the surrounding context.
When more than one object is listed, then multiple wrapping scopes are created from left to right.
It also means that the objects to the right shadow the objects to the left.
In the example both `x` and `y` have field `a` and since `y` is later in the list the field of `y` is used.

You can also modify or even create and pin fields:


.source of snippet `modifyWith`
[source]
----
mut x = {a:1,b:2};
mut y = {a:4,c:5};
with x, y {
    a = 0
    b = 0
    c = 0
    mut k = 55;
    pin b
}
try: x.b = 55 catch e: println e
println x
println y


----




.output of snippet `modifyWith`
[source]
----
pinned variable cannot be altered 'b'
{a: 1, b: 0}
{a: 0, c: 0, k: 55}

----



Note that the field `x.a` was not modified, because it is shadowed by `y.a`.
You can only create new fields in the right most object.
You can pin a field in any of the objects unless they are shadowed.

The value of the command is the value of the block executed.


.source of snippet `valueWith`
[source]
----
mut x = {a:1,b:2};
mut y = {a:4,c:5};
println {with x,y : a * b + c}


----




.output of snippet `valueWith`
[source]
----
13

----



=== Asynchronous execution

You can execute any command asynchronously using the `async` command.
You simply have to write `async` in front of the command.
The command will start the execution in a separate thread (Java 21 virtual thread) and the starting thread will go on executing.

The return value of the `async` command is a handler to the started task.
The type is `task`.

To wait for the finishing of an asynchronously started command, you should use the `await` command.
It will also result in the value returned by the task.

In addition to returning a value, a task can also receive and send objects.
The `yield` command inside the task will either receive an object or send an object.


.source of snippet `async`
[source]
----
mut t:task = async {
    for i=0 ; i < 10 ; i++ {
        yield i
    }
    55
}

while t.has_next():
    print t.next(), " "
println()
println(await t)



----




.output of snippet `async`
[source]
----
0 1 2 3 4 5 6 7 8 9 
55

----



A task object implements the following methods:

* `is_done` is `true` when the task has finished.

* `is_cancelled` is `true` when the task was cancelled

* `is_err` is `true` when the task ended in an error

* `get_err` returns the error

* `get` returns the result of the task.
It is the same as the result of the `await` command.

* `close` close the channel to the task.
After calling this method, you cannot send anything to the task and the task will see that the channel is closed.

* `send` will send an object to the task

* `has_next` will be `true` if there are objects send by the task

* `next` gets the next value from the task

The command `async` has four parameters:

* `in` can give the size of the queue for objects to be sent to the task.
The default value is no limit.
If the queue is limited and full, sending an object will wait till a place is freed.

* `out` can give the size of the queue for the task to yield back to the main thread.
If the queue is full, the task will wait.
This can be used to limit the memory and CPU usage of infinite generators.

[NOTE]
====

Say you want to create a generator that returns the prime numbers.
If you do not limit the channel size, the generator will run ahead and fill in the memory with prime numbers.
Limiting the channel size you can balance the calculations.
The generator will stop when it has generated enough numbers and starts when some of the result is consumed.



.source of snippet `channel_limit`
[source]
----

/**
  * a very simple prime number filter
  */
fn is_prime(x:num):bool {
    return true if x == 2;
    return false if x % 2 == 0;
    for n = 3 ; n*n <= x ; n = n + 2 :
        return false if x % n == 0
    true
}
/**
  * Create a generator with limited que size.
  * Then read from it and print.
  */
fn execute(name:str, que_length:num){
    mut prime = async[in=que_length] {
        yield 2;
        mut i = 3;
        while {
            if is_prime(i) {
                yield i
                println name, " generated ", i
            }
            i = i + 2; // only the odd numbers
        }
    }

    mut count = 0
    while prime.has_next(){
        println " prime read ",prime.next()
        count++
        }until count > 3 // limit the printout to the first three primes
    sleep 1 // will give time for the generator to run ahead uselessly
    println "stopping"
    prime.stop()
    // the error is cancellation, since we stopped the task
    try: await prime catch e : println "exception ", e
}
// only 5 for demonstration, in real life it can be millions eating memory
// five now stands for "unlimited size"
execute("Thread 1",5)
// limited channel size will stop the running ahead
execute("Thread 2",2)


----




.output of snippet `channel_limit`
[source]
----
 prime read 2
Thread 1 generated 3
 prime read 3
Thread 1 generated 5
 prime read 5
Thread 1 generated 7
 prime read 7
Thread 1 generated 11
Thread 1 generated 13
Thread 1 generated 17
Thread 1 generated 19
Thread 1 generated 23
stopping
exception Task stopped.
Thread 2 generated 3
 prime read 2
 prime read 3
Thread 2 generated 5
 prime read 5
Thread 2 generated 7
Thread 2 generated 11
 prime read 7
Thread 2 generated 13
stopping
exception Task stopped.

----



In the output you can see that the calculation went ahead uselessly in the first case.
In the second case the calculation was limited.
====

* `steps` limits the number of elementary steps in the execution.
The task will stop after this many steps (planned feature).

* `times` limits the time of the task, unit is milliseconds.
The task will stop after the specified time (planned feature).


These parameters can be specified after the `async` keyword between `[` and `]` characters.
When the command to be executed asynchronously starts with a `[` character you either has to have `[]` in front of it or enclose the command between `(` and `)` or `+{+` and `+}+` to help the syntax analysis.

The command can also execute a list parallel.
When the expression to execute asynchronously is a list literal, then the command will execute the individual elements of the list parallel.
In that case the result is a list of tasks instead of a task that results in a list.

The following example creates a list of `[1,2,3]` in the conventional way and also parallel.
It prints out the elapsed time using the built-in `nano_time` function.


.source of snippet `asyn_list`
[source]
----
fn sleeper(x) {
    sleep 0.1
    x
    }
{
mut start = nano_time()
mut serial = [sleeper(1), sleeper(2), sleeper(3)]
mut end = nano_time()
println serial
println( (end-start)/1000000, "ms")
}
{
mut start = nano_time()
mut serial = [ ..async([sleeper(1), sleeper(2), sleeper(3)]) -> it.get() ]
mut end = nano_time()
println serial
println( (end-start)/1000000, "ms")
}


----




.output of snippet `asyn_list`
[source]
----
[1, 2, 3]
314.681542ms
[]
311.337791ms

----



As you can see, in the first case the execution time is a bit above 300ms, which is the three times 0.1sec waiting in the function.
In the second case the functions wait the same time, parallel, and the execution time is just above the 100ms single wait time.

[[flow-command]]
== `flow` Command

The `flow` command defines a *reactive execution block* in which named expressions (called *cells*) are evaluated in a concurrent and data-driven fashion.
It is particularly useful for implementing iterative or mutually dependent computations where values must be recalculated until a condition is satisfied or a fixed number of changes have occurred.

Cells are defined as variable-expression bindings, and their dependencies are automatically detected by analyzing identifier usage.
When a cell value changes, all other cells that depend on it are automatically rescheduled for evaluation in a new thread (using Java virtual threads).

The `flow` block terminates under one of the following conditions:

- The `until` condition evaluates to `true`.
It is repeatedly evaluated after each task in the context of the `flow` command.
- The maximum number of task executions (`limit`) is reached.
- The allowed wall-clock execution time (`timeout`) is exceeded.
- The flow reaches a stable state, there are no more tasks to run.

In these cases the already scheduled tasks are still executed before the flow stops.

If a `yield` expression is specified, its result is returned as the result of the `flow` command.
It is evaluated once after all scheduled tasks are finished.
The evaluation happens in the context of the `flow` command.
If there is no `yield` in the `flow` command `null` is returned.

The evaluation starts with the cells that have no dependencies.
These are evaluated in asynchronous threads.
Scheduling and executing tasks based on dependencies start when the start cells are all finished and the flow has reached the initial state.

If there are cells that have dependencies, and that way they are not start cells, but their transitive closure of their dependencies does not include any start cells, it is en error.
It is detected during compilation time and results in a syntax error.

=== Syntax

The basic syntax of the `flow` command is:

[source]
----
flow [<identifier>] [until <condition>] [limit <maxTasks>] [timeout <seconds>] {
  <identifier> <- <expression>
  ...
  yield <expression>
}
----

- the identifier following the `flow` keyword is optional.
It is used solely for diagnostic purposes.
It does not get into any symbol table, does not hide any object of the same name in the context hierarchy.
It is used only in error messages and is available for command introspection.
This identifier cannot be `limit` or `timeout`, because those signal the start of the limit and timeout expressions respectively.

- `until <condition>`::
Optional.
A boolean expression that terminates the flow once it evaluates to true.
- `limit <maxTasks>`::
Optional.
A numeric constant that sets the maximum number of dependent cell executions allowed.
- `timeout <seconds>`::
Optional.
A numeric constant (can be fractional) specifying the maximum wall-clock time allowed for execution, in seconds.

[NOTE]
====
`until`, `limit` and `timeout` are all optional and can be in any order.
`limit` and `timeout` are not keywords.
The syntax analyzer would not know if they start the limit or timeout definition or you want to name the flow to "limit" or "timeout".
You cannot name the flow to either of these.
====

Each

[source]
----
<identifier> <- <expression>
----

is a __cell__.
During the execution the expression, which can even be a whole block, just like any expression in Turicum, is evaluated asynchronously, and when it is ready, the resulting value updates the flow local variable on the left side of the `pass:[<-]`.

The expression is the cell expression.
The identifier is the __cell state variable__.

When the syntax analysis is done, the compiler performs several semantic checks.
It checks that there are __start cell__s, that can be calculated independent of any other.

There should be no two __start cell__s updating the same __cell state variable__.

Following this analysis, the compiler checks that each cell is reachable from the __start cell__s.
There should be no cells that are not reachable.

NOTE: Unreachable cells only can happen if a cell depends on itself or there is a circular dependency.
Without such a dependency the cell would be a start cell.

The last check is that all dependency circles contain at least __start cell__.
If there is a dependency circle that does not contain a __start cell__ that circle would result in the use of a __cell state variable__ uninitialized.

If any of the checks fails, the compiler results in a syntax error and the command is not created.

=== Semantics

The `flow` block contains a series of *cells*.
Each cell defines a named variable and an expression that computes its value.
These variables can reference each other, and the runtime will detect and track these dependencies.

When a __cell state variable__ is updated,
(i.e., its computed value differs from the previous value in the local context),
all cells that depend on it are automatically rescheduled.
This process continues until one of the termination conditions is met.

A __cell state variable__ is updated if

* it was undefined and the new value is not `non_mutat`, and not `fini`, OR
* it was defined and the value of the evaluation does not `equals` the current value.

When the value of the __cell block__ evaluation is `non_mutat` the __cell state variable__ is not updated.

When the value of the __cell block__ evaluation is `fini` the __cell state variable__ is not updated and the cell will not be scheduled anymore.
If there are already running instances of the cell, they will finish and possibly update the __cell state variable__ assuming they were started after the cell block that resulted the `fini` value.

When a result is `fini` the __cell state variable__ counter is updated, even though the variable value is not, thus any block that was started earlier and not finished yet will not update the variable.

When the result if `non_mutat` nothing is updated.

NOTE: `fini` and `non_mutat` are predefined pinned global constant objects.

Cell evaluation is performed in isolated thread-local contexts derived from the flow's original context.
This context contains the flow context variables as copies and read-only.

The system avoids infinite re-evaluation loops by tracking value stability and respecting the `limit` and `timeout` constraints.

The execution of the code blocks is done asynchronously.
There is no guarantee for any order.
When it is recognized that a cell variable one of the blocks depends on, (uses it as a variable in some calculation), then it will be scheduled for execution and started as soon as the JVM and the operating system start it.
Each cell block is executed in a new virtual thread.

It can happen that the same block executes parallel in multiple instances.
It could lead to instability in the flow.
An earlier started version can run longer than a later instance.
Also, different blocks can update the same __cell state variable__.
To avoid this the `flow` command only updates a __cell state variable__ to the value resulting from a cell block execution only if the __cell state variable__ was not updated in the meantime.
If the __cell state variable__ was already updated, the result is ignored.
It is implemented using __cell state variable__ version counters.

When the command is created, the dependencies between the __cell state variable__s are analyzed.
Those cells that do not depend on any other cell are __start cell__s.
They will be executed first.

It is important that other cell calculations start only after the __start cell__s have been calculated.
If you have multiple __start cell__s and a cell block depends on more than one, then they will both be defined when the dependent cell calculation starts.

[NOTE]
====
- The order of `until`, `limit`, and `timeout` is flexible in the syntax.
- All expressions in the `flow` block are commands and follow standard language rules.
- Only direct assignments (`x <- expression`) are allowed; complex control flow must be expressed inside expression blocks.
====


=== Use Cases

The `flow` command is useful for:

- Converging numeric approximations (e.g., computing square roots)
- Reactive data propagation
- Declarative fixed-point computations
- Defining cyclic dependencies with convergence guarantees

=== Examples

This example demonstrates a classical use of the `flow` command for computing square roots using the Babylonian method.
It shows how reactive cells can update each other iteratively until convergence is reached, and how the `until` clause controls flow termination based on a numeric precision condition.


.source of snippet `example_flow_squareroot`
[source]
----
mut _sqrt = {
    flow until epsilon < 0.0001 {
        a <- 13;
        a <- {
            mut newA = (a + 13 / a) / 2;
            println("a =", newA);
            newA;
        }
        epsilon <- abs(a - (a + 13 / a) / 2);
        yield a
    }
}

println("sqrt(13) ≈ ", _sqrt);
println("sqrt(13) ≈ ", sqrt(13), " calulated by java Math");
println("square ≈ ", _sqrt * _sqrt);


----




.output of snippet `example_flow_squareroot`
[source]
----
a =7
a =4.428571428571429
a =3.6820276497695854
a =3.6063454894655185
a =3.6055513629176015
a =3.6055512754639905
a =3.6055512754639896
a =3.6055512754639896
sqrt(13) ≈ 3.6055512754639896
sqrt(13) ≈ 3.605551275463989 calulated by java Math
square ≈ 13.000000000000002

----



This example illustrates how the `flow` command can be bounded by wall-clock time using the `timeout` clause.
It simulates a long-running or slow computation and demonstrates how flow execution is safely terminated after the specified time limit.


.source of snippet `example_flow_timeout`
[source]
----
mut result = {try {
    flow timeout 0.01 {  // 10 milliseconds
        counter <- 0;
        counter <- {
            mut n = counter + 1;
            println("counter =", n);
            sleep(0.005);  // 5 milliseconds per step
            n;
        }
        yield counter
    }
}catch e: println e}

println("Final counter = ", result);


----




.output of snippet `example_flow_timeout`
[source]
----
counter =1
counter =2
Flow '#unnamed' timed out after 10 ms
Final counter = none

----



This example highlights the use of the `limit` clause to constrain the number of task executions within a `flow`.
It shows how the system halts with a clear error message once the execution limit is reached, making it useful for preventing runaway or cyclic computations.


.source of snippet `example_flow_limit`
[source]
----

mut result = {try {
               flow limit 5 {
                   x <- 1;
                   x <- {
                       mut newX = x + 1;
                       println("x =", newX);
                       newX;
                   }
                   yield x
               }
           } catch e: println e.message}

           println("Final x = ", result);


----




.output of snippet `example_flow_limit`
[source]
----
x =2
x =3
x =4
x =5
x =6
x =7
Task limit has been reached in flow '#unnamed' command after 5 tasks.
Final x = none

----



The next example demonstrates that you can access the structure of the flow command or to any command.
In the example the flow command is not executed, rather stored in a variable, and then the dependency graph of the cells is printed out.

%S flow_mermaid_output%}

== Functions

Functions play a similar role as in other languages.
They can be top-level functions and methods attached to classes or to objects.

=== Function Declarations

A function declaration is a statement that defines the function.
The function will be usable after the function definition was executed.
The syntax of the function definition is

[source]
----
fn function_name (parameters) : types {
   body
}
----

or

[source]
----
fn function_name (parameters) -> types {
   body
}
----


`fn` is a keyword, and it is never optional.


.source of snippet `fun1`
[source]
----
fn inc(x) {
  x+1
}
println(inc)
println(inc(1))


----




.output of snippet `fun1`
[source]
----
ch.turic.commands.Closure@512535ff
2

----



`function_name` is the name of the function.
It can be missing, typically when the result, the function itself is assigned to a variable or passed directly as an argument.


.source of snippet `fun3`
[source]
----
fn inc x {
  x+1
}
println(inc)
println(inc(1))


----




.output of snippet `fun3`
[source]
----
ch.turic.commands.Closure@61a88b8c
2

----




`(parameters)` are the parameters, including default values and parameter types and parameter-passing requirements.
The `(` and `)` is optional when the function has a name.
When it does not have a name, then `(` and `)` must present even if there are zero arguments.


.source of snippet `fun2`
[source]
----
mut inc = fn (x) {
  x+1
}
println(inc)
println(inc(1))


----




.output of snippet `fun2`
[source]
----
ch.turic.commands.Closure@5adb0db3
2

----



The body of the function can be a block of statements or a single expression.
The expression is specified following a `=` character and the parentheses are a must in this case also.
This is to avoid the unreadable `fn = 2*3` to be declared as a function declaration but `pass:[`fn`]=2*3` an assignment.
`fn = 2*3` is a syntax error.

[NOTE]
====
Be careful when using the `fn x()=...` format.
The following code does not do what you expect:


.source of snippet `fun10`
[source]
----
fn p()=len "original K";
println p()


----




.output of snippet `fun10`
[source]
----
ch.turic.builtins.functions.Len@35229f85

----



You may expect that it will calculate the length of the string and return that value.
In reality, the expression is the function object `len` itself.
The following string is an expression that by itself stands on its own as a command.
The string constant is just a statement with no effect.

If you enclose the whole expression in a pair of parentheses you get the desired result:


.source of snippet `fun11`
[source]
----
fn p()=(len "original K");
println p()


----




.output of snippet `fun11`
[source]
----
10

----



or


.source of snippet `fun12`
[source]
----
fn p()=len("original K");
println p()


----




.output of snippet `fun12`
[source]
----
10

----



Use `=` to define functions only for straightforward expression functions, that are true expressions.
====

The parameter list is comma-separated.
Each element defines a formal parameter.

Types are optional and follow the same syntax as in variable declarations, but function parameters are always immutable.
You cannot use `mut` or `let` in the parameter list.
Attempting to do so will result in a syntax error.

[NOTE]
====
Function parameters are implicitly immutable.
You cannot use `mut` or `let` in a function or closure parameter list.

The only exception is the `init` method: its parameters become fields of the object being initialized, and therefore they are mutable.
====



The individual types can be identifiers or `(` and `)` enclosed expressions.
The types are separated by `|`.
The type of the returned value is checked against the declared types upon returning from a function.


.source of snippet `fun7`
[source]
----
fn concat(a:str, b:str):str = a + b
println concat("ab","ba")


----




.output of snippet `fun7`
[source]
----
abba

----




.source of snippet `fun8`
[source]
----
fn concat(a:str, b:str):str = 13
try:
    println concat("ab","ba")
catch err: println err


----




.output of snippet `fun8`
[source]
----
Cannot return from 'concat' the value '13' as it does not fit any of the accepted type of the function/closure (str)

----



The types are evaluated when the function is defined.


.source of snippet `fun9`
[source]
----
mut myString="num"
fn concat(a:str, b:str):(myString) = 13
myString = "str"
try:
    println concat("ab","ba")
catch err: println err


----




.output of snippet `fun9`
[source]
----
13

----



There is no effect changing the value of the variable `myString` to `str` when the function was already defined.

==== Parameter Passing

When a function is invoked, the actual parameters can be passed to the function in two different ways:

* by position, and
* by name.

Some parameters can be passed in both ways, some of them only positionally, some only by name.
This is declared in the formal parameter list.
Each parameter declaration starts with the identifier of the argument.
This is the identifier how the function body can use the variable as well as the identifier the called can use if the parameter is passed by name.

Parameters preceded with '!' can only be passed positionally.

Parameters preceded with `@` can only be passed by name.


.source of snippet `fun4`
[source]
----
fn inc !x, @how_much {
  x+how_much
}
println(inc)
println(inc(1,how_much=5))


----




.output of snippet `fun4`
[source]
----
ch.turic.commands.Closure@1a760689
6

----



Here `x` is a positional parameter.
Passing a value as `x=1` would be an error.
Parameter `how_much` must be passed by name.

Parameters can also have type declarations and default values.
If there is a type declaration passing a value that does not fit the type declaration is an error.
Not passing a value for a parameter that does not have a default value is also an error.


.source of snippet `fun5`
[source]
----
fn inc !x, @how_much=1 {
  x+how_much
}
println(inc(1,how_much=5))
println(inc(1))


----




.output of snippet `fun5`
[source]
----
6
2

----



Parameter types and the default value assignments have the same syntax as in the case of variable assignment.
There is one notable difference: default value expressions can use the binary or `|` operator only if it is between parentheses.

==== Positional and Named parameters order

You are allowed to use positional and named parameters intermixed.
There can be a named parameter and then a position following it.
It can be beneficial in some special situations, but the general recommendation is not to overuse this feature.
List the positional parameters first, named following, and optional parameters (see soon) the last.

The actual algorithm of parameter passing is the following:

* The actual arguments are evaluated from left to right.
* Named passings are assigned to the argument with the matching name.
* Positional arguments are assigned to the first non-named only argument.
That is the first not-yet-assigned positional or positional/named argument.


.source of snippet `fun6`
[source]
----
fn wrong !x, h, !k {
  // just don't do
}
try: wrong(1,3, h= 2)
catch e: println("There is an error",e)


----




.output of snippet `fun6`
[source]
----
There is an errorParameter 'h' is already defined

----



[#_extra_parameters]
==== Extra parameters

In some cases you want to allow the callers to pass extra arguments and your function body to use them.
To do that, there are three extra arguments you can use in your function definition:

* `[rest]`,

* `+{meta}+`, and

* `^closure`.

You can name them any way you want, but for the same of simplicity we will use the names above.
The syntax distinguishing them from the other parameters is the use of the extra `[]`, `+{}+`, and `^` characters.
If they are present, they have to be the last formal parameters in the order as listed above.
Any of them can be missing, but if two present then `[rest]` should be before `+{meta}+` and `^closure`, and `+{meta}+` has to precede `^closure`.

When the function code starts

* `rest` will be a list containing the value of the positional arguments that were not yet assigned to any parameter.
* `meta` will be an object with the named parameters not assigned as field names and the values holding the values.
* `closure` will hold the last parameter of the function call that usually is a closure.

The following example shows how you can use the rest-parameter:


.source of snippet `restParameters`
[source]
----
mut f = fn (a,b,[rest]) {
  println("a=",a)
  println("b=",b)
  for each r in rest: print("%s " % r)
}

f(1,2,3,4,5,6)


----




.output of snippet `restParameters`
[source]
----
a=1
b=2
3 4 5 6 
----



The following example demonstrates the use of the meta-parameter:


.source of snippet `metaParameters`
[source]
----
mut f = fn (a,b,{meta}) {
  println("a=",a)
  println("b=",b)
  for each r in keys(meta): print("%s=%s\n" % [r , meta[r]])
}

f(1,b=2,k=3,x=4,juice=5,six=6)


----




.output of snippet `metaParameters`
[source]
----
a=1
b=2
six=6
x=4
k=3
juice=5

----



[NOTE]
====
When you

* have a `!name` declared positional only parameter, and
* you also have `+{meta}+` in the parameter list, and
* and you call the function providing a `name=expression` named argument,

it will not be assigned to the positional only parameter, and it is also not an error.
It will be a field in the meta-parameter object created.

The reason for this is that the naming of the positional only parameters is not part of the function signature.
They are the internal business of the function itself, and as such must not have any effect how you call the function.

On the other hand, no named parameter name, or named/positional parameter name will get into the meta-parameter.

Also, you cannot use a parameter name in an argument list more than once.
====


You can also combine the two:


.source of snippet `metaRestParameters`
[source]
----
mut f = fn (a,b,[rest],{meta}) {
  println("a=",a);
  println("b=",b);
  for each r in keys(meta): print("%s=%s\n" % [r , meta[r]]);
  println("rest:");
  for each r in rest: print("%s " % r);
}

f(1,b=2,k=3,x=4,juice=5,7,six=6);


----




.output of snippet `metaRestParameters`
[source]
----
a=1
b=2
six=6
x=4
k=3
juice=5
rest:
7 
----



The last argument, preceded by the `^` character is special.
When you call a function and the last argument is a closure then you can place that closure outside of the `(` and `)` of the arguments, but ONLY if the closure is defined right there.

For example:


.source of snippet `closureArgument`
[source]
----
mut f = fn (a,b,^closure) {
  println("a=",a);
  println("b=",b);
  println(closure(a,b))
}

f(2,3){|x,y| x+y}
f(2,3){|x,y| x*y}


----




.output of snippet `closureArgument`
[source]
----
a=2
b=3
5
a=2
b=3
6

----



The function gets the closure adding the two numbers and then prints the numbers and the result.

The example:

.wrong example
[source]
----
let f = fn (a,b,^closure) {
  println("a=",a);
  println("b=",b);
  println(closure(a,b))
}
let closure = {|x,y| x+y}

f(2,3)closure
----

does not even compile, since the mandatory `;` or new line is missing after the function call.
Also, it would be unreadable to recognize `closure` as an argument.

NOTE: The actual implemented syntax checks that the next two tokens following the `)` are `+{+`and `|`.

This call can aid in creating domain-specific languages.

==== Spreading lists and objects as arguments

When calling a function, you can precede a parameter with the `..` operator.
This will spread the content of the parameter to parameters.

If the value of the parameter is an object, the fields of the object will be used as named parameters.
The field names will be used as argument names and the values as values.


.source of snippet `spread`
[source]
----
fn a(@a,@b,@c,@d){
    println("%s %s %s %s " % [a,b,c,d])
}
fn b(!a,!b,!c,!d){
    println("%s %s %s %s " % [a,b,c,d])
}
fn c(a,b,c,d){
    println("%s %s %s %s " % [a,b,c,d])
}

a(..{a:1,b:2,c:3,d:4});
b(..[1,2,3,4]);
c(..[1,2],..{d:4},3);


----




.output of snippet `spread`
[source]
----
1 2 3 4 
1 2 3 4 
1 2 3 4 

----



If the value is a list, then the values will be used as positional parameters.

This is useful when you want to pass on parameters you got in the `rest` or `meta` parameters to some other function.

[NOTE]
====
Technically you can spread any value resulting from an expression that implements internally the `HasFields, or `Iterable<?>` interface.

Currently, the following classes implement the `HasField` interface:

* `Lex` one token in the lexical analysis.
It is used in preprocessors written in Turicum.

* `LexList` the list of the tokes.
Just like the class `Lex` it is used in preprocessors.

* `Closure` is the implementation class for functions and closure.
There is one, read-only field, `name`.

* `Macro` is the implementation class for macros.
There is one, read-only field, `name`.

* `JavaObject` is the class that implements the handling of any Java object, when all else fails.
It implements reflection to access the declared fields of the class on the enveloped object.

* `LazyObject` is the lazy object that has fields which are evaluated every time they are accessed.

* `LngClass` Turicum class object.
It handles the class level fields.

* `LngException` is any exception caught by a `catch` in the program.
It has a constant set of read-only fields.

* `LngList` Turicum lists.
It has one read-only field `length`.
This class also implements Iterable and is handled as such when used in an argument list spread.

* `LngObject` is a Turicum object.

* `MapObject` any Java `Map<?,?>` object.
The implementation will handle the keys as strings.

The following class implement the `Iterable` interface in Turicum, which do not implement the `HasField` and thus can be spread as positional parameters:

* `IndexedString` envelops a string during commands that modify a String.
This is the technical implementation internally replacing an unmutable Java String with a mutable wrapper around.

* `JavaArray` makes it possible to index any Java array.

* `LngList` is the list object in Turicum.
Although this class also implements the `HasFields` interface this is handled as an exception and passed as positional arguments when spread.

* `AsyncStreamHandler` is the class handling asynchronous operations and yields.
It makes it possible to use the result of a `async expression` as arguments.
+

.source of snippet `spreadStream`
[source]
----
fn c(a,b,c,d){
    println("%s %s %s %s " % [a,b,c,d])
}
fn numbers {
  for i = 1 ; i <= 4 ; i++ : yield i
}

c(..(async numbers()))


----




.output of snippet `spreadStream`
[source]
----
1 2 3 4 

----


====

=== Modifying Arguments
Function arguments in Turicum are immutable.

When a function is called, its arguments are *pinned*—they are bound to their initial values and cannot be reassigned within the function body.

The only exception is the `init` method, which acts as the object initializer.
In this case, the arguments correspond to the fields of the object being constructed.
Assignment is allowed during initialization, because these fields persist beyond the execution of `init`.
If they were pinned like regular arguments, the object's fields would become permanently immutable, which is not desired.

== Classes and Objects

=== Class declaration

Classes can be defined using the `class` keyword.
A class is defined when the class definition is executed.


.source of snippet `class1`
[source]
----
class A {
    fn init {
        mut a = "a";
    }
    mut c = "c"
}
mut a1 = A()
mut a2 = A()
a1.a = "1"
a2.a = "2"
A.c = "d"
println a1.a, a2.a, a1.c, a2.c



----




.output of snippet `class1`
[source]
----
12dd

----



Classes can contain methods and can define class variables.
In the example above the class contains the method `init`, which is a special one and declared one variable, `c`.

The method `init` is the initialized method.
It is invoked when the class is instantiated.
To create an object, you should use the name of the class like a method with parameters.
The parameters will be passed to the `init` method.

When executing a method, there are two special variables:

* `this` is the current object.

* `cls` is the class of the current object.

If you use a variable without the `this.` prefix it will automatically be handled, but you can just use the `this.` prefix any time.
That way the following example is the same as the previous:


.source of snippet `class2`
[source]
----
class A {
    fn init {
        this.a = "a";
    }
    cls.c = "c"
}
mut a1 = A()
mut a2 = A()
a1.a = "1"
a2.a = "2"
A.c = "d"
println a1.a, a2.a, a1.c, a2.c



----




.output of snippet `class2`
[source]
----
12dd

----



When using variables in a class first the object variables are consulted.
If there is no object variable, then the class variables are used.
Classes and the methods inside the classes do not wrap any surrounding context.

The methods defined in a class belong to the class.
You can define methods attached to the objects.


.source of snippet `class3`
[source]
----
class A {
    fn init {
        this.a = "a";
    }
    fn p {
        println "I am class level"
    }
}
mut a1 = A()
a1.p()
a1.p = fn (){
  println "I am a1"
}
mut a2 = A()
a2.p = fn (){
  println "I am a2"
}

a1.p()
a2.p()



----




.output of snippet `class3`
[source]
----
I am class level
I am a1
I am a2

----



The variable `cls` and `this` are pinned, cannot be modified in the methods.


.source of snippet `class4`
[source]
----
class A {
    fn p {
        this = none
    }
}
try :
    A().p()
catch ex :
    println ex


----




.output of snippet `class4`
[source]
----
Variable 'this' is pinned.

----



and


.source of snippet `class5`
[source]
----
class A {
    fn p {
        cls = none
    }
}
try :
    A().p()
catch ex :
    println ex


----




.output of snippet `class5`
[source]
----
Variable 'cls' is pinned.

----



The only exception is the `init` method.


.source of snippet `class6`
[source]
----
class A {
    fn init {
      this = B()
    }
}

class B {

}

println A().cls



----




.output of snippet `class6`
[source]
----
class B

----



The example above alters the `this` variable, and it alters what the construction of the class returns.
That way an initializer can function as a factory method.

You cannot change the value of the `cls` even in the initializer:


.source of snippet `class7`
[source]
----
class A {
    fn init {
      cls = B
    }
}

class B {

}
try:
    A()
catch ex:
    println ex



----




.output of snippet `class7`
[source]
----
Variable 'cls' is pinned.

----



Classes can be nested and defined inside other classes.
When calling the constructor of the class to create a new instance then the variable `this` would be ambigous.

For `a.Z()` it usually points to `a`, but if `Z` is a class, and we called the constructor, than `this` should be the new instance.
In this situation a special variable called `that` will point to `a`.


.source of snippet `class8`
[source]
----
class A {
    class B {
        fn init {
            println "this ", this
            println "cls ", cls
            println "that ", that
        }
    }
}

mut a = A()
mut b = a.B()


----




.output of snippet `class8`
[source]
----
this {that: {cls: class A}, cls: class B}
cls class B
that {cls: class A}

----




=== Class inheritance

Classes can inherit in Turicum.
When you declare a class the parent class or classes are specified by the name after a `:`.


.source of snippet `inherit1`
[source]
----
class P {
    fn a()=1
    mut v = 2
}
class C : P {
    fn b()=3
    mut z = 4
}
mut o = C();
println o.a(),o.v,o.b(),o.z;


----




.output of snippet `inherit1`
[source]
----
1234

----



You can use the methods or fields declared in the class as well as any other method and fields defined in the parent classes.
You can inherit from multiple parent classes:


.source of snippet `inherit2`
[source]
----
class P1 {
    fn a()=1
    mut v = 2
}
class P2 {
    fn aa()=3
    mut vv = 4
}
class C : P1,P2 {
    fn b()=5
    mut z = 6
}
mut o = C();
println o.a(), o.v, o.aa(), o.vv, o.b(), o.z;


----




.output of snippet `inherit2`
[source]
----
123456

----



Inheritance is ordered.
It is important when there are multiple implementations of the same method name or the same field.


.source of snippet `inherit3`
[source]
----
class P1 {
    fn a()=1
    mut v = 2
}
class P2 {
    fn a()=3
    mut v = 4
}
class C : P1,P2 {
    fn b()=5
    mut z = 6
}
mut o = C();
println o.a(), o.v, o.b(), o.z;


----




.output of snippet `inherit3`
[source]
----
1256

----



In the example `P1` is inherited/extended first in the list, so it prevails over `P2` when there is a name collision.

Initializing a class having parent classes is not trivial.
Since there can be, and in the example there are multiple parents, the initialization does not automatically invoke the initialization of the parent classes.


.source of snippet `inherit4`
[source]
----
class P1 {
    fn init {
        println "init in P1, cls='%s' this='%s'" % [cls, this]
    }
}
class P2 {
    fn init {
        println "init in P2, cls='%s' this='%s'" % [cls, this]
    }
}
class C : P1,P2 {
    fn init {
        println "init in C, cls='%s' this='%s'" % [cls, this]
    }
}
mut o = C();


----




.output of snippet `inherit4`
[source]
----
init in C, cls='class C' this='{cls: class C}'

----



You can invoke them directly:


.source of snippet `inherit5`
[source]
----
class P1 {
    fn init {
        println "init in P1, cls='%s' this='%s'" % [cls, this]
    }
}
class P2 {
    fn init {
        println "init in P2, cls='%s' this='%s'" % [cls, this]
    }
}
class C : P1,P2 {
    fn init {
        println "init in C, cls='%s' this='%s'" % [cls, this]
        P1.init()
        P2.init()
    }
}
mut o = C();


----




.output of snippet `inherit5`
[source]
----
init in C, cls='class C' this='{cls: class C}'
init in P1, cls='class P1' this='{cls: class C}'
init in P2, cls='class P2' this='{cls: class C}'

----



If a class does not implement `init` but some of the parent classes do, then it will be invoked.


.source of snippet `inherit6`
[source]
----
class P {
    fn init {
        println "init in P, cls='%s' this='%s'" % [cls, this]
    }
}
class C : P {
}
mut o = C();


----




.output of snippet `inherit6`
[source]
----
init in P, cls='class C' this='{cls: class C}'

----



Note the difference in the value of the field `cls`.
When the parent class `init` is invoked directly from the child `init` the `cls` points to the parent.
When it is inherited, the `init` is executed in the context of the child class; it is simply inherited, hence the value of the field `cls` points to the child class.

When a class has parent class or classes, the class methods and fields are inherited, but there is only one single `this` object.
There is a single set of object fields.
Object fields do not "shadow" each other, because there is only one field for a given name.


.source of snippet `inherit7`
[source]
----
class P {
    fn init(a,b);
}
class C : P {
    fn init(b,c){
        P.init(3,4)
    }
}

let object = C(1,2);
print object


----




.output of snippet `inherit7`
[source]
----
{a: 3, b: 4, c: 2, cls: class C}
----



In the example `b` is `4`, even though it is initialized to be `1` when calling the initializer of `C` but it is overwritten when the `P` initializer is invoked.

There is no restriction on which other classes initializers can or should an initializer invoke.
Your code theoretically could call the initializer of a class the current does not extend.

The object fields are created when the initializers are invoked.
The type declaration of a parent class may not be the same for a field as in the child class.
In this case the type definition of the field will be the union of the types.


.source of snippet `inherit8`
[source]
----
class Parent {
    fn init(b:str){
        }
}
class Child : Parent {
    fn init(b:num){
        Parent.init("mutabor")
        this
    }
}

let k = Child(42);
try: k.b = none; // will fail as it is num and str, which
catch e: println e; // we should see in the error


----




.output of snippet `inherit8`
[source]
----
Cannot set variable 'b' to value 'none' because it does not fit any of the declared types of the variable (num|str)

----



The field `b` is declared to be a number in the class `Child` but it also inherits the type `str` through the invocation of the initializer of `Parent`.

== Error Handling

Error handling is similar to Java.
If an error happens, an exception is thrown.
An exception can be caught using `catch` pairing with a `try`.

An exception is an object.
You can declare a variable to hold an error


.source of snippet `try3`
[source]
----
try{
        z = 55 // undefined variable
}catch x : mut error:err = x

println error



----




.output of snippet `try3`
[source]
----
Variable 'z' is not defined.

----



The predefined type for an exception is `err`.

An exception has

* `stack_trace`

* `message`

* `cause`, and

* `supressed` fields.

`stack_trace` is a list (`lst`), each element is an object with the fields:

* `file`
* `line`
* `column`
* `source`


.source of snippet `try4`
[source]
----
try{
        z = 55 // undefined variable
}catch error: ;

println """message "%s" """ % [error.message]
println """cause "%s" """ % [error.cause]
println """suppressed %s" """ % [error.suppressed]
for each st in error.stack_trace {
    println("%s:%s:%s" % [st.file, st.line, st.column])
    println "source: ", st.source
    }




----




.output of snippet `try4`
[source]
----
message "Variable 'z' is not defined." 
cause "none" 
suppressed []" 
try4.turi:2:9
source:         z = 55 // undefined variable
try4.turi:1:4
source: try{
try4.turi:1:4
source: try{
try4.turi:1:4
source: try{

----



=== Try-Catch

Try is very similar to Java `try`-`catch`-`finally`.
The command `try` tries to execute a block.
If an exception happens it executes the block following the keyword `catch`.
At the end it executes the block following the `finally` keyword.

The syntax of the command is

[source]
----
try ( ':' COMMAND | BLOCK ) [catch [exception_variable] (':' COMMAND | BLOCK)] [finally (':' COMMAND | BLOCK)]
----

The command is executed in the same context as the whole try-catch command.
If, however, a block between `+{+` and `+}+` is used, it will create its own context.
In this case the use of the `:` is optional and is also discouraged, as clutter.

If there is an exception variable specified, it will be defined when the exception is caught.
This is same as defining a variable using the `let` command.
It will hold the value of the exception during the execution of the catch part and after the whole try-catch command.
If there was no exception the value of this variable will be `none`.

The exception variable can be defined as `catch(e)` with parentheses to be a bit more familiar for Java developers.

If an exception happens, the execution of the try command stops, the exception variable will get the exception object and the catch block starts to execute.
The exception variable is not available during the execution of the try command.

The exception variable is pinned, cannot be modified.

The value of the try-catch command is

* the value of the try command if there was no exception, and
* the value of the catch command if there was an exception.

The command after the `finally` keyword does not affect the result of the command.

Also note that the execution of the `try` command has an atomic nature.


.source of snippet `try6`
[source]
----
try : (mut a = 1;
       mut b = 2;
       mut c = 1 / 0;
      )
catch e : println e;

println "Do we have a? ", is_defined(a)
println "Do we have b? ", is_defined(b)
println "Do we have c? ", is_defined(c)


----




.output of snippet `try6`
[source]
----
Cannot divide by zero
Do we have a? false
Do we have b? false
Do we have c? false

----



In the example above, the local variables defined in the expression are not defined afterward because an error, division by zero, has happened.

The next example shows how this atomic behavior works.


.source of snippet `try7`
[source]
----
mut a = 3;
try : (mut a = 1;
       println "we redefined 'a'"
       mut b = 2;
       println "we defined 'b'"
      )
catch e : println e;

println "Do we have a? ", is_defined(a)
println "Was it changed or still 3? It is ",a
println "Do we have b? ", is_defined(b)


----




.output of snippet `try7`
[source]
----
Variable 'a' is already defined.
Do we have a? true
Was it changed or still 3? It is 3
Do we have b? false

----



When the code following the `try` executes it opens a new context.
This context is a so-called shadow context.
It wraps the surrounding context.
When you define a new variable in this context, it checks not only this context but also the surrounding context to see whether the variable is already defined.

To be precise, it checks not only the surrounding shadow context but all shadow contexts wrapped in the line.
It has effect when `try` commands are nested.

When and if the `try` command finishes successfully the variables from the shadow context are moved to the wrapped context, one level higher.


== Decorators, Metaprogramming

Decorators are an inherent part of Turicum.
To make them similar to Python decorators and Java annotation, they can have a `@` in front of the decorator function call.
However, in the case of closures, you do not even need that.
Every function call that has a closure as the last parameter can act as a decorator.


.source of snippet `closureDecorator1`
[source]
----
fn closure_decorator(^closure){
  {|| println("We start"); closure(); println("We finish")}
}

mut z = closure_decorator(){|| println("We are closure") }

z()


----




.output of snippet `closureDecorator1`
[source]
----
We start
We are closure
We finish

----



If you add a `@` then the result is the same:


.source of snippet `closureDecorator2`
[source]
----
fn closure_decorator(^closure){
  {|| println("We start@"); closure(); println("We finish@")}
}

mut z = @closure_decorator(){|| println("We are closure") }

z()


----




.output of snippet `closureDecorator2`
[source]
----
We start@
We are closure
We finish@

----



The `@` helps you emphasize that the call is a decorator call that modifies the closure following it.
The use of `@` also notifies the syntax analyzer that the call is a decorator call, and it extends the recognition of the following `^closure` parameter.
When the `@` precedes the function call, a `fn` or `class` are also recognized as `^closure` parameter,
and you do not need to enclose them between `+{+` and `+}+`.


.source of snippet `fnDecorator1`
[source]
----
  fn fun_decorator(^closure){
    {|| println("We start the fun"); closure(); println("The fun is over")}
  }

mut z =
@fun_decorator()
fn q(){
  println("We function");
}
  z()


----




.output of snippet `fnDecorator1`
[source]
----
We start the fun
We function
The fun is over

----



Without the `@` the program is still valid.
However, as soon as we try to invoke `z()` the program fails.
It tries to invoke the closure returned by `fun_decorator()`, which tries to call `closure()` which now has the value `none`.
This happens because the syntax analysis does not use the function definition as a parameter.

The code can, however, be fixed:


.source of snippet `fnDecorator2`
[source]
----
  fn fun_decorator(^closure){
    {|| println("We start the fun"); closure(); println("The fun is over")}
  }

mut z =
fun_decorator(
fn q(){
  println("We function");
})
  z()


----




.output of snippet `fnDecorator2`
[source]
----
We start the fun
We function
The fun is over

----



The application of the `@` is therefore only a syntactic sugar.
The following example shows that a decorator cannot only return the decorated 0, class, or closure.
They can also modify the existing definition.


.source of snippet `fnDecorator3`
[source]
----
mut fun_decorator={|^closure|
        set(closure.name,
            {|| println("We start the fun"); closure(); println("The fun is over")}
           )
    }

@fun_decorator()
fn q(){
  println("We function");
}

q()


----




.output of snippet `fnDecorator3`
[source]
----
We start the fun
We function
The fun is over

----



Technically the decorator does not modify the function `q`.
It creates a new function and redefines the variable named `q` in the wrapped context.

Note, that if `fun_decorator` was a function declared with `fn` it would not work.
A function does not wrap the surrounding context and thus cannot redefine anything in it.
To redefine an already existing variable, it needs to be a closure.

You usually just assign a value to the variable updating its value.
In this case we have to use the built-in `set` function, because we have the name of the variable as a string.

In the following example we moved the function definition to a local context.
The decorator in this case simply defines the global variable of the same name as we used locally for the function.
The value is the closure or function, whatever we decorate itself.


.source of snippet `fnDecorator4`
[source]
----
{
    fn globalize(^closure){
            set_global(closure.name,closure)
        }

    @globalize()
    fn q(){
      println("We function");
    }
}
q()


----




.output of snippet `fnDecorator4`
[source]
----
We function

----



Since we use `set_global` the decorator can be a function, it does not need access to the enclosing context.

=== Macro and Reclose

The built-in functions `macro` and `reclose` are special closure conversion functions.

The function `macro()` accepts a closure as an argument and returns the closure converted to a macro.
The major difference between ordinary macros and closures is that the argumente of a closure are evaluated before starting.
A macro gets its arguments unevaluated.

=== Special variables

There are a few predefined variables, constants, and some special variables.

* `true`
 has the constant boolean __true__ value.
* `false`
 has the constant boolean __false__ value.

* `none`
 is the undefined value.
 The Java representation of the undefined value is `null`.

* `inf`
 is the infinite numeric value.

* `fini`
 is the special value that, when returned from a cell command, prevents the cell from updating,
 but it also signals that this cell is stopped, should not be evaluated any further

* `non_mutat`
 is the special value that, when returned from a cell command, prevents the cell from updating
 its value and halts propagation to dependent cells in a flow.

* `nan`
 is the special IEEE-754 * `not a number* ` floating-point value.



The special variables are not constants.
They are defined dynamically to represent the current computing environment.
These are the following:

* `this`

* `cls`

* `that` will point to the object on which a method was called when the method is a class constructor.
Class constructors are invoked using the name of the class.
When a class name is used as a field in an object either directly injected to the object or as a class field as in the next example, then the constructor can access the target object of the call through `that`.
+

.source of snippet `that`
[source]
----
class OuterClass {
    mut name = "outer class";
    fn init(){
      mut name = "outer object"
    }
    class InnerClass {
        mut name = "inner class";
        fn init() {
            mut name = "inner object"
            println("this name %s " % this.name)
            println("this name %s " % cls.name)
            println("this name %s " % that.name)
            println("this name %s " % that.cls.name)
            }
        }
    }
mut outer = OuterClass()
mut inner = outer.InnerClass()


----




+
.output of snippet `that`
[source]
----
this name inner object 
this name inner class 
this name outer object 
this name outer class 

----


+
Usually the target object is called `this`, but in the case of the constructor `this` points to the current object to be initialized.
What is more, the constructor, always named `init()`, is allowed to modify the variable `this`.
In this environment `this` cannot be used for both the object to be initialized and the target object.
Hence, the special variable `that` was introduced.
+
You will hardly ever need it.

* `me` it always points to the currently executing function or closure.
You can use it to furnish recursive calls.
It is necessary when a function is defined in a local context it does not capture.
For more read the next section Function scopes and `me`.

=== Function scopes and `me`

Functions are usually defined in the global context or as methods inside classes.
In both cases there is a wrapped context that contains the name of the function defined.
It is either the global context or the class context.

The following example is very straightforward.
It defines the function `fib()`, that calls itself recursively.


.source of snippet `fibonacci1`
[source]
----
fn fib(x) {
    if x == 1 || x == 0 : 1
    else: fib(x - 1) + fib(x - 2)
}
println(fib(10))


----




.output of snippet `fibonacci1`
[source]
----
89

----



If we create the same program using a class memoizing the results:


.source of snippet `fibonacci2`
[source]
----
class FibCalculator {
    mut cache = [];
    fn fib(x) {
        if x == 1 || x == 0 : 1
        else{
            return cache[x] when cache[x] != none;
            cache[x] = fib(x - 1) + fib(x - 2);
        }
    }
}
println(FibCalculator.fib(10))


----




.output of snippet `fibonacci2`
[source]
----
89

----



we get the same result and there is no problem with that.
In this case `fib()` is a class level method, and when we call it Turicum automatically calls it as a method.

The difficulty comes when you define the function in a local context.


.source of snippet `fibonacci3`
[source]
----
try
{
    fn fib(x) {
        if x == 1 || x == 0 : 1
        else: fib(x - 1) + fib(x - 2)
    }
    println(fib(10))
}catch ex : println(ex)


----




.output of snippet `fibonacci3`
[source]
----
Variable 'fib' is undefined.

----



The function does not see itself.
The function `fib` in this case is defined in the local context of the block, and functions do not wrap the surrounding context.
One solution can be to convert the function to a closure:


.source of snippet `fibonacci4`
[source]
----
{
    mut fib={|x|
        if x == 1 || x == 0 : 1
        else: fib(x - 1) + fib(x - 2)
    }
    println(fib(10))
}


----




.output of snippet `fibonacci4`
[source]
----
89

----



Closures wrap the surrounding context, therefore, the body of the closure knows the value of `fib`, which is the closure itself.
If you do not want to wrap the whole context, you can do a little trick using functions.


.source of snippet `fibonacci5`
[source]
----
{
    fn fib(x,fib=fib) {
        if x == 1 || x == 0 : 1
        else: fib(x - 1) + fib(x - 2)
    }
    println(fib(10))
}


----




.output of snippet `fibonacci5`
[source]
----
89

----



The function `fib` has an extra optional parameter.
The left side of the `fib=fib` is the name of the parameter, which will become a variable in the context of the function.
The right side is the default value, which is evaluated in the caller context before the call.

One can like this approach, for explicitly declaring that `fib` needs access to `fib` hence a recursive call.
Others can find it cryptic,
and it is not really clear
without knowing the details how contexts and default values for variable declarations work in Turicum.

An alternative possibility is to use the special variable `me`.


.source of snippet `fibonacci6`
[source]
----
{
    fn fib(x) {
        if x == 1 || x == 0 : 1
        else: me(x - 1) + me(x - 2)
    }
    println(fib(10))
}


----




.output of snippet `fibonacci6`
[source]
----
89

----



This variable is reserved for this purpose, and it gets the function itself as its value before a function is called.
It can also be appealing that the recursive call is explicit whatever the name of the function is, not needing renaming when the function is renamed.

As an extra, here is a version of the fibonacci calculation using a closure with a retained local context as a state instead of a class:


.source of snippet `fibonacci7`
[source]
----
mut fib = {
    mut cache = [];
    {|x|
        if x == 1 || x == 0 : 1
        else{
            return cache[x] if cache[x] != none;
            cache[x] = me(x - 1) + me(x - 2);
        }
    }
}
println(fib(10))


----




.output of snippet `fibonacci7`
[source]
----
89

----



Finally, here is a modified fibonacci calculation that can replace the start value and uses an object cache instead of class level cache.


.source of snippet `fibonacci8`
[source]
----
class FibCalculator {
    fn init(start=1) {
        mut cache = [];
    }
    fn fib(x) {
        if x == 1 || x == 0 : start
        else{
            return cache[x] if cache[x] != none;
            cache[x] = fib(x - 1) + fib(x - 2);
        }
    }
}
println(FibCalculator().fib(10))
println(FibCalculator(2).fib(10))


----




We do not include here the printout.
The first number you already know, try to guess the second, then run the code yourself.

== String Functions

Turicum defines many methods to handle strings.
These methods can be called on the string objects as methods.

            * `to_string` 
 returns the string itself. This method exists so that you can use it like on any other objects.
            * `after` 
 returns the part of the string that follows the argument string.
 If the argument string is not in the string, then it returns an empty string.
            * `before` 
 returns the part of the string that is before the argument string.
 If the argument string is not in the string, then it returns an empty string.
            * `pad_left` 
 add characters on the left of the string to get the desired length.
 You can specify only the number of the characters to pad with spaces.
 Alternatively, you can also specify a string and the desired total length of the result.
 The string is supposed to be a single character, but it can be any length.
 If the necessary number of padding characters is not the multiple of string length, the resulting string may be shorter than desired.
            * `pad_right` 
 add character to the right of the string to get the desired length.
 This method works the same way as `pad_left`, but it appends the characters.
            * `between` 
 returns the part of the string that is between two specific strings.
 if one of the parameter strings is not found in the string, the result is empty string.
            * `lines` 
 returns a list containing the lines of the string.
            * `words` 
 returns a list containing the words of the string.
            * `turi_lex` 
 returns a list containing the tokens of the string matching the tokenization of the language (Turicum).
            * `execute` 
 executes the string as Turicum code.
            * `url_encode` 
 encode the string for URL
            * `url_decode` 
 decode the string from URL-encoded form
            * `md5` 
 calculate the md5 hash of the string
            * `sha_1` 
 calculate the sha-1 hash of the string
            * `sha_256` 
 calculate the sha-256 hash of the string
            * `sha_512` 
 calculate the sha-512 hash of the string
            * `digest` 
 calculate the hash of the string. The algorithm name has to be provided as argument.
            * `base64` 
 base64 encode the string
            * `from_base64` 
 create a list of numbers (bytes) from a base64 encoded string
            * `from_base64_str` 
 create a string from a base64 encoded string
            * `contains` 
 returns `true` if the string contains the argument.
            * `is_blank` 
 returns `true` if the string is blank
            * `is_empty` 
 returns `true` if the string is empty
            * `is_numeric` 
 returns `true` if the string holds a decimal numeric value, either integer or floating point formatted.
            * `is_digit` 
 returns `true` if the string contains only digits
            * `is_alpha` 
 returns `true` if the string contains only alpha characters
            * `is_alphanumeric` 
 returns `true` if the string contains only alphanumeric characters
            * `is_hex` 
 returns `true` if the string contains only hexadecimal characters
            * `int` 
 returns the integer value of the string
            * `float` 
 returns the floating number contained in the string
            * `number` 
 returns the number contained in the string encoded with the argument radix
            * `hex` 
 returns the number contained in the string as a hexadecimal number.
 It is not the same as calling `"0AF6"number(16)` because this method respects the leading `0x` if there is any.
            * `substring` 
 retruns a substring of the string.
 There has to be at least one (`a`), and there can be at most two (`a`,`b`) integer arguments.
 The substring starts at the character indexed `a` and finishes before the character `b`.
 If there is no `b`, the substring lasts till the end of the string.
 The implementation honors overindexing and returns characters only to the end of the string or an empty string.
            * `remove_prefix` 
 removes the argument from the string if that is a prefix of the string.
            * `remove_postfix` 
 removes the argument from the string if that is a postfix of the string.
            * `count_substring` 
 counts the occurrences of the argument string.
 Note that when an occurrence is found the other occurrences are sought for after that occurrence.
 It means that, for example, `("a"*6).count_substring("aa")` is 3 and not 5.
            * `count_substring_overlap` 
 counts all the occurrences of the argument string, even if they overlap
 It means that, for example, `("a"*6).count_substring("aa")` is 5.
            * `left` 
 return the left of the string.
 This method uses the argument as a number and returns the string that contains at most that number of characters.
 Essentially, the `string.left(n)` is the `n` leftmost characters if `n` is smaller than the number of characters in the string.
 If `n` is equal to, or larger than the number of characters in the string, then the whole string is the result.
            * `right` 
 return the right of the string.
 This method uses the argument as a number and returns the string that contains at most that number of characters.
 Essentially, the `string.right(n)` is the `n` rightmost characters if `n` is smaller than the number of characters in the string.
 If `n` is equal to, or larger than the number of characters in the string, then the whole string is the result.
            * `replace_all` 
 replaces the occurrences of the first argument interpreted as regular expression with the second argument interpreted as string.
            * `quote` 
 quotes the special characters in the string.
 The result is a string that can be used in a string literal to represent the original string.
            * `reverse` 
 returns the string that contains the same characters as the original string, but in reverse order.
            * `chop` 
 returns string without the last character
            * `chomp` 
 returns the string without the last new-line character.
 If the last character is not a new line character, the original string is returned.
            * `times` 
 repeat the string as specified by the argument. `"x".times(3)` is `"xxx"`.
            * `lower_case` 
 return the string lower-cased character.
            * `upper_case` 
 return the string upper-cased characters.
            * `trim` 
 return the string with spaces removed from the start and the end.
            * `starts_with` 
 return `true` if the string starts with the specified string.
            * `ends_with` 
 return `true` if the string ends with the specified string.
            * `split` 
 split the string into a list using the argument as a regular expression.
            * `bytes` 
 return a list that contains the bytes of the string using UTF-8 character encoding.
            * `join` 
 joins the elements of the argument list using the string as a separator/joiner character.
            * `char_at` 
 get the character at the given position.
            * `safe_char_at` 
 get the character at the given position or an empty string if the index is out of range.
            * `index_of` 
 return the first position of the argument string, or -1 if the argument string cannot be found in the original string.
            * `last_index_of` 
 return the last position of the argument string, or -1 if the argument string cannot be found in the original string.




.source of snippet `string_functions`
[source]
----
println " 1. ","alma kadarka".after("ka")
println " 2. ","alma kadarka".before("ka")
println " 3. ","alma kadarka".between("ma","da")
println " 4. ","aa ".times(6)
println " 5. "," aa ".trim()
println " 6. ","aa ".starts_with("a")
println " 7. ","aa".ends_with("a")
println " 8. ","AA".lower_case()
println " 9. ","aa".upper_case()
println "10. ","a,b,c,d".split(",")
println "11. ","abcd".bytes()
println "12. ","abc".char_at(2), " is c"
println "13. ","alma kadarka".index_of("ka")
println "14. ","alma kadarka".last_index_of("ka")
println "15. ","alma kadarka".replace_all("a|d","e")
println "16. ","\n\t\r".quote()
println "17. ","alma kadarka".reverse()
println "18. ","alma kadarka".chop().chop()
println "19. ","alma kadarka\n".chomp()
println "20. ","alma kadarka".chomp()
println "21. ","alma kadarka".contains("ma ka")
println "22. ","alma kadarka".left(4)
println "23. ","alma kadarka".right(4)
println "24. ","alma kadarka".count_substring("a")
println "25. ","kadarka".pad_left(12)
println "26. ","kadarka".pad_left(".",12)
println "27. ","kadarka".pad_right(12) + "<"
println "28. ","kadarka".pad_right(".",12)
println "29. ","   ".is_blank()
println "30. ","   ".is_empty()
println "31. ","+6.2E23".is_numeric()
println "32. ","+6.2E23".is_digit()
println "33. ","6223".is_digit()
println "34. ","Euler Number".is_numeric()
println "35. ","EulerNumber".is_alpha()
println "36. ","EulerNumberisnot314".is_alphanumeric()
println "37. ","2AF".is_hex()
println "38. ","0x2AF".is_hex()
println "39. ","2AF".hex()
println "40. ","0x2AF".hex()
println "41. ","0x2AF".base64()
println "42. ","MHgyQUY=".from_base64()
println "43. ","MHgyQUY=".from_base64_str()
println "44. ","alma van a fa = alarr://".url_encode()
println "45. ","alma+van+a+fa+%3D+alarr%3A%2F%2F".url_decode()
println "46. ","line 1\nline2\n\nline4".lines()
println "47. ","What do you read, my lord? Words, words, words.".words()
println "48. ","alma kadarka".remove_prefix("alma")
println "49. ","alma kadarka".remove_postfix("kadarka")
println "50. ","alma kadarka".remove_prefix("apple")
println "51. ","alma kadarka".remove_postfix("kik")
println "52. ",">" + ("alma".safe_char_at(666)) + "<"
println "53. ",",".join(["abrak","a","dabra","lonak","zabla"])
println "54. ","aaa".md5()
println "55. ","aaa".sha_1()
println "56. ","aaa".sha_256()
println "57. ","aaa".sha_512()
println "60. ","aaa".digest("MD5")
println "61. ",61.hex()
println "62. ","mut z = if a == 3 :  3 else: 5;".turi_lex()
println "63. ","mut M= \"\"; for i=0 ; i < 8 ; i++ : M = M + i; M".execute()
println "64. ",M
println "65. ","65".int() , "is 65... literally"
println "65. ","3.14".float(), " is 3.14"
println "66. ","0765".number(8), " is ", 8*8*7+8*6+5


----




.output of snippet `string_functions`
[source]
----
 1. darka
 2. alma 
 3.  ka
 4. aa aa aa aa aa aa 
 5. aa
 6. true
 7. true
 8. aa
 9. AA
10. [a, b, c, d]
11. [97, 98, 99, 100]
12. c is c
13. 5
14. 10
15. elme keeerke
16. \n\t\r
17. akradak amla
18. alma kadar
19. alma kadarka
20. alma kadarka
21. true
22. alma
23. arka
24. 5
25.      kadarka
26. .....kadarka
27. kadarka     <
28. kadarka.....
29. true
30. false
31. true
32. false
33. true
34. false
35. true
36. true
37. true
38. true
39. 687
40. 687
41. MHgyQUY=
42. [48, 120, 50, 65, 70]
43. 0x2AF
44. alma+van+a+fa+%3D+alarr%3A%2F%2F
45. alma van a fa = alarr://
46. [line 1, line2, , line4]
47. [What, do, you, read, my, lord, Words, words, words, ]
48.  kadarka
49. alma 
50. alma kadarka
51. alma kadarka
52. ><
53. abrak,a,dabra,lonak,zabla
54. 47bce5c74f589f4867dbd57e9ca9f808
55. 7e240de74fb1ed08fa08d38063f6a6a91462a815
56. 9834876dcfb05cb167a5c24953eba58c4ac89b1adf57f28f2f9d09af107ee8f0
57. d6f644b19812e97b5d871658d6d3400ecd4787faeb9b8990c1e7608288664be77257104a58d033bcf1a0e0945ff06468ebe53e2dff36e248424c7273117dac09
60. 47bce5c74f589f4867dbd57e9ca9f808
61. 0x3D
62. [Lex{types=RESERVED, text='mut'}, Lex{types=IDENTIFIER, text='z'}, Lex{types=RESERVED, text='='}, Lex{types=RESERVED, text='if'}, Lex{types=IDENTIFIER, text='a'}, Lex{types=RESERVED, text='=='}, Lex{types=INTEGER, text='3'}, Lex{types=RESERVED, text=':'}, Lex{types=INTEGER, text='3'}, Lex{types=RESERVED, text='else'}, Lex{types=RESERVED, text=':'}, Lex{types=INTEGER, text='5'}, Lex{types=RESERVED, text=';'}]
63. 01234567
64. 01234567
65. 65is 65... literally
65. 3.14 is 3.14
66. 501 is 501

----



== Built-in Functions

Built-in functions are functions provided by the interpreter, which extend the functionality of the run-time.

=== Mathematical Functions

All mathematical functions from Java's Math class are available in Turicum:

* `acos(x)` - Returns the arc cosine of a value
* `asin(x)` - Returns the arc sine of a value
* `atan(x)` - Returns the arc tangent of a value
* `atan2(y,x)` - Returns the angle theta from the conversion of rectangular coordinates (x,y) to polar coordinates
* `cbrt(x)` - Returns the cube root of a value
* `ceil(x)` - Returns the smallest integer greater than or equal to the argument
* `copy_sign(magnitude,sign)` - Returns first argument with the sign of the second argument
* `cos(x)` - Returns the trigonometric cosine of an angle
* `cosh(x)` - Returns the hyperbolic cosine of x
* `exp(x)` - Returns Euler's number e raised to the power of x
* `floor(x)` - Returns the largest integer less than or equal to the argument
* `get_exponent(x)` - Returns the unbiased exponent used in the representation of a floating point number
* `hypot(x,y)` - Returns sqrt(x^2 + y^2) without intermediate overflow or underflow
* `ieee_remainder(x,y)` - Returns the IEEE 754 floating-point remainder of division
* `log(x)` - Returns the natural logarithm (base e) of x
* `log10(x)` - Returns the base 10 logarithm of x
* `next_after(start,direction)` - Returns the floating-point number adjacent to start in the direction of direction
* `next_down(x)` - Returns the floating-point value adjacent to x in the direction of negative infinity
* `next_up(x)` - Returns the floating-point value adjacent to x in the direction of positive infinity
* `pow(x,y)` - Returns the value of x raised to the power of y
* `random()` - Returns a random number between 0.0 and 1.0
* `rint(x)` - Returns the closest integer to x (as a double)
* `round(x)` - Returns the closest integer to x (as a long)
* `scalb(x,scaleFactor)` - Returns x * 2^scaleFactor
* `sig_num(x)` - Returns the signum function of x
* `sin(x)` - Returns the trigonometric sine of an angle
* `sinh(x)` - Returns the hyperbolic sine of x
* `sqrt(x)` - Returns the square root of x
* `tan(x)` - Returns the trigonometric tangent of an angle
* `tanh(x)` - Returns the hyperbolic tangent of x
* `to_degrees(x)` - Converts an angle measured in radians to degrees
* `to_radians(x)` - Converts an angle measured in degrees to radians
* `ulp(x)` - Returns the size of an ulp (unit in last place) of x


.source of snippet `math_functions`
[source]
----
println "Testing math functions:"
println "sin(1) = ", sin(1)
println "cos(1) = ", cos(1)
println "acos(0.5) = ", acos(0.5)
println "asin(0.5) = ", asin(0.5)
println "atan(1) = ", atan(1)
println "atan2(1,1) = ", atan2(1,1)
println "cbrt(27) = ", cbrt(27)
println "ceil(3.2) = ", ceil(3.2)
println "abs(-3) = ", abs(-3)
println "exp(1) = ", exp(1)
println "floor(3.8) = ", floor(3.8)
println "log(2.718281828459045) = ", log(2.718281828459045)
println "log10(100) = ", log10(100)
println "sqrt(16) = ", sqrt(16)
println "tan(1) = ", tan(1)
println "tanh(1) = ", tanh(1)
println "sinh(1) = ", sinh(1)
println "cosh(1) = ", cosh(1)
println "to_degrees(3.14159) = ", to_degrees(3.14159)
println "to_radians(180) = ", to_radians(180)
println "pow(3,3) =", pow(3,3)
println "copy_sign(3.5,-2.1) = ", copy_sign(3.5,-2.1)
println "get_exponent(123.456) = ", get_exponent(123.456)
println "hypot(3,4) = ", hypot(3,4)
println "ieee_remainder(5,2) = ", ieee_remainder(5,2)
println "next_after(1.0,2.0) = ", next_after(1.0,2.0)
println "next_down(1.0) = ", next_down(1.0)
println "next_up(1.0) = ", next_up(1.0)
println "random() = ", random()
println "rint(3.7) = ", rint(3.7)
println "round(3.7) = ", round(3.7)
println "signum(-3.7) = ", signum(-3.7)
println "ulp(1.0) = ", ulp(1.0)
println "scalb(2.0,3) = ", scalb(2.0,3)


----




.output of snippet `math_functions`
[source]
----
Testing math functions:
sin(1) = 0.8414709848078965
cos(1) = 0.5403023058681398
acos(0.5) = 1.0471975511965979
asin(0.5) = 0.5235987755982989
atan(1) = 0.7853981633974483
atan2(1,1) = 0.7853981633974483
cbrt(27) = 3.0
ceil(3.2) = 4.0
abs(-3) = 3.0
exp(1) = 2.7182818284590455
floor(3.8) = 3.0
log(2.718281828459045) = 1.0
log10(100) = 2.0
sqrt(16) = 4.0
tan(1) = 1.5574077246549023
tanh(1) = 0.7615941559557649
sinh(1) = 1.1752011936438014
cosh(1) = 1.543080634815244
to_degrees(3.14159) = 179.9998479605043
to_radians(180) = 3.141592653589793
pow(3,3) =27.0
copy_sign(3.5,-2.1) = -3.5
get_exponent(123.456) = 6
hypot(3,4) = 5.0
ieee_remainder(5,2) = 1.0
next_after(1.0,2.0) = 1.0000000000000002
next_down(1.0) = 0.9999999999999999
next_up(1.0) = 1.0000000000000002
random() = 0.48106627585899775
rint(3.7) = 4.0
round(3.7) = 4
signum(-3.7) = -1.0
ulp(1.0) = 2.220446049250313E-16
scalb(2.0,3) = 16.0

----




=== `all_parents`

Returns a list of classes that are the parent classes of the argument with a transitive closure.
It means that all classes, including the parents of the parents and so on, recursively.


.source of snippet `all_parents`
[source]
----
class A {}
class B : A {}
mut K = class : B {}
println all_parents(K)
println([ ..all_parents(K) -> type(it()) ])


----




.output of snippet `all_parents`
[source]
----
[class B, class A]
[B, A]

----



The classes are ordered in inheritance order.

=== `die`

This function will throw an exception.
The argument is the message of the exception.
The naming of the function is a tribute to the programming language Perl.
If you feel the naming offensive, you can use the lame `throw` form after importing it:


.source of snippet `die`
[source]
----

sys_import "turi.throw"

try:
    throw "wuff"
catch ex:
    print "don't die"


----




.output of snippet `die`
[source]
----
don't die
----




=== `evaluate`

Macro implementations use this function.
Macros get their arguments unevaluated and can use this function to evaluate them.
If you try to evaluate anything other than a macro argument, you will get an error.


.source of snippet `evaluate1`
[source]
----
mut twice = macro(fn (arg){ evaluate(arg); evaluate(arg);});
twice( {println("Hello")} )


----




.output of snippet `evaluate1`
[source]
----
Hello
Hello

----



The following example uses all the possible tools that can appear in a macro and a function.
The actual functionality is basic: it just invokes the closure or function provided as the first argument with the rest of the arguments passed on.
In real life you could just call the function itself without making it through a macro, but in this case we focus on doing that and how.

The unnamed function, which is the argument of the macro, has a mandatory, position-only argument and all the three extra arguments.
The first argument will be the function or closure we will call.
The function first called `evaluate` to get the function or closure.
Since this function is never called as a function, only after it is converted to be a macro, the argument is never a function, but a function definition.
Evaluating it will result in the function.

When we call this function adding `(..rest,..meta,..closure)` after it, we spread the extra parameters.
In this example the three argument values for these parameters are

* `+{}+` empty object,
* `[]` empty list, and
* `none`

None of them adds extra parameters when spread.


.source of snippet `evaluate2`
[source]
----
macro(fn (!arg,[rest],{meta},^closure)
            { evaluate(arg)(..rest,..meta,..closure)}
     )(fn () {println("Hello")})


----




.output of snippet `evaluate2`
[source]
----
Hello

----



To be honest, since the evaluation of the argument happens only once and without condition, this functionality does not really need a macro.
It could be shortened as


.source of snippet `evaluate3`
[source]
----
(fn (!arg,[rest],{meta},^closure)
            { arg(..rest,..meta,..closure)})
     (fn () {println("Hello")})


----




.output of snippet `evaluate3`
[source]
----
Hello

----



Note, however that the code starts with a `(`.
That will make the function definition be part of an expression and process the following `(fn () {println("Hello")})` as an argument.
Without that we would have two unnamed function definitions, one after the other.

[NOTE]
====
The first design required enclosing a function definition like the one above to be enclosed between `+{+` and `+}+` to be part of an expression.
In most of the cases, like assigning a function to a variable would require superfluous `+{+` and `+}+` braces.
The philosophy of Turicum is to be dense and use extra characters where it helps readability or avoids syntax ambiguity.

Omitting the requirement around a `fn` (or for that matter a `class`) definition inside an expression make the language leaner, but this does not make a function or class definition to be an expression itself.
====

=== `export`, `export_all`

These are two functions to be used in files imported.
The macro `export` will export the variables listed as arguments.
That way these variables will be copied into the context of the importing code.

You can specify identifiers and expressions resulting in strings as arguments.

`export_all()` will export all the variables from the importing context.
Note that in the case of `export_all()` you cannot omit the `(` and `)`.

=== `import`

Import allows you to get definitions from external files into your code.

When you have a large application, you can separate some of the function definitions or classes into separate files.
These separate files can be referenced, and the definitions from these can be loaded into the currently running interpreter.

The function `import` searches the file looking at each directory listed in the environment variable `APPIA`.

[NOTE]
====
The application

* first looks at the variable named `APPIA` (either global or local),
* then it tries the Java system property named `APPIA`,
* then the environment variable, and finally
* it tries to load the search path from the local directory `.env` file.

Handling the `.env` file is implemented in the code, there is no need to use external helper tools.
====

[NOTE]
====
JavaScipt and Python and some other scripting languages differentiate between static and dynamic importing.
Due to it's fully dynamic nature all imports are dynamic in Turicum.
====

`APPIA` is a string that lists the directories where the imported files may be.
The individual directories are separated using `|` characters.

NOTE: The character `|` was selected because it works on Windows as well as on Linux or other unix-based operating systems.
The drawback is that it may be interpreted by the shell, but the value of `APPIA` is rarely defined on the comand line.

When the import function sees a request to import the file `a.b.c.d` it will look at the subdirectory `a/b/c` for each `APPIA` directory.
The search is left to right as the directories are defined in the variable.
The first location when the  `d.turi` file is found "wins" and the file is loaded.

Technically, the function

* loads a Turicum source file,
* executes using a separate interpreter, and
* returns the global context of the interpreter as a class-less object.

If you have function or class definitions in the imported file, they will be fields in the new object.

You can assign the returned object to a variable or use it right away cherry-picking certain field from it.

If you want a specific class or function in your name space you can simply `let` assign it to a variable.

.file `import_this.turi`
[source]
----
fn imported_fun(){
    "fluffy dog"
}

----


.source of snippet `import`
[source]
----
global APPIA = ["./src/test/resources/"];

let fun = import("import_this").imported_fun

print fun()



----




.output of snippet `import`
[source]
----
fluffy dog
----



There are two pairs to the function `import`: `export()` and `export_all()`.
When these are used in an imported file, the variables from the imported file are copied automatically to the importing context.

Specifying extra arguments after the imported file name can define the symbols you want to import.
These arguments can be identifiers or expressions resulting in a string.
If there is such a list in the import function the `export()` or `export_all()` in the imported file is ignored.


.source of snippet `limited_import`
[source]
----
sys_import "turi.maven" , "lic*"

println license.apache2_0.name
println "The next printout is the error message, because github() is exported but we do not import it."
try : println github("verhas", "turicum"); catch e: println e


----




.output of snippet `limited_import`
[source]
----
The Apache License, Version 2.0
The next printout is the error message, because github() is exported but we do not import it.
Variable 'github' is undefined.

----



The list can contain strings and

=== `is_type`

This function accepts two arguments:

* and object, and
* a string naming a class or the class itself.

The return value is true if the object is an instance of the class or is an instance of a child class of the named class.


.source of snippet `is_type`
[source]
----
class A {}
class B : A {}
mut K = class : B {}
mut z = K()
println is_type(z,"A")," yes"
println is_type(z,"H")," no"
println is_type(z,"K")," no" // it is a no named class
println is_type(z,K)," yes"
println is_type(z,A)," yes"
println is_type(z,"#undefined")," yes" // bit strange, but actually


----




.output of snippet `is_type`
[source]
----
true yes
false no
false no
true yes
true yes
true yes

----



=== `java_...`

There are three functions in this group:

* `java_object`,

* `java_call`, and

* `java_call_vararg`.

==== `java_object`

This function can be used to create new instances of any Java class.
The first argument to the function is the binary name of the class.
The rest of the arguments should be the constructor arguments.

Since Turicum stores numbers as Double and Long, strings as Strings, boolean values as Boolean without any wrapping class, calling this function is straightforward when the constructor arguments are one of these primitive values.
If the parameter type is something else, then you have to use to create that object calling `java_object()`.

==== `java_call`

This function calls a Java method.

The first argument is either

* the object on which we want to call a method, or

* the name of the class to call a static method on.

The second argument is the name of the method. The rest of the arguments are passed to the Java method.
The return value is the value returned by the Java method.

==== `java_call_vararg`

This function should be used to call a vararg method.

An example of the use of `java_call` and `java_call_vararg` from the early stage of `io.turi`:

[source]
----
class files {
    fn read_all_lines(file_name_or_path){
    println(file_name_or_path)
    println(type(file_name_or_path))

        if type(file_name_or_path) == "str" :
            let file = java_call("java.nio.file.Path","of",file_name_or_path)
        else:
            let file = file_name_or_path
        java_call("java.nio.file.Files","readAllLines",file)
    }
}

class path {
 fn `of`(file_name,[rest]){
 java_call_vararg("java.nio.file.Path","of",file_name,rest)
 }
}
----

=== `keys`

The function `keys()` returns a string list containing the keys of the argument.

* If it is a class, then the keys are the class level fields, including those that have closure value, hence are class methods.

* If it is an object, then the list contains the fields.

* If it is a macro, a closure, or a function then it will return the parameter names.

=== `len`

This function returns the length of the argument.
The argument can be:

* string

* list

* Java array

* Java collection

=== `macro`

This function converts a closure or a function into a macro.


.source of snippet `macro_example`
[source]
----
mut c = macro(
    {|condition,then,`else`|
        if evaluate(condition) : evaluate(then) else: evaluate(`else`)
    })

print(

    c(true,"yes, it is true",{ println("this will never be printed") })

    );


----




.output of snippet `macro_example`
[source]
----
yes, it is true
----



=== `min`, `max`

These functions return the minium and the maximum value of their arguments.
If there is only one argument and that argument is a list, then the functions return the extreme element of the list.

The elements can be anything that is comparable, numbers, string.
If the arguments are objects they must have the `pass:[`<`]` method defined.


.source of snippet `min_max`
[source]
----
println max(3,5,8,7,4,11,-1)
println max([3,5,8,7,4,11,-1])
println min(3,5,8,7,4,11,-1)
println min([3,5,8,7,4,11,-1])

println max( "giraffe", "zibra", "elephant" )
println min( "affe", "zibra", "elephant" )

class Complex {
    fn init( real:float|num, imaginary:float|num ){
        pin real
        pin imaginary
    }
    fn `<`(other:Complex):bool = real*real + imaginary*imaginary < (with other: real*real + imaginary*imaginary);
    fn to_string()= $"${real}+i${imaginary}"
}

println min( Complex(1,1), Complex(3,2), Complex(0.5,1.7))
println max( Complex(1,1), Complex(3,2), Complex(0.5,1.7))

try: max( Complex(1,1), "Donald")
catch e: println e


----




.output of snippet `min_max`
[source]
----
11
11
-1
-1
zibra
affe
1+i1
3+i2
Cannot set variable 'other' to value 'Donald' because it does not fit the declared type Complex

----

}

=== `nano_time`

The `nano_time` function in Turicum returns the current value of the most precise available system timer, expressed in nanoseconds.
It is a direct wrapper around Java’s `+System.nanoTime()+` method and is typically used for measuring elapsed time with high resolution.
Unlike timestamps, the returned value has no absolute meaning but is strictly monotonic, making it ideal for performance profiling and timing operations.


.source of snippet `nano_time`
[source]
----
println nano_time()


----




.output of snippet `nano_time`
[source]
----
1055525193932416

----





=== `parents`

Returns a list of the classes that are the parent classes of the argument.


.source of snippet `parents`
[source]
----
class A {}
class B : A {}
mut K = class : B {}
println([ ..parents(K) -> type(it()) ])


----




.output of snippet `parents`
[source]
----
[B]

----



=== `reclose`

This function will "open" and reclose a closure in the current environment.


.source of snippet `reclose`
[source]
----
fn my_fun(@close_it) {
  mut s: str = "in function";
  return reclose(close_it)
}

mut s:str ="outer";
let closure = {|x| println s; s = x};
let reclosure = my_fun(close_it=closure);

closure("closure 1")
reclosure("reclosure 1")
println "s = %s" % s

closure("closure 2")
reclosure("reclosure 2")
println "s = %s" % s


----




.output of snippet `reclose`
[source]
----
outer
in function
s = closure 1
closure 1
reclosure 1
s = closure 2

----



The function opens and "recloses" the closure in the context of the function call.
It will see and alter the `s` in that context of the re-closing, while the original closure alters and sees the global `s`.

=== `rng`

Returns a number range.

[source]
----
rng(start, end, step)
----


It is a read-only list that contains all the numbers from the start (inclusive) to the end (exclusive) with the given step.
It does not create an actual list but just provides access to the numbers of the range by index.
You can also iterate through the elements.

The next example demonstrates that you can have extremely large ranges.


.source of snippet `rng`
[source]
----
mut z = rng(0,9223372036854775807)
mut i = 0
for each k in z {
  println k
  i++
}until i > 5


----




.output of snippet `rng`
[source]
----
0
1
2
3
4
5

----



If you want a physical list with the elements, you can create it using the `..` spread operator:


.source of snippet `rngThousand`
[source]
----
mut z = rng(0,1000)
mut array = [ ..z ]
print( [..array[0 .. 5], ..array[-5 .. array.length]])


----




.output of snippet `rngThousand`
[source]
----
[0, 1, 2, 3, 4, 995, 996, 997, 998, 999]
----



In this case `array` will be a list that contains the elements that we print out.
Do not try this with too large numbers unless you want to test out of memory errors.

You can index a number range, and you can also use a range to index another range:


.source of snippet `rngRange`
[source]
----
mut z = rng(100,9223372036854775807,100)
mut range = z[20..2000000]
print( [..range[0 .. 5], ..range[-5 .. range.length]])


----




.output of snippet `rngRange`
[source]
----
[2100, 2200, 2300, 2400, 2500, 199999600, 199999700, 199999800, 199999900, 200000000]
----



In this case you index the range and do not spread it into a list.
We only spread the new range for the printout.
The range called `range` does not allocate the almost two-million elements.
It is simply another number range.
At the end the code allocates a list of ten elements for the printout.

The third parameter `step` is optional.
If not specified it will be `+1` or `-1` depending on the start and the end value.

If specified, it must not be zero, and it has to be positive or negative based on the relations between the start and end value.
Essentially, stepping has to approach the end value.


.source of snippet `rngErrs`
[source]
----
try:
    rng(1,10,-1)
catch e1:
    println e1.message
try:
    rng(10,1,+1)
catch e2:
    println e2.message
try:
    rng(10,11,0)
catch e3:
    println e3.message

println "Special zero element range can have zero as step %s" % [rng(10,10,0)]
println "but it is just the same as %s" % [rng(10,10)]



----




.output of snippet `rngErrs`
[source]
----
rng(1,10,-1) would never end
rng(10,1,1) would never end
rng(10,11,0) has zero step size
Special zero element range can have zero as step []
but it is just the same as []

----



It is recommended not to use the `rng()` function directly.
You can import the system module `range` that defines a more flexible name:


.source of snippet `rangeThousand`
[source]
----
sys_import "turi.range"
mut z = range(start=0,end=1000,closend=true)
mut array = [ ..z ]
print( array[0 .. 5] + array[-5 .. array.length])


----




.output of snippet `rangeThousand`
[source]
----
[0, 1, 2, 3, 4, 996, 997, 998, 999, 1000]
----



=== `que`

This function will create a FIFO queue that different code fragments can write and read.
These fragments will probably run in different threads.

Here is a complex example using this function:


.source of snippet `que`
[source]
----
/**
 * A printing function that will print the objects received through the que `q` till it gets closed.
 */
fn printer(q,@name){
    mut n = 0 // counts the number of not ready que attempts
    while {
        mut s = q.try_receive(); // try to receive one or get none if there is nothing in the queue
        return { println "%s is done" % name } if q.is_closed(); // return when the que is closed
        if s == none {
            println "%s is not ready %s" % [name,n]
            n++ // count the attempts
            sleep 0.003 // sleep 3 mili
        } else {
            n = 0 // reset the attempts, we go an object to print
            println "%s is ready %s" % [name,s];
        }
    }
}

// create ONE queue that will be consumed by two
mut q : que = que(3)
// create two asynchronous task. they start immediately
mut task1 : task = async printer(q,name="task1")
mut task2 : task = async printer(q,name="task2")
// send the numbers 1 to 10 to the queue, whoever is lucky can get it
for i=1 ; i < 10 ; i++ {
    q.send(i);
    sleep 0.01
    }
println "closing the channel"
q.close();
println "channel is closed"
println "1 is done %s" % task1.is_done()
println "2 is done %s" % task2.is_done()

// get only the tasks into the list which are not done yet
mut task_list = [ task1, task2 ? !it.is_done() ]

println "we start to wait the first time"
await task_list

println "task1 done %s" % task1.is_done()
println "task2 done %s" % task2.is_done()
println "We start to wait the second time"
// have to use [] empty options, no timeout because a list literal stands after it
await[] [ task1, task2 ? !it.is_done() ]

println "task1 done %s" % task1.is_done()
println "task2 done %s" % task2.is_done()

none


----




.output of snippet `que`
[source]
----
task2 is ready 1
task1 is not ready 0
task2 is not ready 0
task1 is not ready 1
task2 is not ready 1
task1 is not ready 2
task2 is not ready 2
task1 is not ready 3
task2 is not ready 3
task1 is ready 2
task2 is not ready 4
task1 is not ready 0
task1 is not ready 1
task2 is not ready 5
task1 is ready 3
task1 is not ready 0
task2 is not ready 6
task1 is not ready 1
task2 is not ready 7
task1 is not ready 2
task2 is not ready 8
task1 is ready 4
task1 is not ready 0
task2 is not ready 9
task1 is not ready 1
task2 is not ready 10
task1 is not ready 2
task2 is not ready 11
task1 is not ready 3
task2 is not ready 12
task1 is ready 5
task1 is not ready 0
task2 is not ready 13
task1 is not ready 1
task2 is not ready 14
task1 is not ready 2
task2 is not ready 15
task2 is not ready 16
task1 is ready 6
task1 is not ready 0
task2 is not ready 17
task1 is not ready 1
task2 is not ready 18
task1 is not ready 2
task2 is ready 7
task1 is not ready 3
task2 is not ready 0
task1 is not ready 4
task2 is not ready 1
task1 is not ready 5task2 is not ready 2

task2 is ready 8
task1 is not ready 6
task2 is not ready 0
task2 is not ready 1
task1 is not ready 7
task2 is not ready 2
task1 is not ready 8
task2 is ready 9
task1 is not ready 9
task2 is not ready 0
task1 is not ready 10
task2 is not ready 1
task1 is not ready 11
task2 is not ready 2
task1 is not ready 12
task2 is not ready 3
closing the channel
channel is closed
1 is done false
2 is done false
we start to wait the first time
task2 is done
task1 is done
task1 done true
task2 done true
We start to wait the second time
task1 done true
task2 done true

----



=== Setting values in Contexts

Currently, there are three 'set' functions to update the value of a variable when the name of the variable is available in a string.

* `set`
* `set_global`
* `set_caller`

The use of these functions should be considered only for special meta-programming cases like writing decorators.

==== `set`

Set the value of a variable in the local context.
This function is useful for meta-programming when the name of the variable is available in a string.
An example is in the sample:


.source of snippet `fnDecorator3`
[source]
----
mut fun_decorator={|^closure|
        set(closure.name,
            {|| println("We start the fun"); closure(); println("The fun is over")}
           )
    }

@fun_decorator()
fn q(){
  println("We function");
}

q()


----




.output of snippet `fnDecorator3`
[source]
----
We start the fun
We function
The fun is over

----



uses this function to decorate a function and then set the variable of the same name, overwriting the definition with a new, decorated closure.

==== `set_global`

It is simlar to `set()` but it sets the value of a global variable.

==== `set_caller`

This function sets the variable in the caller context.
This comes handy when you implement a decorator that wants to redefine a function or class, and the decorator is in a different context than the decorated function.
You can set the name as a global name, but that will define the name globally, and if the function is in a local context, it may not exactly work as expected.

Calling this function from inside a function can redefine a variable in the context of the code that is calling the function or closure.


.source of snippet `fnDecorator5`
[source]
----
fn fun_decorator(^closure){
        set_caller(closure.name,
            {|| println("We start the fun"); closure(); println("The fun is over")}
           )
    }

{
    @fun_decorator()
    fn q(){
      println("We function");
    }

    q()
}


----




.output of snippet `fnDecorator5`
[source]
----
We start the fun
We function
The fun is over

----





=== `sys_import`

This command can be used to import Turicum system files.
These are classes and functions that give an interface to the surrounding environment through the Java VM.
Although Turicum can call any Java method using the functions `java_object`, `java_call` and `java_call_vararg` there are not meant to be used in application code.
They are primitives and are used as part of the system library part of the run-time.
When you use `sys_import` you import the file from the Java resource path, that delivers more Turicum idiomatic API.

=== `type`

This method returns the type of the argument as a string.


.source of snippet `type1`
[source]
----

mut s = "13"; mut i = 13; mut d = 3.14;

mut err
try: z = 6.55
catch ex: err=ex
class A {}

println "\"13\" ", type("13")
println "13 ", type(13)
println "3.14 ", type(3.14)
println "err ",type(err)
println "A() ",type(A())
println "[1,2,3] ",type([1,2,3])
println "A ",type(A)
println "fn()=3 ",type(fn()=3)
println "{|| 3} ",type({|| 3})
println "que(1) ",type(que(1))
println "async ",type(async 1)
println "macro ",type(macro(fn()=3))
println "none ",type(none)
println "java object ", type(java_object("java.lang.Object"))



----




.output of snippet `type1`
[source]
----
"13" str
13 num
3.14 float
err err
A() A
[1,2,3] lst
A cls
fn()=3 fn
{|| 3} fn
que(1) que
async task
macro macro
none none
java object java.java.lang.Object

----



When the argument is a Java object then the type is `java.` + the canonical name of the class.
=== `sleep`

Will sleep the execution of the thread for the given number of seconds.


.source of snippet `sleep`
[source]
----

sleep(0.001) // sleep one mili



----




.output of snippet `sleep`
[source]
----

----




=== `yield()`, `try_yield()`, `yield_is_close()`

In an asynchronous thread you can get objects sent by the parent thread calling `yield()`.
This call will wait for an object and return it.
If the que from the parent thread is already closed, then `yield()` will throw an exception.

`try_yield()` is more lenient.
It does not wait and returns `none` if there is no message or the channel is closed.

`yield_is_close()` can be used to test of the que is open from the parent to the child thread.


.source of snippet `try_yield`
[source]
----
fn printer(){
    mut n = 0
    while {
        mut s = try_yield();
        return { println "we are done" } if yield_is_closed();
        if s == none {
            println "not ready %s" % n
            n++
            sleep 0.003
        } else {
            n = 0
            println "received %s" % s;
        }
    }
}

mut task : task = async printer()
for i=1 ; i < 4 ; i++ {
 println "sending ",i
 task.send(i);
 sleep 0.009
 }
println "closing the channel"
task.close();
println "channel is closed"
println "is done %s" % task.is_done()
await task
println "is done %s" % task.is_done()

none


----




.output of snippet `try_yield`
[source]
----
sending 1
not ready 0
received 1
not ready 0
not ready 1
sending 2
received 2
not ready 0
not ready 1
not ready 2
sending 3
received 3
not ready 0
not ready 1
not ready 2
closing the channel
channel is closed
is done false
we are done
is done true

----



=== Regular Expressions

Regular expression handling is implemented with two primitive functions `pass:[_rx()]` and `pass:[_rx_match()]`.
They start with the `pass:[_]` character to signal that they are not to be used directly.
Instead, the code has to import the system file `re`:


.source of snippet `re`
[source]
----
sys_import "turi.re"

fn print_match(m){
    for i=0 ; i < len(m.group) ; i++ {
        mut {index, start, end } = m.group[i];
        println "%s. '%s'.substring(%s,%s)='%s'" % [index,s,start, end,s[start..end]];
    }
}

mut s = "abrakadabra";
mut rx =Re("a(b)ra(ka)(dabra)")
mut m = rx.match(s);
println m
print_match(m);

s = "xxx"+s+"yyy";
m = rx.match(s);
if m.group == none :
    println "does not match because of xxx and yyy"
println m, " is an empty object"
m = rx.find(s)
if m.group != none :
    println "matches because we find and not match"
print_match(m);


----




.output of snippet `re`
[source]
----
{start: 0, name: {}, end: 11, group: [{start: 1, index: 1, end: 2}, {start: 4, index: 2, end: 6}, {start: 6, index: 3, end: 11}]}
1. 'abrakadabra'.substring(1,2)='b'
2. 'abrakadabra'.substring(4,6)='ka'
3. 'abrakadabra'.substring(6,11)='dabra'
does not match because of xxx and yyy
{} is an empty object
matches because we find and not match
1. 'xxxabrakadabrayyy'.substring(4,5)='b'
2. 'xxxabrakadabrayyy'.substring(7,9)='ka'
3. 'xxxabrakadabrayyy'.substring(9,14)='dabra'

----



You can create a regular expression object using `Re()`.
It has two methods:

* `match()` to match the whole string passed as argument, and

* `find()` to find a matching string in the string.

If there is no match, the return value is an empty object.
If there is a match, then the return value is an object containing the matching groups.

Even if there are no matching groups the object is not empty as it will have an empty list field named `group`.

YOu can also use named arguments, that will get into the field `name`.
In the example above that field was empty.
In the following example we have named arguments:


.source of snippet `re2`
[source]
----
sys_import "turi.re"

mut m = Re("a(?<firstb>b)ra(?<twoletter>ka)(dabra)").match("abrakadabra");
println "the ks is '%s'" % [m.name.twoletter]


----




.output of snippet `re2`
[source]
----
the ks is '{start: 6, index: 3, end: 11}'

----



Each named argument contains the start, end, and the index of the named group.

=== `is_defined`

This macro accepts an identifier and returns `true` if the identifier is defined in the current context.


.source of snippet `is_defined`
[source]
----
if is_defined(z) : println "defined" else: println "not defined";
mut z = 1
if is_defined(z) : println "defined" else: println "not defined";
try:
    println {if is_defined(z+2) : "defined" else: "not defined"}
catch: println "no way"


----




.output of snippet `is_defined`
[source]
----
not defined
defined
no way

----



=== `unlet`

Unlet is a macro that accepts one identifier and deletes it from the local context.
It is an error if the variable is not defined in the local context or defined but not in the local context.

This macro was designed for a special purpose to, to create an initializer that can copy the values of an initializer class. Fo example:


.source of snippet `unlet`
[source]
----
class Z {
    fn init(obj){
        for each t in keys(obj){
            this[t] = obj[t]
        }
        unlet obj;
    }
}
mut z = Z({
    a: {
        B : "abraka"
        },
    c : ""
    });
println z


----




.output of snippet `unlet`
[source]
----
{a: {B: abraka}, c: , cls: class Z}

----



Without the call to `unlet` the class would also have the variable `obj` as a field.

=== `is_obj`

This is a function that returns `true` if the argument is an object.

=== Elephant functions: `thunk`, `unthunk`, `unwrap`, `block_list`

==== `thunk`

The `thunk` macro returns its argument unevaluated, preserving it as a command or expression.
This deferred computation can later be executed using `unthunk`.

`unthunk` evaluates the stored command in the **context where `unthunk` is called**, not the context where the thunk was created.

.difference from `evaluate`
[NOTE]
====
Although `evaluate` provides similar functionality, it differs in two key ways:

- `evaluate` can only be used **inside a macro**.

- It evaluates the argument in the **caller’s context**, i.e., the context of the macro's caller.
====

Note also that the argument to `thunk` can only be an expression and not an arbitrary command.
That is a restriction that comes from Turicum syntax.
However, you can enclose any command into a block, and then you can use the block as an expression or part of an expression.

==== `unthunk`

When you `unthunk` a block it will be evaluated in a local context freshly created for the block execution.
Although this context wraps the surrounding context, but defined local variables will not be visible after the execution of the block.
To overcome this limitation and execute the commands like they were literally written where the `unthunk` call is made you can `unwrap` a block.

.block wrapping explanation
[NOTE]
====
A block can be wrapping and non-wrapping.
Most of the blocks in Turicum are wrapping.
When you execute a wrapping block, the execution starts in a new context.
This context wraps the surrounding context, thus the code can access and modify the variables defined there, but any locally defined variable will only be available in the block and will disappear when the block is finished and the context is not used anymore.

A non-wrapping block executes in the surrounding context.
Any variable defined in the block will also be available outside.
An example of a non-wrapping block is an object initializer.
The body of the `init` method is executed in the surrounding context.
This is the object context in this case.
Any local variable defined in the `init` method becomes a field.

`unwrap` should get a block command as argument, probably as the result of a `thunk` call and it will result in a copy of the block, unwrapping.
====

The following example shows how these functions work.


.source of snippet `thunk_unthunk`
[source]
----
mut z = thunk({mut x = 3; println "hello"})
println "before eval"
unthunk(z)
println "after eval"
println is_defined(x) // will print false
unthunk(unwrap(z))
println is_defined(x) // will print true and
println x             // then the value


----




.output of snippet `thunk_unthunk`
[source]
----
before eval
hello
after eval
false
hello
true
3

----



==== `blocl_list`

The function `block_list` will return a list containing the commands in a command block.
The following example shows you how it can be used together with `thunk` and `unthunk`.


.source of snippet `block_list`
[source]
----
mut commands = block_list(thunk({k = 13; suss = "huss"; mut x = 3; println "hello"}))
println "before execution"
mut i = 1;
for each command in commands {
    mut suss;
    println "%s. before is_defined(x) = %s" % [i,is_defined(x)]
    if i == 1 {
        try: unthunk(command) catch e: println "ERROR: %s" % [e];
    } else {
        unthunk(command)
        println "%s. after is_defined(x) = %s" % [i,is_defined(x)]
    }
    i++
}


----




.output of snippet `block_list`
[source]
----
before execution
1. before is_defined(x) = false
ERROR: Variable 'k' is not defined.
2. before is_defined(x) = false
2. after is_defined(x) = false
3. before is_defined(x) = false
3. after is_defined(x) = true
4. before is_defined(x) = false
hello
4. after is_defined(x) = false

----



==== `as_object`

This function converts a command into an object.
This function supports reflective programming and is likely used together with the `thunk`, `unthunk` and inside macros.


.source of snippet `as_object`
[source]
----
let z = thunk({let k = 5})
println as_object(z)


----




.output of snippet `as_object`
[source]
----
{java$canonicalName: ch.turic.commands.BlockCommand, wrap: true, commands: [{assignments: [{identifier: k, types: [], expression: {java$canonicalName: ch.turic.commands.IntegerConstant, value: 5}, java$canonicalName: ch.turic.analyzer.AssignmentList.Assignment}], java$canonicalName: ch.turic.commands.LetAssignment, mut: false}]}

----



== Preprocessing

When the syntax analyzer meets a `#` symbol it stops parsing the tokens and starts preprocessing.
The steps of the preprocessing are the following:

. Parse the command following the `#` symbol.
This is the preprocessor command.
It has to be a macro, a function, or a closure.

. Remove all the tokens from the token list that were already processed.

. Create a preprocessor context.

. Execute the commands that were parsed.
This will create global variables, functions, and classes in the preprocessor context.

. Execute the command passing the list of tokens as the only argument.

. Remove all the tokens from the input and replace them with the token list returned by the preprocessor.

. If there are elements that are not tokens originating from the original list, parse them and convert each to a list of tokens.

When the remaining code is executed, the interpreter will use the preprocessor context.
If there is more than one preprocessor executed, they will share the same context.

The following example shows preprocessing that adds lines defining a global variable `M`,
defines a function, and
sets the value of the variable `M` to `"hello hello"`.


.source of snippet `preprocessorSample`
[source]
----
fn hi(){ // this will be deleted, it only exists in the preprocessor context
  "hello "
}
// the next line starts the preprocessor
# {|lexes|
["""
    // this is a string that will lead the new lexical token list
    mut M:str = ""
    fn helvetic_hi(){
      "Gruetzi "
    }
    fn hi() { "hullo" }
    M = M + "hello ";
    M = M + (hi() or "none ");
""",
// and just mut's have the rest of the tokens
..lexes]
} // end of the preprocessor command

// this is preprocessed
M = M + helvetic_hi() + "ant hunter"
print M


----




.output of snippet `preprocessorSample`
[source]
----
hello hulloGruetzi ant hunter
----



The example above is quite contrived.
Preprocessors are usually defined in imported files and invoked using a simple function call.

== Language Grammar (Appendix)

=== Full Annotated EBNF

The following is the non-standard EBNF definition of the programming language called Turicum.

* Strings between ' characters are literal keywords.
* Syntax between `[` and `]` are optional
* Syntax between `+{+` and `+}+` are repeated zero or more times
* Syntax between `(` and `)` is a group with alternatives
* Alternative syntaxes are separated using the `|` character.
* Non-terminal symbols are all capital letters.
* EBNF non-terminals are followed by `::=` and then the definition closed by `;`

* Non-literal terminal symbols are:

** IDENTIFIER
** number
** string

A program is a series of commands.
Commands can be separated by `;` character, and it is recommended to use it, but it is not required.
New line can replace the use of `;`.
The recognition of the command end upon new-line is heuristic.
The safe way is to use `;` to close commands.

 PROGRAM ::= { COMMAND [;] } ;

A program is an ordered list of commands optionally separated by `;`.

Commands have values. It is the __result__ of the command.

 COMMAND ::=  IF |
              LOOP |
              CLASS |
              FLOW |
              FN |
              LOCAL | GLOBAL | PIN
              BREAK | YIELD | RETURN |
              TRY |
              ASSIGNMENT |
              EXPRESSION |
              ;

 LOOP ::= (
           'while' [EXPRESSION] ['list']( BLOCK | ':' COMMAND )|
           'for' COMMAND ';' [EXPRESSION] ';' COMMAND ['list']( BLOCK | ':' COMMAND ) |
           'for' '(' COMMAND [EXPRESSION] COMMAND ')' ['list'](  BLOCK | ':' COMMAND )  |
           'for each' identifier [with identifier] 'in' EXPRESSION ['list']( BLOCK | ':' COMMAND ) |
           'for each' '(' identifier ['with' identifier] 'in' EXPRESSION ')' ['list'](  BLOCK | ':' COMMAND )
          ) [ 'until' EXPRESSION]
 ;

If the condition expression is missing after 'for' or 'while' it is `true`.
The expression following the 'until' keyword is not optional, but the whole `until` `EXPRESSION` part is.
The value of a loop is the last __executed__ command, or a list if the `list` keyword was specified.
The elements of the list are the last __executed__ commands for each iteration.

The value of an `IF` command is the value of the first or the second block, whichever is executed.
If the condition expression is false and there is no second block, then the value is `none`.

 IF ::= 'if' EXPRESSION ( ':' COMMAND | BLOCK ) [ 'else' ( ':' COMMAND | BLOCK )] ;

The result of a CLASS declaration is the declared class itself.

 CLASS ::= 'class' [IDENTIFIER] [ ':' IDENTIFIER_LIST ] BLOCK ;

The class object is also assigned to the variable denoted by the `IDENTIFIER` in the current context.

The result of a function declaration is the function itself.

 FN ::= FN_EXPR | FN_BLOCK ;
 FN_EXPR   ::= 'fn' [ IDENTIFIER ] '(' IDENTIFIER_LIST ')' '=' EXPRESSION ;
 FN_BLOCK  ::= 'fn' [ IDENTIFIER ] [ '(' IDENTIFIER_LIST ')' ] BLOCK ;

For functions with an expression body following a '=', the parameter list is mandatory.
The parameter list may be empty, having only '(' and ')'.

For functions with a block body, both the function name and parameter list are optional, but you must have at least one of them.

Variables declared as local will be local to the context, even if the same name is used in some enclosing context or as a global variable.
The value of the local declaration is the value of the last assignment in the command

 LOCAL ::= 'let' IDENTIFIER_ASSIGNMENT_LIST |
           'let' '{' TYPED_IDENTIFIER_LIST '}' '=' EXPRESSION|
           'let' '[' TYPED_IDENTIFIER_LIST ']' '=' EXPRESSION ;

When there are braces or brackets around the identifier list the `EXPRESSION` has to be an object (for braces) or a list (for brackets).
The fields or the elements of the object or list are assigned to the individual variables.

Variables declared global will refer to the global variable.
The value of the global declaration is the value of the last assignment in the command.

 GLOBAL ::= 'global' IDENTIFIER_ASSIGNMENT_LIST;

Variables pinned cannot be changed in the local context.
Pinning has no effect to outer scopes.
You can also pin an object. In that case use `+{variable}+` instead of the name.

 PIN ::= 'pin' IDENTIFIER_ASSIGNMENT_LIST;

 IDENTIFIER_ASSIGNMENT_LIST ::= [identifier [: TYPE_DEFINITION ] ['=' expression]]
                                    { ',' identifier [: TYPE_DEFINITION ] [ '=' expression] };

 TYPED_IDENTIFIER_LIST ::= identifier [: TYPE_DEFINITION ]
                                    { ',' identifier [: TYPE_DEFINITION ] };

 TYPE_DEFINITION ::= TYPE_NAME { '|' TYPE_NAME }

 TYPE_NAME ::= IDENTIFIER

It is valid to have no identifiers in an identifier list, a.k.a. having an empty identifier list

 IDENTIFIER_LIST ::= [ IDENTIFIER { ',' IDENTIFIER } ];

Using '=' updates a variable but never creates a new one. It first has to be created using `let`.

 ASSIGNMENT ::= LEFT_VALUE '=' EXPRESSION ;
 LEFT_VALUE ::= IDENTIFIER { '.' IDENTIFIER | '[' EXPRESSION ']'};
 EXPRESSION ::= BINARY_EXPRESSION[0];

Define precedence levels using indexed rules

 N=10;
 BINARY_EXPRESSION[i <N ] ::= BINARY_EXPRESSION[i+1] { BINARY_OPERATOR[i] BINARY_EXPRESSION[i+1] };
 BINARY_EXPRESSION[i == N] ::= UNARY_EXPRESSION  ;// Highest precedence level

Unary operators and primary expressions

 UNARY_EXPRESSION ::= PREFIX_UNARY_OPERATOR UNARY_EXPRESSION | PRIMARY_EXPRESSION;

 PRIMARY_EXPRESSION ::= number | string
 | FN
 | CLASS
 | IDENTIFIER
 | '(' COMMAND_LIST ')'
 | FUNCTION_CALL
 | FIELD_ACCESS
 | METHOD_CALL
 | BLOCK
 | ARRAY_ACCESS
 ;

Function call: name(params)

 FUNCTION_CALL: := IDENTIFIER '(' [ EXPRESSION { ',' EXPRESSION } ] ')' ;

Field access: obj.field

 FIELD_ACCESS: := PRIMARY_EXPRESSION '.' IDENTIFIER ;

Method call: obj.method(params)

 METHOD_CALL: := PRIMARY_EXPRESSION '.' IDENTIFIER '(' [ EXPRESSION { ',' EXPRESSION } ] ')' ;

Block returning an expression value. The value of the block is always the last executed expression.

 BLOCK: := '{' COMMAND_LIST '}' ;

 COMMAND_LIST: := { COMMAND [';' | '\n'] }

 BREAK: := 'break' CONDITIONAL_VALUE ;
 RETURN: := 'return' CONDITIONAL_VALUE ;
 YIELD: := 'yield' CONDITIONAL_VALUE ;
 CONDITIONAL_VALUE = EXPRESSION [ ('if' | 'when') EXPRESSION ];

Array element access: array[index]

 ARRAY_ACCESS: := PRIMARY_EXPRESSION '[' EXPRESSION ']' ;

Unary operators

 PREFIX_UNARY_OPERATOR ::= '+' | '-' | '!' ;

Binary operators grouped by precedence (higher index = higher precedence)

 BINARY_OPERATOR[0] ::= '||' ; Lowest precedence
 BINARY_OPERATOR[1] ::= '&&' ;
 BINARY_OPERATOR[2] ::= '|' ;
 BINARY_OPERATOR[3] ::= '^' ;
 BINARY_OPERATOR[4] ::= '&' ;
 BINARY_OPERATOR[5] ::= '==' | '!=' ;
 BINARY_OPERATOR[6] ::= '<' | '<=' | '>' | '>=' ;
 BINARY_OPERATOR[7] ::= '<<' | '>>' ;
 BINARY_OPERATOR[8] ::= '+' | '-' ;
 BINARY_OPERATOR[9] ::= '*' | '/' | '%' ; Highest precedence for binary ops
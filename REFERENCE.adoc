= Turicum Programming Language Reference








== Introduction

=== What is Turicum?

Turicum is a modern programming language designed for expressiveness, safety, and concurrency.
It combines functional and object-oriented paradigms in a clean and coherent syntax.
The preprocessing capability and the dynamic nature of the language make it outstanding from a programming perspective.

=== Turicum is

* **Fuctional**
+
Functions, closures, and macros are first-class citizens in Turicum, and any of them can be used as a value.
Every command has a value, and thus any command can be part of an expression, and an expression is also a command.

* **Object-Oriented**
+
Programs can define classes, methods in classes, multiple inheritance, and objects that inherit properties.

* **Dynamic**
+
Everything is defined during run-time and can be changed during run-time.
For example, a class of function is defined when the definition is executed and lives in the defining scope.
Methods are fields with closure or function values and can be added to any class or object even after the creation.

* **Flexible**
+
The interpreter can execute already loaded code at any time passing the remaining of the lexical tokens to a preprocessor.
The preprocessor can be a function or closure written in Turicum,
It can modify the lexical stream introducing arbitrary syntactical extensions to the language.

* **Multithread**
+
The interpreter uses Java 21 and supports (planned) VirtualThreads using native language constructs.

* **Typed and scoped**
+
Variables can be typed and assignment types are dynamically checked.

Turicum is both a scripting language and an embeddable engine.
It can be run as a standalone command-line tool or integrated into Java or Kotlin applications as a library.

Turicum is implemented in Java and designed to be approachable by JVM developers while introducing powerful abstractions.

The name “Turicum” is the ancient Roman name for the city of Zürich, Switzerland, where the language is being developed.

=== Design Goals and Philosophy

Turicum was designed with the following principles:

* **Concise syntax** that remains readable and expressive.
* **Functional-first** execution model with support for **side effects** when needed.
* **Multithreading and pipeline support** built into the language.
* **Safe scoping and closures**, including *reclosable* closures which adapt to new context bindings.
Closure eclosing is a unique language feature.
* **Macro metaprogramming**, allowing deferred and explicit evaluation of arguments.
* A flexible **parameter system**, supporting `normal`, positional-only, named-only, argument and special parameters for rest, meta, and trailing callable parameters.

The language is designed for **experienced developers**, particularly those who work with the JVM and need a powerful scripting or DSL tool that feels natural but scales to complex architectural needs.

=== Lexical and Syntax Conventions

Turicum syntax is clean, indentation-insensitive, and mostly expression-oriented.
It does not try to reinvent the syntax, so it will look familiar for Java, C and even in some cases for Python programmers.
On the other hand, it does not require syntactically superfluous characters, like `(` and `)` around the conditions of the `if` statement.

The basic syntactic conventions are:

* Semicolons (`;`) can be used to separate commands but are mostly optional.
* Blocks are defined with curly braces `{}` and return the result of the last evaluated command.
* Comments start with `//` and continue to the end of the line.
* Multiline comments start with `+/*+` and end with `*/` like in Java, and they can be nested unlike Java.
* Identifiers follow conventional rules and are case-sensitive.
* Any string between two `+`+` (back-tick) characters is an identifier (like in Kotlin).
* All keywords are lowercase.
* String between ``` are terminated on the same line and between ````` can be multi-line.

More details about expressions, control flow, and declarations can be found in the chapters that follow.

== Basic Concepts

A Turicum program is a list of commands, which is executed from the start to the end.


.first_sample
[source]
----
print "Hello,";
println " World"
for i=1 ; i < 3 ; i = i+1 : println(i)


----




will print out


.output first_sample
[source]
----
Hello, World
1
2

----


A command end is usually denoted by a new line or a `;`.
At the end of the command a `;` can always be repaced by a new line, but not when the syntax requires the`;` inside the command, like the `for` loop.

Commands can be grouped in to blocks enclosed between `{` and `}`.
Everything has a value, even commands.
For example, an `if` statement will result the value of the command after the `if` conditional if the conditional was true and the else block otherwise or `none` if there is no else block.


.if_value
[source]
----
let z : num = {if 232 % 2 == 0 : 1 else: 2 }
println(z)


----




will output


.output if_value
[source]
----
1

----


Command blocks can be part of expressions.
The value of a command block is the value of the last executed expression.


.block_value
[source]
----
let z = {
    let k = "Hi";
    k + "cory"
    }
println(z)


----




will output


.output block_value
[source]
----
Hicory

----


Expressions can contain

* literals,

** string
** numerical
** JSON

* variables,
* operators,
* function calls,
* closure calls,
* macro calls,
* method calls,
* async expressions,
* and code blocks.

Symbolic constants are `true`
// has the constant boolean __true__ value.
`false`
// has the constant boolean __false__ value
`none`
// is the undefined value.
// The Java representation of the undefined value is `null`.
`inf`
// is the infinite value.
pinned (non-changeable, final) global variables.

==== Whitespace and Line Breaks

Whitespace (spaces, tabs, line breaks) is generally insignificant except where indentation affects readability.
Multiple newlines are allowed between tokens and commands.
Line breaks alone do not terminate statements.

==== Identifiers

Identifiers are names used for variables, functions, classes, and other user-defined symbols.

* Identifiers must start with a Unicode letter or underscore (`_`), and may contain letters, digits, and underscores.
* You can explicitly define an identifier using backticks: `+`non-standard-id`+`.
Using backticks allows you to use any string as an identifier, even reserved words, or symbols.
You can use it to override operators, like `+`==`+`.
* Identifiers are case-sensitive.

Some Unicode characters like `∞` (infinity) and `∅` (none) are automatically translated into meaningful identifiers (`inf`, `none`).

==== Reserved Words

Turicum has a set of reserved keywords that cannot be used as identifiers, unless you enclose the name between `+`+` backticks, like `+`if`+`.

The keywords are:




`async`
`await`
`break`
`catch`
`class`
`each`
`else`
`elseif`
`finally`
`fn`
`for`
`global`
`if`
`in`
`let`
`or`
`pin`
`return`
`try`
`until`
`when`
`while`
`yield`

== Expressions and Operators

=== Literals

Turicum supports a rich set of literals, including numeric values, strings, JSON-like constants, and lists.
All literals are expressions that evaluate to immutable values.

==== Numeric Literals

Numeric literals can be either integers or floating-point numbers.

* Integers are written as sequences of digits, e.g., `42`, `0`, `123456`.
* Floating-point numbers contain a decimal point or exponent part, e.g., `3.14`, `2e10`, `1.0e-3`.

There is no special suffix for numeric types.
Type promotion is automatic and based on the context of usage.
Internal implementation of numerical types uses `Long` and `Double`.

==== String Literals

Strings in Turicum are enclosed in double quotes (```), e.g., ``hello world``.

Backslash escapes are supported:

* `\n` — newline
* `\t` — tab
* `\\` — backslash
* `\`` — double quote

Example:

[source]
----
`Hello`
----

==== Multiline Strings

Multiline string literals are enclosed between triple quotes `+```+`.

They preserve line breaks and indentation exactly as written. Escape sequences are still processed.

Example:

[source]
----
```
Hello,
  This is a multiline string.
Goodbye.
```
----

==== JSON Constants

Turicum supports JSON-like literals directly in the language syntax. These can be written using JavaScript-style object and array literals:

[source]
----
{
  `name`: `Alice`,
  age: 30,
  `tags`: [`developer`, `java`]
}
----

JSON keys can be identifiers or strings.
The values can be presented by any Turicum expression.
The value of a JSON expression is a class-less Turicum object.
The values are evaluated when the literal is evaluated.

==== Lazy JSON

To defer the evaluation of a JSON literal until it is accessed, Turicum provides _lazy JSON_ literals.

These are written with a `+&+` prefix before the JSON object:

[source]
----
&{
  `timestamp`: now(),
  user: getCurrentUser()
}
----

Lazy JSON is not evaluated at definition time.
Each field is computed lazily, on demand, using the current execution context wrapping the context where the JSON was defined.
This behavior is similar to that of closures.

In the example above `getCurrentUser()` is only invoked if and when the field `user` is accessed.
Lazy JSON objects are pinned, a.k.a. it is not possible to change any of their fields.

==== List Literals

Lists can be defined using square brackets `+[]+`.

List elements are expressions and are separated by commas:

[source]
----
[1, 2, 3, 4]
[`apple`, `banana`, `cherry`]
[1 + 2, `computed`]
----

Lists are mutable by default and can be indexed using the `+[]+` operator.
They support iteration in `+for each+` loops.

Empty lists can be written simply as `+[]+`.

Lists can contain mixed types, but homogeneous lists are encouraged for clarity.

List literals also support flattening other lists using the `..` prefix.
For example:

[source]
----
let a = [1, 2, 3, 4]
let b = [`apple`, ..a, `banana`, `cherry`]
----

will make `b` contain ``apple``, `1`,`2`,`3`,`4`,``banana``, ``cherry``.

List literals also support filters and mappers.
For example:

[source]
----
let a = [1, 2, 3, 4 ? {|a| a%2 == 0 } -> {|a| a / 2} ]
----

will select first `2` and `4` and then map them to `1` and `2`

==== Operators and Symbols

The lexer recognizes both symbolic and word-based operators.
Operators are tokenized with priority for the **longest matching operator**.

Recognized symbols are:


"--", "++", "->", "=", "(", ")", ",", ".",
"&{", "{", "}", "[", "]", ";", ":", "|", "?", "@", "^", "#"




=== Operators

Operators have precendence and are evaluated from left to right.
You can use `(` and `)` to change the evaluation order.
The operators are the followings in order of growing precedence:

* `or` results the left side expression if it is defined and the right side if the left side value is `none` (undefined).
The operator does short-cut evaluation.
The right side is only evaluated if the left side is undefined.

*  `||` logical OR operation, shortcut evaluated.

* `&&` logical AND operation, shortcut evaluated.

* `..` range operator. `start..end`` will result a range to index a list.
The first index is `start`, the last is `end-1`.
Ranges can be used to index lists as values and also in left values to replace a part of a list.
When used as a unary prefix operator, it must be inside a list literal and in front of a list to flatten the list content into the literal.

* `|` bitwise OR operation.

* `^` bitwise XOR operation. (planned)

* `&` bitwise AND operation.

* `==`, `!=`, `in` equal, not equal and part-of operators.
The `in` operator works on a list to check if an element is in that list,
or on strings to check the existence of a substring.

* `<`, `+<=+`, `>`, `>=` usual size comparision operators.

* `<<`, `>>`, `>>>` left shift, right shift, and signed right shift operators.

* `+`, `-` binary and unary plus and minus.

* `*`, `/`, `%` binary multiply, divide, and remainder operators.

.functions argument default values
[NOTE]
====
The bitwise OR `|` is not allowed in the expression specifying a default value for a function or closure argument.
You can however freely enclose the expression or a part of it between `(` and `)` and use the operator freely.
====

.pre and post increment/decrement
[NOTE]
====
The lexical elements `pass:[++]` and `--` are defined and recognized by the lexical analyzer.
This is to avoid accidentally writing `pass:[++i]` or `--i`, which would otherwise be valid expressions doing nothing.
Their meaning would otherwise be `+(+i)` and `-(-i)`.
====

They work for numerical types, string types as usually, and they can also work on any object that defines them.
The name of the method implementing the operator should be the operator itself.
There is not any name association, like in Python dunder plus.
Instead, you can use, for example, `pass:[`+`]` as an operator identifier.

The operator methods must have one single positional arguments, usually named `other`.
The functionality should implement the operation and return the result `this` operation `other`.
When an operation is used as prefix unary operator the value of other will be `none` and `this` will hold the value on the right of the operator.

Only `+`, `-`, `!`, `..` can be used as unary operators.

== Variables and Scope

Variables can be global or local.
They are defined in scopes.
Scopes are wrapped around each other.
The top level scope is the global scope.

Scopes are created in run-time, like everything in Turicum.

=== Block scopes

Code blocks open a new scope and they wrap the surrounding scope.


.scope1
[source]
----
let z = "cory"
z = { // z is global
    println "just a print"
    let k = "Hi" // k is local
         + z // z is accessible
    // the value of the block is the last command executed
    // 'let' assignments result the value assigned
    }
println(z)
println(k)


----




will output


.output scope1
[source]
----
just a print
Hicory
none

----


The variable `k` is local inside the code block, and it has no value outside.
The variable `z` is part of the wrapped context, and in this case it is global.
The block executes in its own scope, and this scope wraps the global scope.

You can nest scopes.

When you use a variable defined in a wrapped (outer) scope you cannot define it anymore as local using `let`.
For example, the following program:


.local_redefined_error
[source]
----
let z = 5
try{
    z = {
        println(z);
        let z = 3
        }
}catch e {
    println(e)
}


----




will output:


.output local_redefined_error
[source]
----
5
Variable cannot be local, it is already used as non-local 'z'

----


=== Class, object and function scope

Class declarations and functions do not wrap the surrounding scope.
In the following example, modifying the global variable `glb` is not possible without declaration.
The class and the function do not wrap the surrounding, global scope.


.function_scope
[source]
----
let glb = "global variable";
class A {
  fn z(){
    println("You can read glb, which is a " + glb)
    try{
       // you cannot change it without declaring that it is global
       glb = 5;
    }catch(e){
        println("exception 1:",e)
    }
    try{
       // you touched it as global, you cannot declare it as local anymore
       let glb = 5;
    }catch(e){
        println("exception 2:",e)
    }
    global glb;
    glb = "modified"
    return "You can access glb here it is " + glb ;
  }
}
let obj = A()
println(obj.z())


----




The output of the program is:


.output function_scope
[source]
----
You can read glb, which is a global variable
exception 1:Variable 'glb' is not defined.
You can access glb here it is modified

----


The methods, a.k.a. functions defined inside a class wrap the context of the class.
Whenever a method is called its own scope is created and the "local variables" `cls` and `this` are created.
Unless the method is a constructor (named aptly as `constructor`) these variables are pinned, cannot be changed.

Code inside a class, outside any method is executed when the class is defined.


.class_definition
[source]
----
class X {
  let s = "hu"
}
println("class var ", X.s)
let x = X();
println("object var ", x.s)


----




The code above defines a class named `X`.
This class has a class scope variable `s`.
It can be accessed as a field of the class itself `X.s`.

Variable `x` is initialized to hold an instance of this class.
Using `x.s` will reference the same variable, because objects wrap the scope of the class.


.output class_definition
[source]
----
class var hu
object var hu

----


The following example details these different access scenarios:


.object_scope
[source]
----
class X {
  let s = "class field"
  cls.h = "another class field"
  fn constructor {
    let g = "object field"
  }
  fn t(){
    // access object field explicitly through 'this'
    println("this.g=",this.g)
    // the object wraps the class scope and not the other way around
    // there is no 'g' defined in the class
    println("cls.g=",cls.g)
    // 'g' is in the wrapped scope of the object scope
    // this is same as 'this.g'
    println("g=",g)
    // 'this.h' is the same as 'cls.h' because of wrapping
    println("this.h=",this.h)
    println("cls.h=",cls.h)
    println("h=",h)
    // the same is true for the other field
    // does not matter how it was defined
    println("this.s=",this.s)
    println("cls.s=",cls.s)
    println("s=",s)
  }
}
let x = X();
x.t()


----





.output object_scope
[source]
----
this.g=none
cls.g=none
g=none
this.h=another class field
cls.h=another class field
h=another class field
this.s=class field
cls.s=class field
s=class field

----


=== Closure scopes

Closures are blocks with arguments.
The general syntax is:

[source]
----
  {|arguments declaration| commands}
----

Note that executing a closure and calling a closure are two different things.
When a closure is executed, it returns the closure.
When a closure is called, the arguments are evaluated in the actual scope, and the closure is called in its scope.
The scope of the closure does not wrap the scope of the caller.
It does wrap the scope of the execution, where we created the closure.

Technically functions are closures that do not wrap any other scope.

The following example inside a block.
the closure can access and even modify the variable `whom`.


.closure_example
[source]
----
let c = {
    let whom = "World!";
    {|greeting|
        println(greeting,whom);
        whom = "Universe!"
    }
}
c("Hello, ")
c("Hi, ")


----




.output closure_example
[source]
----
Hello, World!
Hi, Universe!

----



The variable `whom` lives only inside the block.

=== Macro scopes

macro scopes are the same as closure scopes.
Macros are closures that get their arguments unevaluated.
You can create a macro using the built-in global function `macro` with a closure or function as an argument.
Code inside macros can call the global function `evaluate` on the arguments.

This way macros can decide which arguments to evaluate and what order, or how many times.
The following simple macro reimplements the `if` command's functionality using it:


.macro_example
[source]
----
let c = macro(
    {|condition,then,`else`|
        if evaluate(condition) : evaluate(then) else: evaluate(`else`)
    })

print(

    c(true,"yes, it is true",{ println("this will never be printed") })

    );


----




.output macro_example
[source]
----
yes, it is true
----



When a macro calls the function `evaluate` the evaluation happens in the caller scope.
This ensures the same scope and variable visibility like calling a function or closure.
The caller does not need to know that the implementation of the something it calls is a function, closure, or macro.

=== Variable Declaration

You can read an undefined variable.
The value will be `none`.

You cannot, however, assign value to an undefined variable.
Upon first assignment the code has to use the keyword `let` to define the variable.

NOTE: There is a subtle difference between an undefined variable and a defined variable having the value `none`.
An undefined variable was never defined.
As it was said it's value is `none`.
An already defined variable can also have the value of `none`, but it also has an optional type declaration.

The syntax of a `let` command is the following:

[source]
----
let identifier : type = expression
----

or

[source]
----
let {identifier:type , ... } = expression
----

or

[source]
----
let [identifier:type ...] = expression
----

In the first version you assign a value to an identifier and optionally define the type.
If the type is defined, only values that match the type can be assigned to the variable.
Type is one of the predefined types or the name of the class or a java object type.
You can specify multiple types separated using `|` character.

Note that if you do not define an expression but you define a type that is not `any` or `none` then you should also specify `|none` as an alternative, because the initial value will be `none`.

The `: type` and the `= expression` parts are optional.
If the type is not defined, then the variable can get any value.
If the expression is missing the value will be `none`.
There can be multiple `identifier : type = expression` after the `let` keyword comma separated.
There are predefined type names.

* `bool`
 boolean type
* `str`
 string
* `num`
 any numeric type, integer or float
* `float`
 float type
* `any`
 the variable can hold any value
* `obj`
 the variable can hols any object without restriction on the class of that object
* `lst`
 the variable has to be a list
* `que`
 the variable has to be a queue
* `task`
 the variable has to be an asynchronous task
* `err`
 the variable has to be an asynchronous task
* `cls`
 the variable has to be a class
* `fn`
 the variable value has to be a function of closure
* `macro`
 the variable value has to be a macro
* `none`
 the variable can hold the value `none`



If the name starts with `java.` then the variable can hold a Java object.
For example `java.java.math.BigInteger` can hold any `java.math.BigInteger` object.

In other cases the type can be the name of a class defined in the program.
The class has to be defined by the time the variable is defined.

If the name of the type is specified between `(` and `)` then the expression between the parentheses is evaluated and the string value is used as a type name.

[NOTE]
====
Note that a variable can hold `none` only if

* there is no type defined,

* `none` is among the allowed types, or

* `any` is among the allowed types.

For example `let a:num;` will fail, because it allows only numerical values, but missing the initial value will try to set it to `none`.
====

You can define multiple types for a variable separating the types with `|`. For example `let a:num|str|myClass` makes `a` eligible to store a numeric value, a string or an instance of `MyClass`.

The following example declares a variable that can hold a string or a numeric value.


.let_with_types_example
[source]
----
let c : str |num = 3;
c = "" + c + " == " + c
println(c)


----




.output let_with_types_example
[source]
----
3 == 3

----



If you use the format `let { identifier list } = expression` then the identifiers are not followed by expressions individually.
Instead, the expression after the `=` is evaluated once, used as an object and the fields are assigned to the variables of the same name on the left side.


.flat_let_object1
[source]
----

let z = { a: "apple", b:"bier", c : "count" }
let {a, b, c} = z
println a
println b
println c


----




.output flat_let_object1
[source]
----
apple
bier
count

----



It is not an error if there are fields in the object not read during the assignment and also if some of the variables do not have matching fields.


.flat_let_object2
[source]
----

let z = { a: "apple", b:"bier", c : "count" , d: "not used" }
let {a, b, c, f} = z
println a
println b
println c
println f


----




.output flat_let_object2
[source]
----
apple
bier
count
none

----



If you use the format `let [ identifier list ] = expression` then the identifiers are not followed by expressions individually.
Instead, the expression after the `=` is evaluated once, used as a list and the elements are assigned to the variables.


.flat_let_list1
[source]
----
let [a, b, c] = [1,2,3]
println a
println b
println c


----




.output flat_let_list1
[source]
----
1
2
3

----



It is  an error if there are not enough or too many elements in the list on the right-hand side.


.flat_let_list2
[source]
----
try:
    let [a, b, c, f] = [1,2,3]
catch err: println err


----




.output flat_let_list2
[source]
----
[multi-let] assignment right hand side has too few values

----




.flat_let_list3
[source]
----
try:
    let [a, b] = [1,2,3]
catch err: println err


----




.output flat_let_list3
[source]
----
[multi-let] assignment right hand side has too many values

----



If you have too many elements you can cut the list:


.flat_let_list4
[source]
----
let [a, b] = [1,2,3,4,5,6,7,8][0..2]
println a
println b


----




.output flat_let_list4
[source]
----
1
2

----



If you have too few you can extend the list:


.flat_let_list5
[source]
----
fn adjust(x, @to){
    if len(x) < to :
        while len(x) < to :
            x = [..x, none]
    else :
        x = x[0..len(x)]
    x
}
let [a, b, c, d] = adjust(to=4,[1,2])
println a
println b
println c
println d


----




.output flat_let_list5
[source]
----
1
2
none
none

----



or even


.flat_let_list6
[source]
----
fn adjust(@to,[x]){
    if len(x) < to :
        while len(x) < to :
            x = [..x, none]
    else :
        x = x[0..len(x)]
    x
}
let [a, b, c, d] = adjust(to=4, 1,2)
println a
println b
println c
println d


----




.output flat_let_list6
[source]
----
1
2
none
none

----






==== Pinned Variables

Pinning a variable makes it illegal to change it in the scope.
The syntax of the `pin` command is

[source]
----
  pin list
----

The list is comma separated elements, can be

* a variable name, like `turic`,

* a variable name enclosed between `{` and `}`, like `{object}`, or

* a variable name enclosed between `[` and `]`, like `[list]`.

A variable in the list will make the variable in the current context pinned.
If the variable name is decorated with `{}` then the object, which is the value of the variable gets pinned.
Note that this is changing the object itself and not the variable.

If the variable name is decorated with `[]` then the list, which is the value of the variable gets pinned.
Note that this is changing the list itself and not the variable.

It is an error using the decoration on a variable that is not an object or list.

The following example demonstrates the different pinning possibilities:


.pinning
[source]
----
let turicum = 13
let list = [1,2,3]
let object = { x:1, y:2};
pin turicum, [list], {object}

try {
  turicum = 14;
}catch e: println("could not change the variable")

try {
  list[1] = 0;
}catch e: println("could not change the list")
list = [ 0, ..list, 4]
println("variable 'list' still can be changed: ", list)

try {
  object.x = 3;
}catch e: println("could not change the object")
object = { x:1, y:3 }
println("variable 'object' still can be changed: ", object)



----




.output pinning
[source]
----
could not change the variable
could not change the list
variable 'list' still can be changed: [0, 1, 2, 3, 4]
could not change the object
variable 'object' still can be changed: {x: 1, y: 3}

----



== Control Flow

=== Conditional Execution (`if` / `else`)

Command `if` is very conventional and similar to any other programming language.

[source]
----
'if' EXPRESSION ( ':' COMMAND | BLOCK ) [ 'else' ( ':' COMMAND | BLOCK )] ;
----

If the expression is `true` it executes the first command or block.
If the expression is `false` it executes the second command or block.
The second command or block along with the keyword `else` is optional.

The block is a series of commands enclosed between `{` and `}`.
If there is only a single command after the condition or the keyword `else` it has to be preceded with a `:`.

The conditional expression may, but does not need to be enclosed between parentheses.

The result of the command is the value of the command or block executed.
If the condition is `false` and there is no "else" block or command, then the result is `none`.


.ifCommand
[source]
----
let a= 13
if a%2 == 0: println("even") else: println("odd")
a = {if a%2 == 0: "even" else: "odd"}
print("again ",a)


----




.output ifCommand
[source]
----
odd
again odd
----




=== Loops

There are three types of loops in Turicum:

* `while`

* `for`

* `for each` loop.

Loops, like any command, have a result value.
The value of a loop

==== `while`

A while loop is front and tail conditioned.
The front condition, following the keyword `while` is checked before each execution of the loop body.
The body of the loop will only be executed if the front fondition is `true`.

The tail condition is optional, and follows the body of the loop with the `until` keyword.
It is checked after the execution of the loop body.
Execution of the loop stops when the tail condition is  `true`.


.whileLoop
[source]
----
let i = 1;
while i < 5 {
  print(i," ");
  i = i + 1;
}until i % 3 == 0;


----




.output whileLoop
[source]
----
1 2 
----



The body of the loop can be a command block, or it can be a single command.
If the body is a single command, not enclosed between `{` and `}` it has to be preceded by a `:`.


.whileLoop2
[source]
----
let i = 1;
while i < 5 :
  i = i + 1;
until i % 3 == 0;
println(i)


----




.output whileLoop2
[source]
----
3

----



==== `for`

For loop is very much similar to the conventional `for` loop we have since it was invented in the language C.
The difference is that the start, condition, and end steps do not need to be enclosed between `(` and `)`.
The start, condition, and end parts are separated by `;` and they are commands.
The `;` in this place is not optional.


.for1
[source]
----
for i = 1 ; i < 5 ; i=i+1 {
  print(i," ")
}until i%3 == 0 ;


----




.output for1
[source]
----
1 2 3 
----



The `for` loop also has an optional `until` part the same way as `while`.
The next example shows the same loop with the optional parentheses but without the tail condition.


.for2
[source]
----
for( i = 1 ; i < 5 ; i=i+1 ){
  print(i," ")
}


----




.output for2
[source]
----
1 2 3 4 
----



If the start command is an assignment, it is interpreted as a local assignment.



.for3
[source]
----
// same as 'for( let i = 1 ;' ...
for( i = 1 ; i < 5 ; i=i+1 ){
  print(i," ")
}until i%3 == 0 ;
println("i at end=",i);


----




.output for3
[source]
----
1 2 3 i at end=none

----



The variable `i` after the loop is still undefined.
To use a variable from the enclosing wrapped scope, you can enclose the assignment into a block.


.for4
[source]
----
let i;
for {i = 1} ; i < 5 ; i=i+1 :  print(i," "); until i%3 == 0;
println("i at end=",i);


----




.output for4
[source]
----
1 2 3 i at end=3

----



In this last example we also use a single command as the body of the loop.
In this case the command is preceded by a `:` character.

==== `foreach`

Foreach iterate through a list


.foreach1
[source]
----
for each i in [1,2,3,4]: print(i," ");


----




.output foreach1
[source]
----
1 2 3 4 
----



The `for each` loop can also have a tail condition.


.foreach2
[source]
----
for each i ∈ [1,2,3,4]: print(i," "); until i%3 == 0


----




.output foreach2
[source]
----
1 2 3 
----



==== `break`

The command can break the execution of the loop and can also specify the value of the loop.

=== Returning, Breaking and Yielding

These three commands are in one family.
each of them can pass a value, and each can have a conditionality following the expression.
The syntax is

[source]
----
break expression if condition
return expression if condition
yield expression if condition
----

The `if condition` part is optional.
When it is missing the command is executed like if it was `if true`.

==== `break`

The command `break` stops the execution of a loop.
If it is executed, the value of the loop will be the expression that follows the command.

==== `return`

The command `return` stops the execution of a function, method, closure, or macro.
If it is executed, the value of the function, method, closure, or macro will be the expression that follows the command.

==== `yield`

The command yield produces a value, and the execution of the code continues.
It can only be used when the code was started so that another thread is expecting the yielded value.
The typical example is when you execute a command `async` .


.yield1
[source]
----
fn gen_1_to_10 {
    for i=1 ; i <= 10 ; i = i + 1:
        yield i;
}

println([ .. (async gen_1_to_10()) ])


----




.output yield1
[source]
----
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

----



The return value can be used in a `for each` loop, or you can iterate through it the same way you would with any iterator.


.yield2
[source]
----
fn gen_1_to_10 {
    for i=1 ; i <= 10 ; i = i + 1:
        yield i;
}

let st = async gen_1_to_10();
while st.has_next() :
    println(st.next());


----




.output yield2
[source]
----
1
2
3
4
5
6
7
8
9
10

----



== Functions

Functions play a similar role as in other languages.
They can be top-level functions and methods attached to classes or to objects.

=== Function Declarations

A function declaration is a statement that defines the function.
The function will be usable after the function definition was executed.
The syntax of the function definition is

[source]
----
fn function_name (parameters) {
   body
}
----


`fn` is a keyword, and it is never optional.


.fun1
[source]
----
fn inc(x) {
  x+1
}
println(inc)
println(inc(1))


----




.output fun1
[source]
----
ch.turic.commands.Closure@95e33cc
2

----



`function_name` is the name of the function.
It may be missing, typically when the result, the function itself is assigned to a variable or passed directly as an argument.


.fun3
[source]
----
fn inc x {
  x+1
}
println(inc)
println(inc(1))


----




.output fun3
[source]
----
ch.turic.commands.Closure@38604b81
2

----




`(parameters)` are the parameters, including default values and parameter types and parameter-passing requirements.
The `(` and `)` is optional when the function has a name.
When it has no name, then `(` and `)` must present even if there are zero arguments.


.fun2
[source]
----
let inc = fn (x) {
  x+1
}
println(inc)
println(inc(1))


----




.output fun2
[source]
----
ch.turic.commands.Closure@1e44b638
2

----



The body of the function can be a block of statements or a single expression.
The expression is specified following a `=` character and the parentheses are a must in this case also.
This is to avoid the unreadable `fn = 2*3` to be declared as a function declaration but `pass:[`fn`]=2*3` an assignment.
`fn = 2*3` is a syntax error.

The parameter list is comma-separated.
Each element defines a formal parameter.

==== Parameter Passing

When a function is invoked, the actual parameters can be passed to the function in two different ways:

* by position, and
* by name.

Some parameters can be passed in both ways, some of them only positionally, some only by name.
This is declared in the formal parameter list.
Each parameter declaration starts with the identifier of the argument.
This is the identifier how the function body can use the variable as well as the identifier the called can use if the parameter is passed by name.

Parameters preceded with '!' can only be passed positionally.

Parameters preceded with `@` can only be passed by name.


.fun4
[source]
----
fn inc !x, @how_much {
  x+how_much
}
println(inc)
println(inc(1,how_much=5))


----




.output fun4
[source]
----
ch.turic.commands.Closure@7393222f
6

----



Here `x` is a positional parameter.
Passing a value as `x=1` would be an error.
Parameter `how_much` must be passed by name.

Parameters can also have type declarations and default values.
If there is a type declaration passing a value that does not fit the type declaration is an error.
Not passing a value for a parameter that does not have a default value is also an error.


.fun5
[source]
----
fn inc !x, @how_much=1 {
  x+how_much
}
println(inc(1,how_much=5))
println(inc(1))


----




.output fun5
[source]
----
6
2

----



Parameter types and the default value assignments have the same syntax as in the case of variable assignment.
There is one notable difference: default value expressions can use the binary or `|` operator only if it is between parentheses.

==== Positional and Named parameters order

You are allowed to use positional and named parameters intermixed.
There can be a named parameter and then a position following it.
It may be beneficial in some special situations, but the general recommendation is not to overuse this feature.
List the positional parameters first, named following, and optional parameters (see soon) the last.

The actual algorithm of parameter passing is the following:

* The actual arguments are evaluated from left to right.
* Named passings are assigned to the argument with the matching name.
* Positional arguments are assigned to the first non-named only argument.
That is the first not-yet-assigned positional or positional/named argument.


.fun6
[source]
----
fn wrong !x, h, !k {
  // just don't do
}
try: wrong(1,3, h= 2)
catch e: println("There is an error",e)


----




.output fun6
[source]
----
There is an errorParameter 'h' is already defined

----



[#_extra_parameters]
==== Extra parameters

In some cases you want to allow the callers to pass extra arguments and your function body to use them.
To do that, there are three extra arguments you can use in your function definition:

* `[rest]`,

* `{meta}`, and

* `^closure`.

You can name them any way you want, but for the same of simplicity we will use the names above.
The syntax distinguishing them from the other parameters is the use of the extra `[]`, `{}`, and `^` characters.
If they are present, they have to be the last formal parameters in the order as listed above.
Any of them may be missing, but if two present then `[rest]` should be before `{meta}` and `^closure`, and `{meta}` has to precede `^closure`.

When the function code starts

* `rest` will be a list containing the value of the positional arguments that were not yet assigned to any parameter.
* `meta` will be an object with the named parameters not assigned as field names and the values holding the values.
* `closure` will hold the last parameter of the function call that usually is a closure.

The following example shows how you can use the rest-parameter:


.restParameters
[source]
----
let f = fn (a,b,[rest]) {
  println("a=",a)
  println("b=",b)
  for each r in rest: print("%s " % r)
}

f(1,2,3,4,5,6)


----




.output restParameters
[source]
----
a=1
b=2
3 4 5 6 
----



The following example demonstrates the use of the meta-parameter:


.metaParameters
[source]
----
let f = fn (a,b,{meta}) {
  println("a=",a)
  println("b=",b)
  for each r in keys(meta): print("%s=%s\n" % [r , meta[r]])
}

f(1,b=2,k=3,x=4,juice=5,six=6)


----




.output metaParameters
[source]
----
a=1
b=2
six=6
x=4
k=3
juice=5

----



[NOTE]
====
When you

* have a `!name` declared positional only parameter, and
* you also have `{meta}` in the parameter list, and
* and you call the function providing a `name=expression` named argument,

it will not be assigned to the positional only parameter, and it is also not an error.
It will be a field in the meta-parameter object created.

The reason for this is that the naming of the positional only parameters is not part of the function signature.
They are the internal business of the function itself, and as such must not have any effect how you call the function.

On the other hand, no named parameter name, or named/positional parameter name will get into the meta-parameter.

Also, you cannot use a parameter name in an argument list more than once.
====


You can also combine the two:


.metaRestParameters
[source]
----
let f = fn (a,b,[rest],{meta}) {
  println("a=",a);
  println("b=",b);
  for each r in keys(meta): print("%s=%s\n" % [r , meta[r]]);
  println("rest:");
  for each r in rest: print("%s " % r);
}

f(1,b=2,k=3,x=4,juice=5,7,six=6);


----




.output metaRestParameters
[source]
----
a=1
b=2
six=6
x=4
k=3
juice=5
rest:
7 
----



The last argument, preceeded by the `^` character is special.
When you call a function and the last argument is a closure then you can place that closure outside of the `(` and `)` of the arguments, but ONLY if the closure is defined right there.

For example:


.closureArgument
[source]
----
let f = fn (a,b,^closure) {
  println("a=",a);
  println("b=",b);
  println(closure(a,b))
}

f(2,3){|x,y| x+y}
f(2,3){|x,y| x*y}


----




.output closureArgument
[source]
----
a=2
b=3
5
a=2
b=3
6

----



The function gets the closure adding the two numbers and then prints the numbers and the result.

The example:

.wrong example
[source]
----
let f = fn (a,b,^closure) {
  println("a=",a);
  println("b=",b);
  println(closure(a,b))
}
let closure = {|x,y| x+y}

f(2,3)closure
----

does not even compile, since the mandatory `;` or new line is missing after the function call.
Also, it would be unreadable to recognize `closure` as an argument.

NOTE: The actual implemented syntax checks that the next two tokens following the `)` are `{`and `|`.

This call can aid in creating domain-specific languages.

==== Spreading lists and objects as arguments

When calling a function, you can precede a parameter with the `..` operator.
This will spread the content of the parameter to parameters.

If the value of the parameter is an object, the fields of the object will be used as named parameters.
The field names will be used as argument names and the values as values.


.spread
[source]
----
fn a(@a,@b,@c,@d){
    println("%s %s %s %s " % [a,b,c,d])
}
fn b(!a,!b,!c,!d){
    println("%s %s %s %s " % [a,b,c,d])
}
fn c(a,b,c,d){
    println("%s %s %s %s " % [a,b,c,d])
}

a(..{a:1,b:2,c:3,d:4});
b(..[1,2,3,4]);
c(..[1,2],..{d:4},3);


----




.output spread
[source]
----
1 2 3 4 
1 2 3 4 
1 2 3 4 

----



If the value is a list, then the values will be used as positional parameters.

This is useful when you want to pass on parameters you got in the `rest` or `meta` parameters to some other function.

[NOTE]
====
Technically you can spread any value resulting from an expression that implements internally the `HasFields, or `Iterable<?>` interface.

Currently, the following classes implement the `HasField` interface:

* `Lex` one token in the lexical analysis.
It is used in preprocessors written in Turicum.

* `LexList` the list of the tokes.
Just like the class `Lex` it is used in preprocessors.

* `Closure` is the implementation class for functions and closure.
There is one, read-only field, `name`.

* `Macro` is the implementation class for macros.
There is one, read-only field, `name`.

* `JavaObject` is the class that implements the handling of any Java object, when all else fails.
It implements reflection to access the declared fields of the class on the enveloped object.

* `LazyObject` is the lazy object that has fields which are evaluated every time they are accessed.

* `LngClass` Turicum class object.
It handles the class level fields.

* `LngException` is any exception caught by a `catch` in the program.
It has a constant set of read-only fields.

* `LngList` Turicum lists.
It has one read-only field `length`.
This class also implements Iterable and is handled as such when used in an argument list spread.

* `LngObject` is a Turicum object.

* `MapObject` any Java `Map<?,?>` object.
The implementation will handle the keys as strings.

The following class implement the `Iterable` interface in Turicum, which do not implement the `HasField` and thus can be spread as positional parameters:

* `IndexedString` envelops a string during commands that modify a String.
This is the technical implementation internally replacing an unmutable Java String with a mutable wrapper around.

* `JavaArray` makes it possible to index any Java array.

* `LngList` is the list object in Turicum.
Although this class also implements the `HasFields` interface this is handled as an exception and passed as positional arguments when spread.

* `AsyncStreamHandler` is the class handling asynchronous operations and yields.
It makes it possible to use the result of a `async expression` as arguments.
+

.spreadStream
[source]
----
fn c(a,b,c,d){
    println("%s %s %s %s " % [a,b,c,d])
}
fn numbers {
  for i = 1 ; i <= 4 ; i = i + 1 : yield i
}

c(..(async numbers()))


----




.output spreadStream
[source]
----
1 2 3 4 

----


====

== Classes and Objects

Classes can be defined using the `class` keyword.
A class is defined when the class definition is executed.


.class1
[source]
----
class A {
    fn init {
        let a = "a";
    }
    let c = "c"
}
let a1 = A()
let a2 = A()
a1.a = "1"
a2.a = "2"
A.c = "d"
println a1.a, a2.a, a1.c, a2.c



----




.output class1
[source]
----
12dd

----



Classes can contain methods and can define class variables.
In the example above the class contains the method `init`, which is a special one and declared one variable, `c`.

The method `init` is the initialized method.
It is invoked when the class is instantiated.
To create an object, you should use the name of the class like a method with parameters.
The parameters will be passed to the `init` method.

When executing a method, there are two special variables:

* `this` is the current object.

* `cls` is the class of the current object.

If you use a variable without the `this.` prefix it will automatically be handled, but you can just use the `this.` prefix any time.
That way the following example is the same as the previous:


.class2
[source]
----
class A {
    fn init {
        this.a = "a";
    }
    cls.c = "c"
}
let a1 = A()
let a2 = A()
a1.a = "1"
a2.a = "2"
A.c = "d"
println a1.a, a2.a, a1.c, a2.c



----




.output class2
[source]
----
12dd

----



When using variables in a class first the object variables are consulted.
If there is no object variable, then the class variables are used.
Classes and the methods inside the classes do not wrap any surrounding context.

The methods defined in a class belong to the class.
You can define methods attached to the objects.


.class3
[source]
----
class A {
    fn init {
        this.a = "a";
    }
    fn p {
        println "I am class level"
    }
}
let a1 = A()
a1.p()
a1.p = fn (){
  println "I am a1"
}
let a2 = A()
a2.p = fn (){
  println "I am a2"
}

a1.p()
a2.p()



----




.output class3
[source]
----
I am class level
I am a1
I am a2

----



The variable `cls` and `this` are pinned, cannot be modified in the methods.


.class4
[source]
----
class A {
    fn p {
        this = none
    }
}
try :
    A().p()
catch ex :
    println ex


----




.output class4
[source]
----
Variable 'this' is pinned.

----



and


.class5
[source]
----
class A {
    fn p {
        cls = none
    }
}
try :
    A().p()
catch ex :
    println ex


----




.output class5
[source]
----
Variable 'cls' is pinned.

----



The only exception is the `init` method.


.class6
[source]
----
class A {
    fn init {
      this = B()
    }
}

class B {

}

println A().cls



----




.output class6
[source]
----
class B

----



The example above alters the `this` variable, and it alters what the construction of the class returns.
That way an initializer can function as a factory method.

You cannot change the value of the `cls` even in the initializer:


.class7
[source]
----
class A {
    fn init {
      cls = B
    }
}

class B {

}
try:
    A()
catch ex:
    println ex



----




.output class7
[source]
----
Variable 'cls' is pinned.

----



Classes can be nested and defined inside other classes.
When calling the constructor of the class to create a new instance then the variable `this` would be ambigous.

For `a.Z()` it usually points to `a`, but if `Z` is a class, and we called the constructor, than `this` should be the new instance.
In this situation a special variable called `that` will point to `a`.


.class8
[source]
----
class A {
    class B {
        fn init {
            println "this ", this
            println "cls ", cls
            println "that ", that
        }
    }
}

let a = A()
let b = a.B()


----




.output class8
[source]
----
this {that: {, cls: class A}, cls: class B}
cls class B
that {, cls: class A}

----





=== Class Declaration

=== Fields and Methods

=== Blocks as Expressions

== Data Structures

=== Future Structures

== Error Handling

Error handling is similar to Java.
If an error happens, an exception is thrown.
An exception can be caught using `catch` pairing with a `try`.

An exception is an object.
You can declare a variable to hold an error


.try3
[source]
----
let error:err|none
try{
        z = 55 // undefined variable
}catch(err): error = err

println error



----




.output try3
[source]
----
Variable 'z' is not defined.

----



The predefined type for an exception is `err`.

An exception has

* `stack_trace`

* `message`

* `cause`, and

* `supressed` fields.

`stack_trace` is a list (`lst`), each element is an object with the fields:

* `file`
* `line`
* `column`
* `source`


.try4
[source]
----
let error:err|none
try{
        z = 55 // undefined variable
}catch(err): error = err

println """message "%s" """ % [error.message]
println """cause "%s" """ % [error.cause]
println """suppressed %s" """ % [error.suppressed]
for each st in error.stack_trace {
    println("%s:%s:%s" % [st.file, st.line, st.column])
    println "source: ", st.source
    }




----




.output try4
[source]
----
message "Variable 'z' is not defined." 
cause "none" 
suppressed []" 
try4.turi:3:9
source:         z = 55 // undefined variable
try4.turi:2:3
source: try{
try4.turi:4:18
source: }catch(err): error = err
try4.turi:1:4
source: let error:err|none

----



=== Try-Catch

Try is very similar to Java `try`-`catch`-`finally`.
The command `try` tries to execute a block and if an exception happens it executes the block following the keyword `catch`.
At the end it executes the block following the `finally` keyword.


The `catch` and finally` blocks are optional.


.try1
[source]
----

try {
    z = 55 // undefined variable
}catch err {
  println err
} finally {
  println "this will always run"
}



----




.output try1
[source]
----
Variable 'z' is not defined.
this will always run

----



Another example without the optional part, but enclosed in an outer try-catch block:


.try2
[source]
----
try{
    try {
        z = 55 // undefined variable
    }
}catch(err): println err



----




.output try2
[source]
----
Variable 'z' is not defined.

----



== Decorators, Metaprogramming

Decorators are an inherent part of Turicum.
To make them similar to Python decorators and Java annotation, they can have a `@` in front of the decorator function call.
However, in the case of closures, you do not even need that.
Every function call that has a closure as the last parameter can act as a decorator.


.closureDecorator1
[source]
----
fn closure_decorator(^closure){
  {|| println("We start"); closure(); println("We finish")}
}

let z = closure_decorator(){|| println("We are closure") }

z()


----




.output closureDecorator1
[source]
----
We start
We are closure
We finish

----



If you add a `@` then the result is the same:


.closureDecorator2
[source]
----
fn closure_decorator(^closure){
  {|| println("We start@"); closure(); println("We finish@")}
}

let z = @closure_decorator(){|| println("We are closure") }

z()


----




.output closureDecorator2
[source]
----
We start@
We are closure
We finish@

----



The `@` helps you emphasize that the call is a decorator call that modifies the closure following it.
The use of `@` also notifies the syntax analyzer that the call is a decorator call, and it extends the recognition of the following `^closure` parameter.
When the `@` precedes the function call, a `fn` or `class` are also recognized as `^closure` parameter.


.fnDecorator1
[source]
----
  fn fun_decorator(^closure){
    {|| println("We start the fun"); closure(); println("The fun is over")}
  }

let z =
@fun_decorator()
fn q(){
  println("We function");
}
  z()


----




.output fnDecorator1
[source]
----
We start the fun
We function
The fun is over

----



Without the `@` the program is still valid.
However, as soon as we try to invoke `z()` the program fails.
It tries to invoke the closure returned by `fun_decorator()`, which tries to call `closure()` which now has the value `none`.
This happens because the syntax analysis does not use the function definition as a parameter.

The code can, however, be fixed:


.fnDecorator2
[source]
----
  fn fun_decorator(^closure){
    {|| println("We start the fun"); closure(); println("The fun is over")}
  }

let z =
fun_decorator(
fn q(){
  println("We function");
})
  z()


----




.output fnDecorator2
[source]
----
We start the fun
We function
The fun is over

----



The application of the `@` is therefore only a syntactic sugar.
The following example shows that a decorator can not only return the decorated function, class, or closure.
They can also modify the existing definition.


.fnDecorator3
[source]
----
let fun_decorator={|^closure|
        set(closure.name,
            {|| println("We start the fun"); closure(); println("The fun is over")}
           )
    }

@fun_decorator()
fn q(){
  println("We function");
}

q()


----




.output fnDecorator3
[source]
----
We start the fun
We function
The fun is over

----



Technically the decorator does not modify the function `q`.
It creates a new function and redefines the variable named `q` in the wrapped context.

Note, that if `fun_decorator` was a function declared with `fn` it would not work.
A function does not wrap the surrounding context and thus cannot redefine anything in it.
To redefine an already existing variable, it needs to be a closure.

You usually just assign a value to the variable updating its value.
In this case we have to use the built-in `set` function, because we have the name of the variable as a string.

In the following example we moved the function definition to a local scope.
The decorator in this case simply defines the global variable of the same name as we used locally for the function.
The value is the closure or function, whatever we decorate itself.


.fnDecorator4
[source]
----
{
    fn globalize(^closure){
            set_global(closure.name,closure)
        }

    @globalize()
    fn q(){
      println("We function");
    }
}
q()


----




.output fnDecorator4
[source]
----
We function

----



Since we use `set_global` the decorator can be a function, it does not need access to the enclosing context.

=== Macro and Reclose

The built-in functions `macro` and `reclose` are special closure conversion functions.

The function `macro()` accepts a closure as an argument and returns the closure converted to a macro.
The major difference between ordinary macros and closures is that the argumente of a closure are evaluated before starting.
A macro gets its arguments unevaluated.

=== Special variables

There are a few predefined variables, constants, and some special variables.

* `true`
 has the constant boolean __true__ value.
* `false`
 has the constant boolean __false__ value
* `none`
 is the undefined value.
 The Java representation of the undefined value is `null`.
* `inf`
 is the infinite value.


The special variables are not constants.
They are defined dynamically to represent the current computing environment.
These are the following:

* `this`

* `cls`

* `that` will point to the object on which a method was called when the method is a class constructor.
Class constructors are invoked using the name of the class.
When a class name is used as a field in an object either directly injected to the object or as a class field as in the next example, then the constructor can access the target object of the call through `that`.
+

.that
[source]
----
class OuterClass {
    let name = "outer class";
    fn init(){
      let name = "outer object"
    }
    class InnerClass {
        let name = "inner class";
        fn init() {
            let name = "inner object"
            println("this name %s " % this.name)
            println("this name %s " % cls.name)
            println("this name %s " % that.name)
            println("this name %s " % that.cls.name)
            }
        }
    }
let outer = OuterClass()
let inner = outer.InnerClass()


----




.output that
[source]
----
this name inner object 
this name inner class 
this name outer object 
this name outer class 

----


+
Usually the target object is called `this`, but in the case of the constructor `this` points to the current object to be initialized.
What is more, the constructor, always named `init()`, is allowed to modify the variable `this`.
In this environment `this` cannot be used for both the object to be initialized and the target object.
Hence, the special variable `that` was introduced.
+
You will hardly ever need it.

* `me` always points to the currently executing function or closure.
You can use it to furnish recursive calls.
It is necessary when a function is defined in a local context it does not capture.
For more read the next section Function scopes and `me`.

=== Function scopes and `me`

Functions are usually defined in the global context or as methods inside classes.
In both cases there is a wrapped context that contains the name of the function defined.
It is either the global context or the class context.

The following example is very straightforward.
It defines the function `fib()`, that calls itself recursively.


.fibonacci1
[source]
----
fn fib(x) {
    if x == 1 || x == 0 : 1
    else: fib(x - 1) + fib(x - 2)
}
println(fib(10))


----




.output fibonacci1
[source]
----
89

----



If we create the same program using a class memoizing the results:


.fibonacci2
[source]
----
class FibCalculator {
    let cache = [];
    fn fib(x) {
        if x == 1 || x == 0 : 1
        else{
            return cache[x] when cache[x] != none;
            cache[x] = fib(x - 1) + fib(x - 2);
        }
    }
}
println(FibCalculator.fib(10))


----




.output fibonacci2
[source]
----
89

----



we get the same result and there is no problem with that.
In this case `fib()` is a class level method and when we call it Turicum automatically calls it as a method.

The difficulty comes when you define the function in a local context.


.fibonacci3
[source]
----
try
{
    fn fib(x) {
        if x == 1 || x == 0 : 1
        else: fib(x - 1) + fib(x - 2)
    }
    println(fib(10))
}catch ex : println(ex)


----




.output fibonacci3
[source]
----
It is not possible to invoke 'fib' because its value is 'null' and not something I can invoke.It is a f5g null

----



The function does not see itself.
The function `fib` in this case is defined in the local context of the block, and functions do not wrap the surrounding context.
One solution can be to convert the function to a closure:


.fibonacci4
[source]
----
{
    let fib={|x|
        if x == 1 || x == 0 : 1
        else: fib(x - 1) + fib(x - 2)
    }
    println(fib(10))
}


----




.output fibonacci4
[source]
----
89

----



Closures wrap the surrounding context, therefore the body of the closure knows the value of `fib`, which is the closure itself.
If you do not want to wrap the whole context, you can do a little trick using functions.


.fibonacci5
[source]
----
{
    fn fib(x,fib=fib) {
        if x == 1 || x == 0 : 1
        else: fib(x - 1) + fib(x - 2)
    }
    println(fib(10))
}


----




.output fibonacci5
[source]
----
89

----



The function `fib` has an extra optional parameter.
The left side of the `fib=fib` is the name of the parameter, which will become a variable in the context if the function.
The right side is the default value, which is evaluated in the caller context before the call.

One may like this approach, for explicitly declaring that `fib` needs access to `fib` hence a recursive call.
Others may find it cryptic,
and it is not really clear
without knowing the details how contexts and default values for variable declarations work in Turicum.

An alternative possibility is to use the special variable `me`.


.fibonacci6
[source]
----
{
    fn fib(x) {
        if x == 1 || x == 0 : 1
        else: me(x - 1) + me(x - 2)
    }
    println(fib(10))
}


----




.output fibonacci6
[source]
----
89

----



This variable is reserved for this purpose, and it gets the function itself as its value before a function is called.
It may also be appealing that the recursive call is explicit whatever the name of the function is, not needing renaming when the function is renamed.

As an extra, here is a version of the fibonacci calculation using a closure with a retained local context as a state instead of a class:


.fibonacci7
[source]
----
let fib = {
    let cache = [];
    {|x|
        if x == 1 || x == 0 : 1
        else{
            return cache[x] if cache[x] != none;
            cache[x] = me(x - 1) + me(x - 2);
        }
    }
}
println(fib(10))


----




.output fibonacci7
[source]
----
89

----



Finally, here is a modified fibonacci calculation that can replace the start value and uses an object cache instead of class level cache.


.fibonacci8
[source]
----
class FibCalculator {
    fn init(start=1) {
        let cache = [];
    }
    fn fib(x) {
        if x == 1 || x == 0 : start
        else{
            return cache[x] if cache[x] != none;
            cache[x] = fib(x - 1) + fib(x - 2);
        }
    }
}
println(FibCalculator().fib(10))
println(FibCalculator(2).fib(10))


----




We do not include here the printout.
The first number you already know, try to guess the second, then run the code yourself.

== Built-in Functions

Built-in functions are functions provided by the interpreter, which extend the functionality of the run-time.

=== `evaluate`

Macro implementations use this function.
Macros get their arguments unevaluated and can use this function to evaluate them.
If you try to evaluate anything else than a macro argument, you will get an error.


.evaluate1
[source]
----
let twice = macro(fn (arg){ evaluate(arg); evaluate(arg);});
twice( {println("Hello")} )


----




.output evaluate1
[source]
----
Hello
Hello

----



The following example uses all the possible tools that can appear in a macro and a function.
The actual functionality is basic: it just invokes the closure or function provided as the first argument with the rest of the arguments passed on.
In real life you could just call the function itself without making it through a macro, but in this case we focus on doing that and how.

The unnamed function, which is the argument of the macro, has a mandatory, position-only argument and all the three extra arguments.
The first argument will be the function or closure we will call.
The function first called `evaluate` to get the function or closure.
Since this function is never called as a function, only after it is converted to be a macro, the argument is never a function, but a function definition.
Evaluating it will result in the function.

When we call this function adding `(..rest,..meta,..closure)` after it we spread the extra parameters.
In this example the three argument values for these parameters are

* `{}` empty object,
* `[]` empty list, and
* `none`

None of them adds extra parameters when spread.


.evaluate2
[source]
----
macro(fn (!arg,[rest],{meta},^closure)
            { evaluate(arg)(..rest,..meta,..closure)}
     )(fn () {println("Hello")})


----




.output evaluate2
[source]
----
Hello

----



To be honest, since the evaluation of the argument happens only once and without condition, this functionality does not really need a macro.
It could be shortened as


.evaluate3
[source]
----
(fn (!arg,[rest],{meta},^closure)
            { arg(..rest,..meta,..closure)})
     (fn () {println("Hello")})


----




.output evaluate3
[source]
----
Hello

----



Note, however that the code starts with a `(`.
That will make the function definition be part of an expression and process the following `(fn () {println("Hello")})` as an argument.
Without that we would have two unnamed function definitions, one after the other.

[NOTE]
====
The first design required enclosing a function definition like the one above to be enclosed between `{` and `}` to be part of an expression.
In most of the cases, like assigning a function to a variable would require superfluous `{` and `}` braces.
The philosophy of Turicum is to be dense and use extra characters where it helps readability or avoids syntax ambiguity.

Omitting the requirement around a `fn` (or for that matter a `class`) definition inside an expression make the language leaner, but this does not make a function or class definition to be an expression itself.
====

=== `import`

Import allows you to get definitions in other files into your code.

Technically, the function loads a Turicum source file, executes it, and returns the global context as an object.
If you have function or class definitions in the imported file, they will be fields in the new object.
Instead of introducing a new command, Turicum uses this function.

Other languages separate the module names, class names and alias definitions.
In turicum when you import `mod.dul.name.file` it will find the file in one of the `mod/ul/name` subdirectories^*^ in the file `file.turi` via the appia.

You can assign the returned object to a variable.
If you want a specific class or function in your name space you can simply `let` assign it to a variable

[source]
----
let MyImport = import("mod.ul.name.file")
let my_function = MyImport.imported_function;
my_function("hello")

----

The import searches for the file in the directories listed in the environment variable `APPIA`.
This variable is a list of directories separated by `|` characters.
They are searched from the first to the last until the file is found.

=== `sys_import`

This command can be used to import Turicum system files.
These are classes and functions that give an interface to the surrounding environment through the Java VM.
Although Turicum can call any Java method using the functions `java_object`, `java_call` and `java_call_vararg` there are not meant to be used in application code.
They are primitives and are used as part of the system library part of the run-time.
When you use `sys_import` you import the file from the Java resource path, that delivers more Turicum idiomatic API.

=== `java_...`

There are three functions in this group:

* `java_object`,

* `java_call`, and

* `java_call_vararg`.

==== `java_object`

This function can be used to create new instances of any Java class.
The first argument to the function is the binary name of the class.
The rest of the arguments should be the constructor arguments.

Since Turicum stores numbers as Double and Long, strings as Strings, boolean values as Boolean without any wrapping class, calling this function is straightforward when the constructor arguments are one of these primitive values.
If the parameter type is something else, then you have to use to create that object calling `java_object()`.

==== `java_call`

This function calls a Java method.

The first argument is either

* the object on which we want to call a method, or

* the name of the class to call a static method on.

The second argument is the name of the method. The rest of the arguments are passed to the Java method.
The return value is the value returned by the Java method.

==== `java_call_vararg`

This function should be used to call a vararg method.

An example of the use of `java_call` and `java_call_vararg` from the early stage of `io.turi`:

[source]
----
class files {
    fn read_all_lines(file_name_or_path){
    println(file_name_or_path)
    println(type(file_name_or_path))

        if type(file_name_or_path) == "str" :
            let file = java_call("java.nio.file.Path","of",file_name_or_path)
        else:
            let file = file_name_or_path
        java_call("java.nio.file.Files","readAllLines",file)
    }
}

class path {
    fn `of`(file_name,[rest]){
        java_call_vararg("java.nio.file.Path","of",file_name,rest)
    }
}
----

=== `keys`

The function `keys()` returns a string list containing the keys of the argument.

* If it is a class, then the keys are the class level fields, including those that have closure value, hence are class methods.

* If it is an object, then the list contains the fields.

* If it is a macro, a closure, or a function then it will return the parameter names.

=== `len`

This function returns the length of the argument.
The argument can be:

* string

* list

* Java array

* Java collection

=== `set`

Set the value of a variable in the local context.
This function is useful for meta-programming when the name of the variable is available in a string.
An example is in the sample:


.fnDecorator3
[source]
----
let fun_decorator={|^closure|
        set(closure.name,
            {|| println("We start the fun"); closure(); println("The fun is over")}
           )
    }

@fun_decorator()
fn q(){
  println("We function");
}

q()


----




.output fnDecorator3
[source]
----
We start the fun
We function
The fun is over

----



uses this function to decorate a function and then set the variable of the same name, overwriting the definition with a new, decorated closure.

=== `set_global`

It is simlar to `set()` but it sets the variable as global.

=== `type`

This method returns the type of the argument as a string.


.type1
[source]
----

let s = "13"; let i = 13; let d = 3.14;

let err
try: z = 6.55
catch ex: err=ex
class A {}

println "\"13\" ", type("13")
println "13 ", type(13)
println "3.14 ", type(3.14)
println "err ",type(err)
println "A() ",type(A())
println "[1,2,3] ",type([1,2,3])
println "A ",type(A)
println "fn()=3 ",type(fn()=3)
println "{|| 3} ",type({|| 3})
println "que(1) ",type(que(1))
println "async ",type(async 1)
println "macro ",type(macro(fn()=3))
println "none ",type(none)
println "java object ", type(java_object("java.lang.Object"))



----




.output type1
[source]
----
"13" str
13 num
3.14 float
err err
A() A
[1,2,3] lst
A cls
fn()=3 fn
{|| 3} fn
que(1) que
async task
macro macro
none none
java object java.java.lang.Object

----



When the argument is a Java object then the type is `java.` + the canonical name of the class.

=== `sleep`

Will sleep the execution of the thread for the given number of seconds.


.sleep
[source]
----

sleep(0.001) // sleep one mili



----




.output sleep
[source]
----

----



=== `macro`

This function converts a closure or a function into a macro.


.macro_example
[source]
----
let c = macro(
    {|condition,then,`else`|
        if evaluate(condition) : evaluate(then) else: evaluate(`else`)
    })

print(

    c(true,"yes, it is true",{ println("this will never be printed") })

    );


----




.output macro_example
[source]
----
yes, it is true
----



=== `reclose`

This function will "open" and relose a closure in the current environment.


.reclose
[source]
----
fn my_fun(@close_it) {
  let s: str = "in function";
  return reclose(close_it)
}

let s:str ="outer";
let closure = {|x| println s; s = x};
let reclosure = my_fun(close_it=closure);

closure("closure 1")
reclosure("reclosure 1")
println "s = %s" % s

closure("closure 2")
reclosure("reclosure 2")
println "s = %s" % s


----




.output reclose
[source]
----
outer
in function
s = closure 1
closure 1
reclosure 1
s = closure 2

----



The function opens and "recloses" the closure in the context of the function call.
It will see and alter the `s` in that context of the re-closing, while the original closure alters and sees the global `s`.


=== `print`, `println`

Prints the arguments to the standard output.
`println` also prints a new-line at the end.

=== `que`

This function will create a FIFO queue, that different code fragments can write and read.
These fragments will probably run in different threads.

Here is a complex example using this function:


.que
[source]
----
/**
 * A printing function that will print the objects received through the que `q` till it gets closed.
 */
fn printer(q,@name){
    let n = 0 // counts the number of not ready que attempts
    while {
        let s = q.try_receive(); // try to receive one or get none if there is nothing in the queue
        return { println "%s is done" % name } if q.is_closed(); // return when the que is closed
        if s == none {
            println "%s is not ready %s" % [name,n]
            n = n + 1 // count the attempts
            sleep 0.003 // sleep 3 mili
        } else {
            n = 0 // reset the attempts, we go an object to print
            println "%s is ready %s" % [name,s];
        }
    }
}

// create ONE queue that will be consumed by two
let q : que = que(3)
// create two asynchronous task. they start immediately
let task1 : task = async printer(q,name="task1")
let task2 : task = async printer(q,name="task2")
// send the numbers 1 to 10 to the queue, whoever is lucky can get it
for i=1 ; i < 10 ; i = i +1 {
    q.send(i);
    sleep 0.01
    }
println "closing the channel"
q.close();
println "channel is closed"
println "1 is done %s" % task1.is_done()
println "2 is done %s" % task2.is_done()

// get only the tasks into the list which are not done yet
let task_list = [task1, task2 ? {|x| !x.is_done()} ]

println "we start to wait the first time"
await task_list

println "task1 done %s" % task1.is_done()
println "task2 done %s" % task2.is_done()
println "We start to wait the second time"
// have to use [] empty options, no timeout because a list literal stands after it
await[] [task1, task2 ? {|x| !x.is_done()} ]

println "task1 done %s" % task1.is_done()
println "task2 done %s" % task2.is_done()

none


----




.output que
[source]
----
task2 is not ready 0
task1 is not ready 0
task1 is not ready 1
task2 is ready 1
task2 is not ready 0
task1 is not ready 2
task2 is not ready 1
task1 is not ready 3
task2 is not ready 2
task2 is ready 2
task1 is not ready 4
task2 is not ready 0
task1 is not ready 5
task2 is not ready 1
task1 is not ready 6task2 is not ready 2

task2 is ready 3
task1 is not ready 7
task2 is not ready 0
task2 is not ready 1
task1 is not ready 8
task2 is not ready 2task1 is not ready 9

task1 is ready 4
task2 is not ready 3
task1 is not ready 0
task2 is not ready 4
task1 is not ready 1
task2 is not ready 5
task1 is not ready 2
task1 is ready 5
task2 is not ready 6
task1 is not ready 0
task2 is not ready 7
task1 is not ready 1
task2 is not ready 8
task1 is not ready 2
task2 is ready 6
task2 is not ready 0
task1 is not ready 3
task2 is not ready 1
task1 is not ready 4
task2 is not ready 2
task1 is not ready 5
task2 is not ready 3
task1 is not ready 6
task2 is ready 7
task2 is not ready 0
task1 is not ready 7
task1 is not ready 8
task2 is not ready 1
task2 is ready 8
task1 is not ready 9
task2 is not ready 0
task2 is not ready 1
task1 is not ready 10
task2 is not ready 2task1 is not ready 11

task1 is not ready 12
task2 is not ready 3
task2 is not ready 4task1 is ready 9
task1 is not ready 0

task1 is not ready 1task2 is not ready 5

task2 is not ready 6
task1 is not ready 2
closing the channel
channel is closed
1 is done false
2 is done false
we start to wait the first time
task2 is done
task1 is done
task1 done true
task2 done true
We start to wait the second time
task1 done true
task2 done true

----




=== `die`

This function will throw an exception.
The argument is the message of the exception.
The naming of the function is a tribute to the programming language Perl.
If you feel offensive the naming, you can use the lame `throw` form after importing it:


.die
[source]
----

sys_import "turi.throw"

try:
    throw "wuff"
catch ex:
    print "don't die"


----




.output die
[source]
----
don't die
----




=== `yield()`, `try_yield()`, `yield_is_close()`

In an asynchronous thread you can get objects sent by the parent thread calling `yield()`.
This call will wait for an object and return it.
If the que from the parent thread is already closed, then `yield()` will throw an exception.

`try_yield()` is more lenient.
It does not wait and returns `none` if there is no message or the channel is closed.

`yield_is_close()` can be used to test of the que is open from the parent to the child thread.


.try_yield
[source]
----
fn printer(){
    let n = 0
    while {
        let s = try_yield();
        return { println "we are done" } if yield_is_closed();
        if s == none {
            println "not ready %s" % n
            n = n + 1
            sleep 0.003
        } else {
            n = 0
            println "received %s" % s;
        }
    }
}

let task : task = async printer()
for i=1 ; i < 4 ; i = i +1 {
 println "sending ",i
 task.send(i);
 sleep 0.009
 }
println "closing the channel"
task.close();
println "channel is closed"
println "is done %s" % task.is_done()
await task
println "is done %s" % task.is_done()

none


----




.output try_yield
[source]
----
sending 1not ready 0

received 1
not ready 0
not ready 1
sending 2
received 2
not ready 0
not ready 1
not ready 2
sending 3
received 3
not ready 0
not ready 1
not ready 2
closing the channel
channel is closed
is done false
we are done
is done true

----



=== Regular Expressions

Regular expression handling is implemented with two primitive functions `_rx()` and `_rx_match()`.
They start with the `_` character to signal that they are not to be used directly.
Instead, the code has to import the system file `re`:


.re
[source]
----
sys_import "turi.re"

fn print_match(m){
    for i=0 ; i < len(m.group) ; i = i + 1 {
        let {index, start, end } = m.group[i];
        println "%s. '%s'.substring(%s,%s)='%s'" % [index,s,start, end,s[start..end]];
    }
}

let s = "abrakadabra";
let rx =Re("a(b)ra(ka)(dabra)")
let m = rx.match(s);
println m
print_match(m);

s = "xxx"+s+"yyy";
m = rx.match(s);
if m.group == none :
    println "does not match because of xxx and yyy"
println m, " is an empty object"
m = rx.find(s)
if m.group != none :
    println "matches because we find and not match"
print_match(m);


----




.output re
[source]
----
{start: 0, name: {}, end: 11, group: [{start: 1, index: 1, end: 2}, {start: 4, index: 2, end: 6}, {start: 6, index: 3, end: 11}]}
1. 'abrakadabra'.substring(1,2)='b'
2. 'abrakadabra'.substring(4,6)='ka'
3. 'abrakadabra'.substring(6,11)='dabra'
does not match because of xxx and yyy
{} is an empty object
matches because we find and not match
1. 'xxxabrakadabrayyy'.substring(4,5)='b'
2. 'xxxabrakadabrayyy'.substring(7,9)='ka'
3. 'xxxabrakadabrayyy'.substring(9,14)='dabra'

----



You can create a regular expression object using `Re()`.
It has two methods:

* `match()` to match the whole string passed as argument, and

* `find()` to find a matching strign in the string.

If there is no match, the return value is an empty object.
If there is a match, then the return value is an object containing the matching groups.

Even if there are no matching groups the object is not empty as it will have an empty list field named `group`.

YOu can also use named arguments, that will get into the field `name`.
In the example above that field was empty.
In the following example we have named arguments:


.re2
[source]
----
sys_import "turi.re"

let m = Re("a(?<firstb>b)ra(?<twoletter>ka)(dabra)").match("abrakadabra");
println "the ks is '%s'" % [m.name.twoletter]


----




.output re2
[source]
----
the ks is '{start: 6, index: 3, end: 11}'

----



Each named argument contains the start, end and the index of the named group.

== Preprocessing

When the syntax analyzer meets a `#` symbol it stops parsing the tokens and starts preprocessing.
The steps of the preprocessing are the following:

. Parse the command following the `#` symbol.
This is the preprocessor command.
It has to be a macro, a function or a closure.

. Remove all the tokens from the token list that were already processed.

. Create a preprocessor context.

. Execute the commands that were parsed.
This will create global variables, functions and classes in the preprocessor context.

. Execute the command passing the list of tokens as the only argument.

. Remove all the tokens from the input and replace them with the token list returned by the preprocessor.

. If there are elements that are not tokens originating from the original list, parse them and convert each to a list of tokens.

When the remaining code is executed, the interpreter will use the preprocessor context.
If there is more than one preprocessor executed, they will share the same context.

The following example shows preprocessing that adds lines defining a global variable `M`,
defines a function `helvetic_hi()` and
sets the value of the variable `M` to `"hello hello"`.


.preprocessorSample
[source]
----
fn hi(){ // this will be deleted, it only exists in the preprocessor context
  "hello "
}
// the next line starts the preprocessor
# {|lexes|
["""
    // this is a string that will lead the new lexical token list
    let M:str = ""
    fn helvetic_hi(){
      "Gruetzi "
    }
    M = M + "hello ";
    M = M + (hi() or "none ");
""",
// and just let's have the rest of the tokens
..lexes]
} // end of the preprocessor command

// this is preprocessed
M = M + helvetic_hi() + "ant hunter"
print M


----




.output preprocessorSample
[source]
----
hello hello Gruetzi ant hunter
----



The example above is quite contrived.
Preprocessors are usually defined in imported files and invoked using a simple function call.

== Language Grammar (Appendix)

=== Full Annotated EBNF

The following is the non-standard EBNF definition of the programming language called Turicum.
Strings between ' characters are literal keywords.
Syntax between `[` and `]` are optional
Syntax between `{` and `}` are repeated zero or more times
Syntax between `(` and `)` is a group with alternatives
Alternative syntaxes are separated using the `|` character.
Non-terminal symbols are all capital letters.
EBNF non-terminals are followed by `::=` and then the definition closed by `;`
Non-literal terminal symbols are:

* IDENTIFIER
* number
* string

A program is a series of commands.
Commands may be separated by `;` character, and it is recommended to use it, but it is not required.
New line may replace the use of `;`.

 PROGRAM ::= { COMMAND [;] } ;

Commands also have values. It is the __result__ of the command.

 COMMAND ::=  IF |
              LOOP |
              CLASS |
              FN |
              LOCAL | GLOBAL | PIN
              BREAK | YIELD | RETURN |
              TRY |
              ASSIGNMENT |
              EXPRESSION |
              ;

 LOOP ::= ('while' [EXPRESSION] ( BLOCK | ':' COMMAND ) |
           'for' COMMAND ';' [EXPRESSION] ';' COMMAND ( BLOCK | ':' COMMAND ) |
           'for' '(' COMMAND [EXPRESSION] COMMAND ')' (  BLOCK | ':' COMMAND )  |
           'for each' identifier 'in' EXPRESSION ( BLOCK | ':' COMMAND ) |
           'for each' '(' identifier 'in' EXPRESSION ')' (  BLOCK | ':' COMMAND )
          ) [ 'until' EXPRESSION]
 ;

If the condition expression is missing after 'for' or 'while' it is `true`.
The expression following the 'until' is not optional, but the whole `until` `EXPRESSION` part is.
The value of a loop is the last __executed__ command.
Equivalent to: `for(init; condition; step)`

The value of an `IF` command is the value of the first or the second block, whichever is executed.
If the condition expression is false and there is no second block, then the value is `none`.

 IF ::= 'if' EXPRESSION ( ':' COMMAND | BLOCK ) [ 'else' ( ':' COMMAND | BLOCK )] ;

The result of a CLASS declaration is the class itself.

 CLASS ::= 'class' [IDENTIFIER] [ ':' IDENTIFIER_LIST ] BLOCK ;

The result of a function declaration is the function itself.

 FN ::= FN_EXPR | FN_BLOCK ;

For functions with an expression body following a '=' the parameter list is mandatory.
The parameter list may be empty having only '(' and ')'

 FN_EXPR   ::= 'fn' [ IDENTIFIER ] '(' IDENTIFIER_LIST ')' '=' EXPRESSION ;

For functions with a block body, both the function name and parameter list are optional, but you must have at least one of them.

 FN_BLOCK  ::= 'fn' [ IDENTIFIER ] [ '(' IDENTIFIER_LIST ')' ] BLOCK ;

Variables declared as local will be local to the scope, even if the same name is used in some enclosing scope
or as a global variable
the value of the local declaration is the value of the last assignment in the command

 LOCAL ::= 'let' IDENTIFIER_ASSIGNMENT_LIST |
           'let' '{' TYPED_IDENTIFIER_LIST '}' '=' EXPRESSION|
           'let' '[' TYPED_IDENTIFIER_LIST ']' '=' EXPRESSION ;

Variables declared global will refer to the global variable.
The value of the global declaration is the value of the last assignment in the command.

 GLOBAL ::= 'global' IDENTIFIER_ASSIGNMENT_LIST;

Variables pinned cannot be changed in the local scope.
Pinning has no effect to outer scopes.
You can also pin an object. In that case use `{variable}` instead of the name.

 PIN ::= 'pin' IDENTIFIER_ASSIGNMENT_LIST;

 IDENTIFIER_ASSIGNMENT_LIST ::= [identifier [: TYPE_DEFINITION ] ['=' expression]]
                                    { ',' identifier [: TYPE_DEFINITION ] [ '=' expression] };

 TYPED_IDENTIFIER_LIST ::= identifier [: TYPE_DEFINITION ]
                                    { ',' identifier [: TYPE_DEFINITION ] };

 TYPE_DEFINITION ::= TYPE_NAME { '|' TYPE_NAME }

 TYPE_NAME ::= IDENTIFIER

It is valid to have no identifiers in an identifier list, a.k.a. having an empty identifier list

 IDENTIFIER_LIST ::= [ IDENTIFIER { ',' IDENTIFIER } ];

Using '=' updates a variable but never creates a new one. It first has to be created using `let`.

 ASSIGNMENT ::= LEFT_VALUE '=' EXPRESSION ;
 LEFT_VALUE ::= IDENTIFIER { '.' IDENTIFIER | '[' EXPRESSION ']'};
 EXPRESSION ::= BINARY_EXPRESSION[0];

Define precedence levels using indexed rules

 N=10;
 BINARY_EXPRESSION[i <N ] ::= BINARY_EXPRESSION[i+1] { BINARY_OPERATOR[i] BINARY_EXPRESSION[i+1] };
 BINARY_EXPRESSION[i == N] ::= UNARY_EXPRESSION  ;// Highest precedence level

Unary operators and primary expressions

 UNARY_EXPRESSION ::= PREFIX_UNARY_OPERATOR UNARY_EXPRESSION | PRIMARY_EXPRESSION;

 PRIMARY_EXPRESSION ::= number | string
 | FN
 | CLASS
 | IDENTIFIER
 | '(' EXPRESSION ')'
 | FUNCTION_CALL
 | FIELD_ACCESS
 | METHOD_CALL
 | BLOCK
 | ARRAY_ACCESS
 ;

Function call: name(params)

 FUNCTION_CALL ::= IDENTIFIER '(' [ EXPRESSION { ',' EXPRESSION } ] ')' ;

Field access: obj.field

 FIELD_ACCESS ::= PRIMARY_EXPRESSION '.' IDENTIFIER ;

Method call: obj.method(params)

 METHOD_CALL ::= PRIMARY_EXPRESSION '.' IDENTIFIER '(' [ EXPRESSION { ',' EXPRESSION } ] ')' ;

Block returning an expression value. The value of the block is always the last executed expression.

 BLOCK ::= '{' { COMMAND [';'] } '}' ;

 BREAK  ::= 'break' CONDITIONAL_VALUE ;
 RETURN  ::= 'return' CONDITIONAL_VALUE ;
 YIELD ::= 'yield' CONDITIONAL_VALUE ;
 CONDITIONAL_VALUE = EXPRESSION [ ('if' | 'when') EXPRESSION ];

Array element access: array[index]

 ARRAY_ACCESS ::= PRIMARY_EXPRESSION '[' EXPRESSION ']' ;

Unary operators

 PREFIX_UNARY_OPERATOR ::= '+' | '-' | '!' ;

Binary operators grouped by precedence (higher index = higher precedence)

 BINARY_OPERATOR[0] ::= '||' ; Lowest precedence
 BINARY_OPERATOR[1] ::= '&&' ;
 BINARY_OPERATOR[2] ::= '|' ;
 BINARY_OPERATOR[3] ::= '^' ;
 BINARY_OPERATOR[4] ::= '&' ;
 BINARY_OPERATOR[5] ::= '==' | '!=' ;
 BINARY_OPERATOR[6] ::= '<' | '<=' | '>' | '>=' ;
 BINARY_OPERATOR[7] ::= '<<' | '>>' ;
 BINARY_OPERATOR[8] ::= '+' | '-' ;
 BINARY_OPERATOR[9] ::= '*' | '/' | '%' ; Highest precedence for binary ops